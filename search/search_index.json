{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About me","text":"<p>Cuenta: 199064</p> <p>Este es mi portafolio personal, donde voy a publicar todos mis avances, procedimientos, observaciones y resultados de mis proyectos dentro de mi carrera a partir del quinto semestre.  </p> <p>Me llamo Oscar Guzman Jorge, soy un alumno que cursa la carrera de mecatr\u00f3nica en la Universidad Iberoamericana Puebla, actualmente, en Agosto de 2025 tengo 20 a\u00f1os. Estoy cursando el quinto semestre, pero he hecho numerosos aportes personales (IEEE) y para mi universidad.</p>"},{"location":"Ejemplos%20y%20Gu%C3%ADas/comandos/","title":"Encabezados","text":"<pre><code># T\u00edtulo H1\n## T\u00edtulo H2\n### T\u00edtulo H3\n</code></pre>"},{"location":"Ejemplos%20y%20Gu%C3%ADas/comandos/#titulo-h1","title":"T\u00edtulo H1","text":""},{"location":"Ejemplos%20y%20Gu%C3%ADas/comandos/#titulo-h2","title":"T\u00edtulo H2","text":""},{"location":"Ejemplos%20y%20Gu%C3%ADas/comandos/#titulo-h3","title":"T\u00edtulo H3","text":""},{"location":"Ejemplos%20y%20Gu%C3%ADas/comandos/#enfasis-y-codigo-en-linea","title":"\u00c9nfasis y c\u00f3digo en l\u00ednea","text":"<pre><code>**negritas**, *cursivas*, ~~tachado~~, `c\u00f3digo en l\u00ednea`\n</code></pre> <p>negritas, cursivas, ~~tachado~~, <code>c\u00f3digo en l\u00ednea</code></p>"},{"location":"Ejemplos%20y%20Gu%C3%ADas/comandos/#citas-blockquote","title":"Citas (blockquote)","text":"<pre><code>&gt; Esta es una cita destacada.\n&gt; Puede tener m\u00faltiples l\u00edneas.\n</code></pre> <p>Esta es una cita destacada. Puede tener m\u00faltiples l\u00edneas.</p>"},{"location":"Ejemplos%20y%20Gu%C3%ADas/comandos/#enlaces","title":"Enlaces","text":"<pre><code>[Enlace directo](https://www.iberopuebla.mx/)\n\n[Texto del enlace de referencia][doc-ref]\n\n[doc-ref]: https://www.iberopuebla.mx//docs \"T\u00edtulo opcional\"\n</code></pre> <p>Enlace directo</p> <p>Texto del enlace de referencia</p>"},{"location":"Ejemplos%20y%20Gu%C3%ADas/comandos/#listas-vinetas-numeradas-y-de-tareas","title":"Listas: vi\u00f1etas, numeradas y de tareas","text":"<pre><code>- Item A\n    * Subitem A.1\n    * Subitem A.2\n- Item B\n    - Subitem B.1\n    - Subitem B.2\n\n1.  Paso 1\n    1.  Paso 1.1\n    2.  Paso 1.2\n        1.  Paso 1.2.1\n        2.  Paso 1.2.2\n\n- [x] Hecho\n- [ ] Pendiente\n</code></pre> <ul> <li>Item A<ul> <li>Subitem A.1</li> <li>Subitem A.2</li> </ul> </li> <li>Item B<ul> <li>Subitem B.1</li> <li>Subitem B.2</li> </ul> </li> </ul> <ol> <li> <p>Paso 1</p> <ol> <li>Paso 1.1</li> <li>Paso 1.2<ol> <li>Paso 1.2.1</li> <li>Paso 1.2.2</li> </ol> </li> </ol> </li> <li> <p> Hecho</p> </li> <li> Pendiente</li> </ol>"},{"location":"Ejemplos%20y%20Gu%C3%ADas/comandos/#tablas","title":"Tablas","text":"<pre><code>| Componente | Cant. | Nota        |\n|-----------:|:-----:|-------------|\n| Sensor X   | 2     | I2C         |\n| MCU Y      | 1     | WiFi/BLE    |\n</code></pre> Componente Cant. Nota Sensor X 2 I2C MCU Y 1 WiFi/BLE"},{"location":"Ejemplos%20y%20Gu%C3%ADas/comandos/#imagenes","title":"Im\u00e1genes","text":"<pre><code>![Diagrama del sistema](recursos/imgs/ibero.jpeg)\n\n&lt;!-- Control de tama\u00f1o usando HTML (cuando se requiera) --&gt;\n&lt;img src=\"../recursos/imgs/ibero.jpeg\" alt=\"Diagrama del sistema\" width=\"420\"&gt;\n</code></pre>"},{"location":"Ejemplos%20y%20Gu%C3%ADas/comandos/#pdfs-enlace-y-embebido","title":"PDFs (enlace y embebido)","text":"<pre><code>[Descargar especificaci\u00f3n (PDF)](recursos/archivos/Calendario.pdf)\n\n&lt;!-- Embed (requiere navegador compatible) --&gt;\n&lt;object data=\"recursos/archivos/Calendario.pdf\" type=\"application/pdf\" width=\"100%\" height=\"600\"&gt;\n  &lt;p&gt;No se pudo mostrar el PDF. &lt;a href=\"../recursos/archivos/Calendario.pdf\"&gt;Descargar&lt;/a&gt;&lt;/p&gt;\n&lt;/object&gt;\n</code></pre> <p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"Ejemplos%20y%20Gu%C3%ADas/comandos/#admonitions-material","title":"Admonitions (Material)","text":"<pre><code>!!! note \"Nota\"\n    Esto es una nota informativa.\n\n!!! tip \"Sugerencia\"\n    Un consejo breve para el usuario.\n\n!!! warning \"Advertencia\"\n    Precauciones o riesgos a considerar.\n\n??? info \"M\u00e1s informaci\u00f3n (colapsable)\"\n    Contenido adicional que se puede expandir.\n</code></pre> <p>Nota</p> <p>Esto es una nota informativa.</p> <p>Sugerencia</p> <p>Un consejo breve para el usuario.</p> <p>Advertencia</p> <p>Precauciones o riesgos a considerar.</p> M\u00e1s informaci\u00f3n (colapsable) <p>Contenido adicional que se puede expandir.</p>"},{"location":"Ejemplos%20y%20Gu%C3%ADas/comandos/#codigo-con-resaltado","title":"C\u00f3digo con resaltado","text":"<p><pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre> <pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre></p>"},{"location":"Ejemplos%20y%20Gu%C3%ADas/comandos/#separador-horizontal","title":"Separador horizontal","text":"<pre><code>---\n</code></pre>"},{"location":"Ejemplos%20y%20Gu%C3%ADas/comandos/#listas-anidadas-con-codigo-y-notas","title":"Listas anidadas con c\u00f3digo y notas","text":"<pre><code>- **M\u00f3dulo A**\n  - Funci\u00f3n: `procesar()`\n  - Entrada:\n    - `signal` (float)\n    - `freq` (Hz)\n  - Salida:\n    - JSON con `valor`, `unidad`\n  - !!! note\n        Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> <ul> <li>M\u00f3dulo A</li> <li>Funci\u00f3n: <code>procesar()</code></li> <li>Entrada:<ul> <li><code>signal</code> (float)</li> <li><code>freq</code> (Hz)</li> </ul> </li> <li>Salida:<ul> <li>JSON con <code>valor</code>, <code>unidad</code></li> </ul> </li> <li> <p>Note</p> <pre><code>Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> </li> </ul>"},{"location":"Ejemplos%20y%20Gu%C3%ADas/comandos/#bloques-de-cita-con-codigo-pseudo-logs","title":"Bloques de cita con c\u00f3digo (pseudo-logs)","text":"<pre><code>&gt; **Log:**\n&gt; ```\n&gt; [12:00:00] Init OK\n&gt; [12:00:01] Conectando a I2C...\n&gt; [12:00:02] Lectura: 523 mV\n&gt; ```\n</code></pre> <p>Log: <pre><code>[12:00:00] Init OK\n[12:00:01] Conectando a I2C...\n[12:00:02] Lectura: 523 mV\n</code></pre></p>"},{"location":"Ejemplos%20y%20Gu%C3%ADas/ejemplo/","title":"\ud83d\udcda Ejemplo de Documentaci\u00f3n del Proyecto","text":"<p>Plantilla gen\u00e9rica para documentar proyectos acad\u00e9micos o de ingenier\u00eda. Copia y adapta las secciones seg\u00fan tu necesidad.</p>"},{"location":"Ejemplos%20y%20Gu%C3%ADas/ejemplo/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Mi Proyecto </li> <li>Equipo / Autor(es): Nombre(s) </li> <li>Curso / Asignatura: Nombre del curso </li> <li>Fecha: DD/MM/AAAA </li> <li>Descripci\u00f3n breve: Una o dos l\u00edneas que expliquen qu\u00e9 hace y por qu\u00e9.</li> </ul> <p>Consejo</p> <p>Mant\u00e9n este resumen corto (m\u00e1x. 5 l\u00edneas). Lo dem\u00e1s va en secciones espec\u00edficas.</p>"},{"location":"Ejemplos%20y%20Gu%C3%ADas/ejemplo/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Qu\u00e9 se pretende lograr en t\u00e9rminos amplios.</li> <li>Espec\u00edficos:</li> <li>OE1\u2026</li> <li>OE2\u2026</li> <li>OE3\u2026</li> </ul>"},{"location":"Ejemplos%20y%20Gu%C3%ADas/ejemplo/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: Qu\u00e9 funcionalidades/entregables s\u00ed est\u00e1n en el proyecto.</li> <li>No incluye: Qu\u00e9 queda fuera para evitar malentendidos.</li> </ul>"},{"location":"Ejemplos%20y%20Gu%C3%ADas/ejemplo/#4-requisitos","title":"4) Requisitos","text":"<p>Software - SO compatible (Windows/Linux/macOS) - Python 3.x / Node 18+ / Arduino IDE / etc. - Dependencias (p. ej., pip/requirements, npm packages)</p> <p>Hardware (si aplica) - MCU / Sensores / Actuadores / Fuente de poder - Herramientas (mult\u00edmetro, caut\u00edn, etc.)</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en X - Electr\u00f3nica b\u00e1sica - Git/GitHub</p>"},{"location":"Ejemplos%20y%20Gu%C3%ADas/ejemplo/#5-instalacion","title":"5) Instalaci\u00f3n","text":"<pre><code># 1) Clonar\ngit clone https://github.com/&lt;usuario&gt;/&lt;repo&gt;.git\ncd &lt;repo&gt;\n\n# 2) (Opcional) Crear entorno virtual\npython -m venv .venv\n# macOS/Linux\nsource .venv/bin/activate\n# Windows (PowerShell)\n.venv\\Scripts\\Activate.ps1\n\n# 3) Instalar dependencias (ejemplos)\npip install -r requirements.txt\n# o, si es Node:\nnpm install\n</code></pre>"},{"location":"Ejemplos%20y%20Gu%C3%ADas/gitcmds/","title":"\ud83d\ude80 Comandos b\u00e1sicos de Git (primeros pasos)","text":"<p>En este curso solo usaremos los comandos esenciales de Git para trabajar con repositorios.</p>"},{"location":"Ejemplos%20y%20Gu%C3%ADas/gitcmds/#1-clonar-un-repositorio","title":"1. Clonar un repositorio","text":"<p>Copia un proyecto de GitHub a tu computadora.</p> <pre><code>git clone https://github.com/usuario/repositorio.git\n</code></pre>"},{"location":"Ejemplos%20y%20Gu%C3%ADas/gitcmds/#2-verificar-cambios","title":"2. Verificar cambios","text":"<p>Muestra qu\u00e9 archivos has modificado o agregado.</p> <pre><code>git status\n</code></pre>"},{"location":"Ejemplos%20y%20Gu%C3%ADas/gitcmds/#3-preparar-cambios","title":"3. Preparar cambios","text":"<p>Agrega archivos para guardarlos en el pr\u00f3ximo commit.</p> <pre><code>git add archivo.txt\ngit add .   # agrega todos los archivos modificados\n</code></pre>"},{"location":"Ejemplos%20y%20Gu%C3%ADas/gitcmds/#4-guardar-cambios-commit","title":"4. Guardar cambios (commit)","text":"<p>Guarda tus cambios con un mensaje descriptivo.</p> <pre><code>git commit -m \"Descripci\u00f3n breve de los cambios\"\n</code></pre>"},{"location":"Ejemplos%20y%20Gu%C3%ADas/gitcmds/#5-subir-cambios-al-repositorio-push","title":"5. Subir cambios al repositorio (push)","text":"<p>Env\u00eda tus commits locales al repositorio en GitHub.</p> <pre><code>git push origin main\n</code></pre>"},{"location":"Ejemplos%20y%20Gu%C3%ADas/gitcmds/#6-traer-cambios-del-remoto-pull","title":"6. Traer cambios del remoto (pull)","text":"<p>Actualiza tu proyecto con los \u00faltimos cambios de GitHub.</p> <pre><code>git pull origin main\n</code></pre>"},{"location":"Ejemplos%20y%20Gu%C3%ADas/gitcmds/#flujo-tipico-de-trabajo","title":"Flujo t\u00edpico de trabajo","text":"<ol> <li> <p>Traer cambios del remoto <pre><code>git pull origin main\n</code></pre></p> </li> <li> <p>Editar tus archivos de proyecto.</p> </li> <li> <p>Preparar los cambios <pre><code>git add .\n</code></pre></p> </li> <li> <p>Guardar los cambios <pre><code>git commit -m \"Mensaje descriptivo\"\n</code></pre></p> </li> <li> <p>Enviar los cambios al remoto <pre><code>git push origin main\n</code></pre></p> </li> </ol> <p>Consejo</p> <p>Piensa en este ciclo como un loop infinito: cada vez que quieras contribuir \u2192 primero <code>pull</code>, despu\u00e9s <code>add</code> + <code>commit</code>, y finalmente <code>push</code>.</p>"},{"location":"ProyectoDeIng4/Proyecto/","title":"Propuesta de proyecto","text":""},{"location":"ProyectoDeIng4/Proyecto/#sensor-de-rayos-uv","title":"Sensor de rayos UV","text":"<p>Los rayos UV son uno de los problemas m\u00e1s comunes del d\u00eda a d\u00eda para la salud, ya que la exposici\u00f3n prolongada puede ocasionar desde da\u00f1os leves, envejecimiento acelerado, generaci\u00f3n de acn\u00e9 o incluso enfermedades terminales en la piel.</p> <p>La mayor parte de los da\u00f1os graves son gracias al descuido o desinformaci\u00f3n sobre el impacto del nivel y la alta exposici\u00f3n a los rayos UV. Esto es muy riesgoso, sobretodo en nuestra generaci\u00f3n actual, ya que gracias a la contaminaci\u00f3n ambiental y la reducci\u00f3n de la capa de ozono estamos viviendo con el nivel de rayos UV m\u00e1s alto registrado hasta la fecha.</p> <p>Nuestra propuesta es construir un sensor de monitorizaci\u00f3n de rayos UV barato y personalizable seg\u00fan tu fisionom\u00eda de la piel , que monitoree en tiempo real la cantidad de rayos UV que est\u00e1 recibiendo, y accione una alarma que te avise si es necesario ponerse bloqueador, volverse a poner o si no es necesario, podr\u00e1 ser implementado en diveros equipajes (mochilas, loncheras, bolsas, tableros de auto, etc.).</p>"},{"location":"ProyectoDeIng4/Proyecto/#caracteristicas-que-debe-de-tener-el-producto","title":"Caracter\u00edsticas que debe de tener el producto:","text":"<p>Debe de ser capaz de detectar en tiempo real los niveles de rayos UV en el ambiente y mostrar una alarma o notificaci\u00f3n, alertando del riesgo para la piel a tiempo para evitar en mayor medida un da\u00f1o f\u00edsico. Debe de ser barato, confiable, f\u00e1cil de construir, con un dise\u00f1o amigable, port\u00e1til y f\u00e1cil de implementar.</p>"},{"location":"ProyectoDeIng4/Proyecto/#link-de-la-presentacion","title":"Link de la presentaci\u00f3n","text":"<p>Presentaci\u00f3n de ideas.</p>"},{"location":"ProyectoDeIng4/Proyecto/#boceto","title":"Boceto","text":""},{"location":"ProyectoDeIng4/Proyecto/#tarea-1-syllabus-firmado","title":"Tarea 1 SYLLABUS Firmado","text":"<p>\ud83d\udcc4 Ver y descargar PDF del Syllabus firmado</p>"},{"location":"ProyectoDeIng4/Proyecto/#tarea-2-investigacion-de-maquinas-de-capsulas-de-cafe","title":"TAREA 2 Investigaci\u00f3n de m\u00e1quinas de c\u00e1psulas de caf\u00e9","text":"<p>Caf\u00e9 de c\u00e1psulas</p>"},{"location":"ProyectoDeIng4/Proyecto/#tarea-3-diagrama-de-gantt","title":"TAREA 3 Diagrama de Gantt","text":"<p>Diagrama de Gantt proyecto</p>"},{"location":"ProyectoDeIng4/Proyecto/#tarea-4-marco-real-ganar-vale-la-pena-aplicado-a-mi-proyecto","title":"TAREA 4 Marco \u201creal-ganar-vale la pena\u201d aplicado a mi proyecto","text":"<p>Real-Ganar Vale la pena</p>"},{"location":"ProyectoDeIng4/Proyecto/#paginas-de-trabajo-en-tiempo-real","title":"P\u00e1ginas de trabajo en tiempo real","text":"<p>P\u00e1gina de Trello</p> <p>P\u00e1gina de Jira</p>"},{"location":"ProyectoDeIng4/Proyecto/#tarea-5-mercado-y-diagrama-porter","title":"TAREA 5 Mercado y diagrama Porter","text":"<p>IDEO Buisness</p> <p>Sensor de rayos UV</p> <p>Diagrama de Porter</p> <p>Insightful</p> <p>Costo de arranque</p>"},{"location":"ProyectoDeIng4/Proyecto/#costos-del-excell","title":"Costos del Excell","text":"<p>Hicimos una tabla de costos para nuestro prototipo con el objetivo de tener una visi\u00f3n clara y organizada de los recursos necesarios para su desarrollo desde cero. En ella se desglosan tanto los costos de producci\u00f3n \u2014como materiales, componentes electr\u00f3nicos, herramientas y mano de obra\u2014, como los costos de distribuci\u00f3n que se planean adoptar, incluyendo empaque, transporte y posibles canales de venta. Esta tabla nos permite estimar el presupuesto total, evaluar la viabilidad econ\u00f3mica del proyecto y planificar una estrategia de producci\u00f3n sostenible, asegurando que el prototipo no solo sea funcional, sino tambi\u00e9n accesible y realista para su futura implementaci\u00f3n o comercializaci\u00f3n.</p> <p>Creando la oferta Al crear la oferta de nuestro producto, es necesario dividir los costos individuales que se requieren para la producci\u00f3n unitaria de dicha prototipo, de manera que se pueda crear un an\u00e1lisis en relaci\u00f3n a un a\u00f1o (nosotros elegimos un a\u00f1o) de cu\u00e1nto costar\u00eda la producci\u00f3n de una cantidad determinada del producto terminado.</p> <p>En este caso, nosotros separamos nuestros costos de manera que se pueda identificar, cu\u00e1les son aquellos que diferencian a nuestro producto de los dem\u00e1s.</p> <p>Dsitribuci\u00f3n del producto La distribuci\u00f3n del producto es ESENCIAL para la creaci\u00f3n y venta de una idea, ya que se tiene que considerar \u00bfa qui\u00e9n? y \u00bfc\u00f3mo? vas a hacer llegar tu idea.</p> <p>Costos dermasense (Excell)</p>"},{"location":"SistemasEmbebidos/Examenes/","title":"Examenes Del Curso","text":""},{"location":"SistemasEmbebidos/Examenes/#primer-parcial-simon-dice","title":"Primer Parcial: Sim\u00f3n Dice","text":"<p>En este parcial, nuestro reto consisti\u00f3 en hacer utilizando todos los conocimientos previos un juego de sim\u00f3n dice en raspberry Pi Pico 2, con las siguientes normas:</p> <p>1.- La secuencia crece +1 por ronda, de 1 hasta 15.</p> <p>2.- La persona jugadora debe repetir la secuencia con 4 botones dentro de un tiempo l\u00edmite por ronda (En nuestro caso se anul\u00f3 esta regla porque Sebasti\u00e1n qued\u00f3 en podio del Kahoot).</p> <p>3.- Tiempo l\u00edmite por ronda (fase de entrada): TL = longitud + 5 segundos (p. ej., Ronda 7 \u2192 12 s). (No lo aplicamos).</p> <p>4.- Puntaje (0\u201315): mostrar la m\u00e1xima ronda alcanzada en un display de 7 segmentos en hex (0\u20139, A, b, C, d, E, F).</p> <p>5.- Aleatoriedad obligatoria: la secuencia debe ser impredecible en cada ejecuci\u00f3n.</p>"},{"location":"SistemasEmbebidos/Examenes/#reglas-del-juego-obligatorias","title":"Reglas del juego (obligatorias):","text":"<p>1.- Encendido/Reset: el 7 segmentos muestra \u201c0\u201d y queda en espera de Start (cualquier bot\u00f3n permite iniciar).</p> <p>2.- Reproducci\u00f3n: mostrar la secuencia actual (LEDs uno por uno con separaci\u00f3n clara).</p> <p>3.- Entrada: al terminar la reproducci\u00f3n, la persona debe repetir la secuencia completa dentro de TL.</p> <p>4.- Fallo (Game Over): bot\u00f3n incorrecto, falta/extra de entradas o exceder TL.</p> <p>5.- Progresi\u00f3n: si acierta, puntaje = n\u00famero de ronda, agrega 1 color aleatorio y avanza.</p> <p>6.- Fin: al fallar o completar la Ronda 15. Mostrar puntaje final en 7 segmentos (hex).</p>"},{"location":"SistemasEmbebidos/Examenes/#programa","title":"Programa","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/adc.h\"\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n\n#define Rondas 15\n#define Parpadeo 400\n#define Pausa 250\n#define Debounce 50\n\n#define LED0 0\n#define LED1 1\n#define LED2 3\n#define LED3 4\n\n#define BTN0 27\n#define BTN1 28\n#define BTN2 14\n#define BTN3 15\n\n#define SegmentoA  16\n#define SegmentoB  17\n#define SegmentoC  18\n#define SegmentoD 26\n#define SegmentoDp  20\n#define SegmentoE  21\n#define SegmentoF  22\n#define SegmentoG  2\n\n// arrays de pines para recorrer\nconst uint LEDS[4] = {LED0, LED1, LED2, LED3};\nconst uint Botones[4] = {BTN0, BTN1, BTN2, BTN3};\nconst uint Segmentos[8] = {SegmentoA, SegmentoB, SegmentoC, SegmentoDp, SegmentoE, SegmentoF, SegmentoG, SegmentoD};\n\n//\u00c1nodo com\u00fan, 0=1, 1=0\nconst bool MapaDisplay[16][8] = {\n    {0,0,0,0,0,0,1,1}, // 0\n    {1,0,0,1,1,1,1,1}, // 1\n    {0,0,1,0,0,1,0,1}, // 2\n    {0,0,0,0,1,1,0,1}, // 3\n    {1,0,0,1,1,0,0,1}, // 4\n    {0,1,0,0,1,0,0,1}, // 5\n    {0,1,0,0,0,0,0,1}, // 6\n    {0,0,0,1,1,1,1,1}, // 7\n    {0,0,0,0,0,0,0,1}, // 8\n    {0,0,0,0,1,0,0,1}, // 9\n    {0,0,0,1,0,0,0,1}, // A\n    {1,1,0,0,0,0,0,1}, // b\n    {0,1,1,0,0,0,1,1}, // C\n    {1,0,0,0,0,1,0,1}, // d\n    {0,1,1,0,0,0,0,1}, // E\n    {0,1,1,1,0,0,0,1}  // F\n};\n\nuint8_t Sequencia[Rondas];\nint Num_sequencia = 0;\n\nvoid MuestraDisplay(uint8_t n) {\n    for (int i = 0; i &lt; 8; i++) {\n        gpio_put(Segmentos[i], MapaDisplay[n &amp; 0xF][i]);\n    }\n}\n\nvoid Blink(uint8_t iL, uint32_t ms) {\n    gpio_put(LEDS[iL], 1);\n    sleep_ms(ms);\n    gpio_put(LEDS[iL], 0);\n}\n\nint PresionaBoton() {\n    while (1) {\n        for (int i = 0; i &lt; 4; i++) {\n            if (!gpio_get(Botones[i])) { \n                sleep_ms(Debounce);\n                while (!gpio_get(Botones[i])); \n                return i;\n            }\n        }\n        sleep_ms(10);\n    }\n}\n\nvoid EsperarBoton() {\n    while (1) {\n        for (int i = 0; i &lt; 4; i++) {\n            if (!gpio_get(Botones[i])) {\n                sleep_ms(Debounce);\n                while (!gpio_get(Botones[i])); // espera a quitar el bot\u00f3n presionado\n                return;\n            }\n        }\n        sleep_ms(10);\n    }\n}\n\nvoid IniciarLeds() {\n    for (int i = 0; i &lt; 4; i++) {\n        gpio_init(LEDS[i]);\n        gpio_set_dir(LEDS[i], true);\n    }\n}\n\nvoid IniciarBotones() {\n    for (int i = 0; i &lt; 4; i++) {\n        gpio_init(Botones[i]);\n        gpio_set_dir(Botones[i], false);\n        gpio_pull_up(Botones[i]);\n    }\n}\n\nvoid IniciarDisplay() {\n    for (int i = 0; i &lt; 8; i++) {\n        gpio_init(Segmentos[i]);\n        gpio_set_dir(Segmentos[i], true);\n    }\n}\n\n// Reproduce la secuencia actual\nvoid ReproducirSecuencia(int lim) {\n    sleep_ms(300);\n    for (int i = 0; i &lt; lim; i++) {\n        Blink(Sequencia[i], Parpadeo);\n        sleep_ms(Pausa);\n    }\n}\n\n// Game Over\nvoid GameOver(uint8_t score) {\n    MuestraDisplay(score &gt; 15 ? 15 : score);\n\n\n    for (int j = 0; j &lt; 6; j++) {\n        for (int i = 0; i &lt; 4; i++) gpio_put(LEDS[i], 1);\n        sleep_ms(120);\n        for (int i = 0; i &lt; 4; i++) gpio_put(LEDS[i], 0);\n        sleep_ms(120);\n    }\n\n\n    EsperarBoton();\n\n    Num_sequencia = 0;\n    MuestraDisplay(0);\n}\n\n// Genera un nuevo color aleatorio y lo agrega a la secuencia\nvoid SiguienteRonda() {\n    Sequencia[Num_sequencia++] = rand() &amp; 0x3;\n    if (Num_sequencia &gt; Rondas) Num_sequencia = Rondas;\n}\n\nbool PresionarSecuencia() { //La funci\u00f3n que tiene que hacer el jugador f\u00edsicamente\n    for (int i = 0; i &lt; Num_sequencia; i++) {\n        int presionar = PresionaBoton();\n        Blink(presionar, 120);\n        if (presionar != Sequencia[i]) return false;\n    }\n    return true;\n}\n\n\n\nint main() {\n    stdio_init_all();\n    IniciarLeds();\n    IniciarBotones();\n    IniciarDisplay();\n\n    // Aleatoriedad: ADC + tiempo\n    adc_init();\n    adc_gpio_init(26);\n    adc_select_input(0);\n    uint16_t noise = adc_read();\n    srand(to_us_since_boot(get_absolute_time()) ^ noise);\n\n    MuestraDisplay(0);\n\n    while (1) {\n\n        EsperarBoton();\n\n        while (1) {\n            SiguienteRonda();\n            MuestraDisplay(Num_sequencia);\n            sleep_ms(400);\n            ReproducirSecuencia(Num_sequencia);\n\n            bool Correcto = PresionarSecuencia();\n\n            if (!Correcto) {\n                GameOver(Num_sequencia - 1);\n                break; // reinicia juego\n            }\n\n            if (Num_sequencia &gt;= Rondas) {\n                GameOver(Rondas);\n                break; // reinicia juego\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"SistemasEmbebidos/Examenes/#diagrama-y-video","title":"Diagrama y video","text":""},{"location":"SistemasEmbebidos/Examenes/#segundo-parcial-control-de-servomotor","title":"Segundo Parcial: Control de Servomotor","text":"<p>En este parcial, nuestro reto consisti\u00f3 en utilizar la conexi\u00f3n con el puerto serial de una raspberry pi pico 2 y hacer un programa en C++ de multifase para mover un sevomotor, con configuraciones que t\u00fa puedes establecer, borrar, reproducir indefinidamente o moverlo paso a paso con botones, las reglas son las siguientes:</p>"},{"location":"SistemasEmbebidos/Examenes/#reglas-del-servoobligatorias","title":"Reglas del servo(obligatorias):","text":"<p>Hardware m\u00ednimo</p> <p>1 \u00d7 servomotor en un pin PWM (50 Hz).</p> <p>3 \u00d7 botones:</p> <p>BTN_MODE: cambia el modo activo (c\u00edclico: Entrenamiento \u2192 Continuo \u2192 Step \u2192 \u2026).</p> <p>BTN_NEXT: avanza a la siguiente posici\u00f3n (s\u00f3lo en Step).</p> <p>BTN_PREV: retrocede a la posici\u00f3n anterior (s\u00f3lo en Step).</p> <p>Pi pico 2</p> <p>Modos de operaci\u00f3n 1) Modo Entrenamiento Se recibe texto por USB-serial con los comandos siguientes (se aceptan min\u00fasculas/may\u00fasculas indistintamente y tambi\u00e9n sus alias en ingl\u00e9s):</p> <p>Borrar (alias: clear, borrar)</p> <p>Sintaxis: Borrar</p> <p>Efecto: elimina la lista completa de posiciones.</p> <p>Respuesta: OK.</p> <p>Escribir (alias: write, escribir)</p> <p>Sintaxis: Escribir, v1, v2, ..., vn</p> <p>vi son enteros en 0\u2013180.</p> <p>Efecto: sobrescribe la lista con los valores dados en ese orden.</p> <p>Respuesta: OK si todos son v\u00e1lidos y la lisa de posiciones; si alguno est\u00e1 fuera de rango o la lista queda vac\u00eda \u2192 Error argumento invalido.</p> <p>Reemplazar (alias: replace, reemplazar)</p> <p>Sintaxis: Reemplazar, i, v</p> <p>\u00cdndice i en base 1 (1 = primera posici\u00f3n).</p> <p>v en 0\u2013180.</p> <p>Efecto: reemplaza el elemento i por v.</p> <p>Respuesta: OK. Si i no existe \u2192 Error indice invalido. Si v fuera de rango \u2192 Error argumento invalido.</p> <p>2) Modo Continuo Recorre todas las posiciones de la lista en orden, moviendo el servo e imprimiendo cada 1.5 s:</p> <p>Formato: posX: V (por ejemplo, pos1: 90), donde X es base 1.</p> <p>Si la lista est\u00e1 vac\u00eda: imprimir cada 1.5 s Error no hay pos y no mover el servo.</p> <p>Al cambiar a otro modo, el ciclo se detiene inmediatamente.</p> <p>3) Modo Step BTN_NEXT: avanza una posici\u00f3n (si ya est\u00e1 en la \u00faltima, se mantiene en esa \u00faltima).</p> <p>BTN_PREV: retrocede una posici\u00f3n (si ya est\u00e1 en la primera, se mantiene en la primera).</p> <p>En cada cambio de posici\u00f3n:</p> <p>mover el servo a la posici\u00f3n seleccionada;</p> <p>imprimir posX: V.</p> <p>Si la lista est\u00e1 vac\u00eda: al presionar BTN_NEXT o BTN_PREV, imprimir Error no hay pos y no mover el servo.</p> <p>INFO IMPORTANTE: El movimiento de un servo requiere alimentacion 5-6v y en el pin de signal, un pwm a 50 HZ con un pulso de 1-2ms que representa 0-180 grados</p>"},{"location":"SistemasEmbebidos/Examenes/#programa_1","title":"Programa","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string&gt;\n#include &lt;cctype&gt;\n#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n#include \"hardware/gpio.h\"\n\nusing namespace std;\n\n#define SERVO_PIN 2\n#define BTN_ATRAS 14\n#define BTN_ADELANTE 13\n#define BTN_MODE 16\n#define UARTID uart0\n#define BAUDIOS 115200\n#define TX 0\n#define RX 1\n#define MAX_POS 10\n#define TOP 20000\n\nint posiciones[MAX_POS] = {0};\nint num_pos = 0;\nint modo = 1, idx = 0;\nvolatile bool cambio_modo = false;\n\n// FUNCIONES \ninline int angle_to_pulse(int a){return 450+(a*1200)/180;}\ninline void set_servo(uint s,uint c,int a){pwm_set_chan_level(s,c,angle_to_pulse(a));}\n\ninline void borrar_lista(){\n    for(int i=0;i&lt;MAX_POS;i++) \n    posiciones[i]=0;\n    num_pos=0;\n}\ninline bool lista_vacia(){\n    if(num_pos==0) return true;\n    for(int i=0;i&lt;num_pos;i++) if(posiciones[i]!=0) return false;\n    return true;\n}\ninline void imprimir_lista(){\n    printf(\"Lista actual: \");\n    for(int i=0;i&lt;MAX_POS;i++){\n        printf(\"%d\",posiciones[i]); if(i&lt;MAX_POS-1)printf(\", \"); \n    }\n    printf(\"\\n\");\n}\nvoid str_tolower(string &amp;s){for(auto &amp;c:s)c=tolower(c);}\n\n//ISR\nvoid cambio_isr(uint gpio,uint32_t events){cambio_modo=true;}\n\nint main(){\n    stdio_init_all();\n    sleep_ms(1500);\n\n    uart_init(UARTID,BAUDIOS);\n    gpio_set_function(TX,GPIO_FUNC_UART);\n    gpio_set_function(RX,GPIO_FUNC_UART);\n    uart_set_format(UARTID,8,1,UART_PARITY_NONE);\n\n    // SERVO\n    gpio_set_function(SERVO_PIN,GPIO_FUNC_PWM);\n    uint slice=pwm_gpio_to_slice_num(SERVO_PIN);\n    uint chan=pwm_gpio_to_channel(SERVO_PIN);\n    pwm_set_clkdiv(slice,150.0f); \n    pwm_set_wrap(slice,TOP);\n    pwm_set_enabled(slice,true);\n\n    gpio_init(BTN_ATRAS\n); gpio_set_dir(BTN_ATRAS\n    ,false); gpio_pull_up(BTN_ATRAS\n);\n    gpio_init(BTN_ADELANTE);  gpio_set_dir(BTN_ADELANTE,false);  gpio_pull_up(BTN_ADELANTE);\n    gpio_init(BTN_MODE); gpio_set_dir(BTN_MODE,false); gpio_pull_up(BTN_MODE);\n    gpio_set_irq_enabled_with_callback(BTN_MODE,GPIO_IRQ_EDGE_FALL,true,&amp;cambio_isr);\n\n    printf(\"\\n=== MODO 1: ENTRENAMIENTO ===\\nComandos: escribir / borrar\\n\");\n\n    string input;\n    bool prev_fwd=1,prev_back=1;\n\n    while(true){\n        //CAMBIO DE MODO\n        if(cambio_modo){\n            cambio_modo=false;\n            modo=(modo%3)+1;\n            idx=0;\n            printf(\"\\n=== CAMBIO A MODO %d ===\\n\",modo);\n\n            if(!lista_vacia()){\n                set_servo(slice,chan,posiciones[0]);\n                sleep_ms(500);\n            }\n\n            if(modo==1) printf(\"Modo entrenamiento: escribir / borrar\\n\");\n            if(modo==2) printf(\"Modo repetici\u00f3n autom\u00e1tica.\\n\");\n            if(modo==3) printf(\"Modo paso a paso con botones.\\n\");\n        }\n\n        //MODO 1 \n        if(modo==1){\n            int ch=getchar_timeout_us(0);\n            if(ch!=PICO_ERROR_TIMEOUT){\n                if(ch=='\\r'||ch=='\\n'){\n                    if(!input.empty()){\n                        string cmd=input; str_tolower(cmd);\n                        if(cmd==\"borrar\"||cmd==\"clear\"){borrar_lista();printf(\"OK.\\n\");imprimir_lista();}\n                        else if(cmd.find(\"escribir\")==0||cmd.find(\"write\")==0){\n                            printf(\"\u00bfCu\u00e1ntos valores (1\u201310)?: \");\n                            fflush(stdout);\n                            string n_str;\n                            while(true){\n                                int c=getchar_timeout_us(0);\n                                if(c!=PICO_ERROR_TIMEOUT){\n                                    if(c=='\\r'||c=='\\n')break; n_str+=(char)c;\n                                }\n                            }\n                            int n=stoi(n_str);\n                            if(n&lt;1||n&gt;MAX_POS){\n                                printf(\"Fuera de rango.\\n\");input.clear();continue;\n                            }\n                            printf(\"Ingrese %d valores (0\u2013180) separados por espacios:\\n\",n);\n                            fflush(stdout);\n                            string val_str;\n                            while(true){\n                                int c=getchar_timeout_us(0);\n                                if(c!=PICO_ERROR_TIMEOUT){\n                                    if(c=='\\r'||c=='\\n')break; val_str+=(char)c;\n                                }\n                            }\n                            borrar_lista();\n                            int i=0; size_t pos=0;\n                            while(i&lt;n &amp;&amp; pos&lt;val_str.size()){\n                                size_t e=val_str.find(' ',pos);\n                                int v=stoi(val_str.substr(pos,e-pos));\n                                if(v&lt;0||v&gt;180){printf(\"Valor fuera de rango.\\n\");break;}\n                                posiciones[i++]=v;\n                                if(e==string::npos)break; pos=e+1;\n                            }\n                            num_pos=i;\n                            printf(\"OK.\\n\");imprimir_lista();\n                        }\n                        else printf(\"Comando no reconocido.\\n\");\n                        input.clear();\n                    }\n                } else input+=(char)ch;\n            }\n        }\n\n        //MODO 2\n        else if(modo==2){\n            if(lista_vacia()){\n                printf(\"SIN MOVIMIENTO, LISTA EN 0\\n\");sleep_ms(1000);\n            }\n            else{\n                for(int i=0;i&lt;num_pos;i++){\n                    if(cambio_modo)break;\n                    set_servo(slice,chan,posiciones[i]);\n                    sleep_ms(1000);\n                }\n            }\n        }\n\n        //MODO 3\n        else if(modo==3){\n            if(lista_vacia()){\n                printf(\"SIN MOVIMIENTO, LISTA EN 0\\n\");sleep_ms(1000);\n            }\n            else{\n                set_servo(slice,chan,posiciones[idx]);\n                bool fwd=gpio_get(BTN_ADELANTE);\n                bool back=gpio_get(BTN_ATRAS\n            );\n\n                if(!fwd &amp;&amp; prev_fwd){ \n                    if(idx&lt;num_pos-1 &amp;&amp; posiciones[idx+1]!=0){\n                        idx++;set_servo(slice,chan,posiciones[idx]);\n                        printf(\"Avance a paso %d (%d\u00b0)\\n\",idx+1,posiciones[idx]);\n                    } else printf(\"Fin de secuencia.\\n\");\n                }\n                if(!back &amp;&amp; prev_back){\n                    if(idx&gt;0){\n                        idx--;set_servo(slice,chan,posiciones[idx]);\n                        printf(\"Retroceso a paso %d (%d\u00b0)\\n\",idx+1,posiciones[idx]);\n                    } else printf(\"Inicio de secuencia.\\n\");\n                }\n                prev_fwd=fwd; \n                prev_back=back;\n                sleep_ms(100);\n            }\n        }\n\n        sleep_ms(10);\n    }\n}\n</code></pre>"},{"location":"SistemasEmbebidos/Examenes/#video","title":"Video","text":""},{"location":"SistemasEmbebidos/PinOuts/","title":"PINOUTS","text":"<p>En esta secci\u00f3n de mi p\u00e1gina colocar\u00e9 los pinouts que encuentre de las placas que ocupamos, esto con la finalidad de tener a la mano toda la informaci\u00f3n necesaria para hacer diversos proyectos.</p>"},{"location":"SistemasEmbebidos/PinOuts/#microcontroladores","title":"Microcontroladores","text":""},{"location":"SistemasEmbebidos/PinOuts/#esp32","title":"ESP32","text":""},{"location":"SistemasEmbebidos/PinOuts/#attiny-85","title":"Attiny 85","text":""},{"location":"SistemasEmbebidos/PinOuts/#raspberry-pi-pico-2","title":"Raspberry Pi Pico 2","text":""},{"location":"SistemasEmbebidos/PinOuts/#puentes-h","title":"Puentes H","text":""},{"location":"SistemasEmbebidos/PinOuts/#tb6612fng","title":"TB6612FNG","text":""},{"location":"SistemasEmbebidos/PinOuts/#l293d","title":"L293D","text":"<p>Nota: Este puente h es peque\u00f1o, adaptable a la protoboard pero su desventaja es que como funciona con 5v se volvi\u00f3 obsoleto ante los microcontroladores modernos que usan 3.3v para funcionar, as\u00ed que lo m\u00e1s recomendable es utilizar Arduino UNO.</p> <p></p>"},{"location":"SistemasEmbebidos/Tareas/","title":"TAREAS DEL CURSO","text":""},{"location":"SistemasEmbebidos/Tareas/#tarea-1-cuadro-comparativo","title":"Tarea 1: Cuadro comparativo","text":"<p>En esta tarea se realizar\u00e1 un cuadro comparativo entre 4 microcontroladores reconocidos, tomando en cuenta varias caracter\u00edsticas, tambi\u00e9n los voy a rankear por puesto y dir\u00e9 cu\u00e1l es mejor para m\u00ed y el por qu\u00e9.</p> Par\u00e1metro Arduino Uno (ATmega328P) ESP32 PIC16F877A Raspberry Pi Pico 2 (RP2350) Perif\u00e9ricos 14 GPIO, 6 entradas ADC, PWM, UART, SPI M\u00e1s de 30 GPIO, WiFi, Bluetooth, ADC, DAC, PWM, UART, SPI 33 GPIO, 8 canales ADC, UART, SPI, PWM 30 GPIO, 3 UART, 2 SPI, PWM, ADC, PIO programables, USB, soporte para memoria externa Memoria 32 KB Flash, 2 KB SRAM Hasta 4 MB Flash, 520 KB SRAM 14 KB Flash, 368 Bytes RAM 520 KB SRAM, soporte para hasta 128 MB Flash externa Ecosistema El m\u00e1s usado en las escuelas por su simpleza y librer\u00edas f\u00e1ciles Amplio en IoT, soporte para programar en Arduino IDE, ESP-IDF Utilizado mucho en industria y un poco en educaci\u00f3n, ecosistema m\u00e1s limitado pero optimizado Ecosistema en constante crecimiento, soporte C/C++, Python y SDK oficial de Raspberry Pi Costos (aprox.) 160-240 MX 100-200 MX (seg\u00fan versi\u00f3n) 120-200 MX 120-160 MX Arquitectura AVR de 8 bits Tensilica Xtensa LX6 o RISC-V de 32 bits PIC de 8 bits ARM Cortex-M33, 32 bits dual-core Velocidad de trabajo 16 MHz 160 \u2013 240 MHz 20 MHz Hasta 150 MHz en dual-core"},{"location":"SistemasEmbebidos/Tareas/#ranking","title":"RANKING","text":"<p>Aqu\u00ed est\u00e1 el ranking de los microcontroladores, lo hice en mi opini\u00f3n tomando en cuenta todas las caracter\u00edsticas de la tabla. </p> Microcontrolador Posici\u00f3n \u00bfPor qu\u00e9 ese ranking en mi opini\u00f3n? \u00bfPor qu\u00e9 los eleg\u00ed? ESP32 1 Es simple, potente, barato, se conecta Wi-Fi y Bluetooth y se puede utilizar en proyectos avanzados Lo eleg\u00ed porque es muy reconocible, lo hemos utilizado en producci\u00f3n electr\u00f3nica (XIAO ESP32) y porque yo s\u00e9 que en un futuro lo voy a ocupar m\u00e1s seriamente Raspberry Pi Pico 2 2 Es muy potente y r\u00e1pido, tiene bastante memoria y tiene un potencial muy bueno porque su ecosistema sigue en crecimiento, por lo tanto, es mucho mejor que Arduino para proyectos serios Lo eleg\u00ed porque siento que tiene much\u00edsimo m\u00e1s potencial que Arduino que me encanta, quiero aprender sobre ese microcontrolador y porque utilizar\u00e9 la rama de Raspberry much\u00edsimo en todo lo que sigue de la carrera Arduino UNO 3 Es h\u00edper simple, el mejor para la ense\u00f1anza en la escuela para empezar con los microcontroladores, pero es muy lento en sus ciclos y en su forma de ejecutar el programa final si son muchas instrucciones Lo eleg\u00ed porque gracias a este microcontrolador me apasion\u00e9 por la mecatr\u00f3nica y los robots potenciados por Arduino, es muy sencillo y divertido de aprender y te da libertad creativa con muchos componentes que utilizar, lo coloqu\u00e9 en este rango porque yo s\u00e9 que tiene un l\u00edmite y es lento y poco eficaz comparado con otros microcontroladores que voy a utilizar a lo largo de mi carrera PIC16F877A 4 Es muy utilizado en la industria por su optimizaci\u00f3n y simpleza, pero en los tiempos actuales se est\u00e1 quedando un poco obsoleto porque no tiene tanta memoria y es un poco m\u00e1s lento Lo eleg\u00ed porque siento que si me voy a un \u00e1rea laboral muy industrial tarde o temprano voy a terminar trabajando con este microcontrolador, o por lo menos, con unos parecidos"},{"location":"SistemasEmbebidos/Tareas/#tarea-2-outputs-basicos","title":"Tarea 2: Outputs b\u00e1sicos","text":"<p>En esta tarea tuvimos que realizar 3 programas distintos, en los cuales trabajamos en la primera un contador binario de 4 bits, en la segunda una secuencia de barrido y la \u00faltima una secuencia en formato Gray, igualmente de 4 bits.</p>"},{"location":"SistemasEmbebidos/Tareas/#primer_programa","title":"Primer_programa","text":"<p>Lo que hace este programa es representar en una cadena de 4 LEDS un contador en binario representando los 1 y 0 en encendido y apagado.</p> <pre><code>#include \"pico/stdlib.h\"\n\n#define LEDS_MASK ((1&lt;&lt;0) | (1&lt;&lt;1) | (1&lt;&lt;3) | (1&lt;&lt;4))  \n\nint main() {\n    stdio_init_all();\n\n\n    gpio_init(0); gpio_set_dir(0, GPIO_OUT);\n    gpio_init(1); gpio_set_dir(1, GPIO_OUT);\n    gpio_init(3); gpio_set_dir(3, GPIO_OUT);\n    gpio_init(4); gpio_set_dir(4, GPIO_OUT);\n\n    int estado = 0;\n\n    while (1) {\n\n        for (estado = 0; estado &lt; 16; estado++) {\n\n            gpio_put(0, estado &amp; (1&lt;&lt;0));\n            gpio_put(1, estado &amp; (1&lt;&lt;1));\n            gpio_put(3, estado &amp; (1&lt;&lt;2));  \n            gpio_put(4, estado &amp; (1&lt;&lt;3));\n            sleep_ms(500);\n        }\n    }\n}\n</code></pre>"},{"location":"SistemasEmbebidos/Tareas/#esquematicos-y-videos","title":"Esquem\u00e1ticos y videos","text":""},{"location":"SistemasEmbebidos/Tareas/#segundo_programa","title":"Segundo_Programa","text":"<p>Lo que hace el segundo programa es representar un barrido de ida y vuelta de una l\u00ednea de 4 LEDS, con el patr\u00f3n 0-1-2-3-2-1-0, encendiendo el pin seleccionado en el momento y apagando el resto.</p> <pre><code>#include \"pico/stdlib.h\"\n\n#define LED0 0   \n#define LED1 1   \n#define LED2 3   \n#define LED3 4   \n\n#define LED_MASK ((1u &lt;&lt; LED0) | (1u &lt;&lt; LED1) | (1u &lt;&lt; LED2) | (1u &lt;&lt; LED3))\n\nconst uint LEDS[4] = {LED0, LED1, LED2, LED3}; // lo hice as\u00ed para no repetir 4 lineas de c\u00f3digo\n\nint main() {\n    for (int i = 0; i &lt; 4; i++) {\n        gpio_init(LEDS[i]);\n        gpio_set_dir(LEDS[i], true);\n    }\n\n    int posicion = 0; \n    int dir = 1;   \n\n    while (true) {\n        gpio_clr_mask(LED_MASK); // Importante limpiar todos los LEDs\n\n        uint32_t bit = (1u &lt;&lt; LEDS[posicion]);  \n        gpio_set_mask(bit);      \n\n        sleep_ms(300);\n\n        posicion += dir;\n\n        if (posicion == 4 || posicion == -1) {\n            gpio_clr_mask(LED_MASK);\n            dir = -dir;  \n        }\n    }\n}\n</code></pre>"},{"location":"SistemasEmbebidos/Tareas/#esquematicos-y-videos_1","title":"Esquem\u00e1ticos y videos","text":""},{"location":"SistemasEmbebidos/Tareas/#tercer_programa","title":"Tercer_Programa","text":"<p>Lo que hace el tercer programa se parece un poco al contador binario del primer programa, pero lo que hace es representar con LEDs una secuencia llamada N\u00fameros Gray, convirtiendo una secuencia de binario a Gray y los representa en su l\u00ednea de 4 LEDs con el 1 como encendido y 0 como apagado.</p> <pre><code>#include \"pico/stdlib.h\"\n\nint main() {\n\n    const uint LEDS[] = {0, 1, 3, 4};\n    const int Cantidad = 4;\n\n\n    for (int i = 0; i &lt; Cantidad; i++) {//Para evitar c\u00f3digo si son muchos pines\n        gpio_init(LEDS[i]);\n        gpio_set_dir(LEDS[i], GPIO_OUT);\n    }\n\n    while (true) {\n\n        for (int n = 0; n &lt; 16; n++) {\n            int gray = n ^ (n &gt;&gt; 1); // F\u00f3rmula para convertir a Gray\n\n\n            for (int i = 0; i &lt; Cantidad; i++) {\n                int bit = (gray &gt;&gt; i) &amp; 1;\n                gpio_put(LEDS[i], bit);\n            }\n\n            sleep_ms(500);\n        }\n    }\n}\n</code></pre>"},{"location":"SistemasEmbebidos/Tareas/#esquematicos-y-videos_2","title":"Esquem\u00e1ticos y videos","text":""},{"location":"SistemasEmbebidos/Tareas/#tarea-3-inputs","title":"Tarea 3 Inputs","text":"<p>En esta tarea nos encargaron hacer 2 programas para Raspberry Pi Pico 2, utilizando inputs de 2 botones distintos para hacer encender una cadena de LEDs de cierta manera que detallar\u00e9 en cada programa.</p>"},{"location":"SistemasEmbebidos/Tareas/#primer-programa","title":"Primer programa","text":"<p>Este primer programa consisti\u00f3 en hacer 3 compuertas l\u00f3gicas: AND, OR y XOR, programando entradas con 2 botones en C y ejecutando en el microcontrolador para encender 3 LEDs, cada LED con la salida de las distintas compuertas.</p> <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n\n#define LED   0\n#define LED2    1\n#define LED3   3\n\n#define Boton1   5\n#define Boton2   6\n\nint main() {\n\n    gpio_init(LED);\n    gpio_set_dir(LED, true);\n\n    gpio_init(LED2);\n    gpio_set_dir(LED2, true);\n\n    gpio_init(LED3);\n    gpio_set_dir(LED3, true);\n\n    gpio_init(Boton1);\n    gpio_set_dir(Boton1, false);\n    gpio_pull_up(Boton1);\n\n    gpio_init(Boton2);\n    gpio_set_dir(Boton2, false);\n    gpio_pull_up(Boton2);\n\n    while (true) {\n        // Se invierte para que sea Pull-up\n        uint32_t b1 = !gpio_get(Boton1);\n        uint32_t b2 = !gpio_get(Boton2);\n\n        uint32_t AND = b1 &amp; b2;   \n        uint32_t OR  = b1 | b2; \n        uint32_t XOR = b1 ^ b2; \n\n        gpio_clr_mask((1u &lt;&lt; LED) | (1u &lt;&lt; LED2) | (1u &lt;&lt; LED3));\n        gpio_set_mask((AND &lt;&lt; LED) |\n                      (OR  &lt;&lt; LED2)  |\n                      (XOR &lt;&lt; LED3));\n    }\n}\n</code></pre>"},{"location":"SistemasEmbebidos/Tareas/#esquematicos-y-videos_3","title":"Esquem\u00e1ticos y videos","text":""},{"location":"SistemasEmbebidos/Tareas/#segundo-programa","title":"Segundo programa","text":"<p>Este segundo programa consisti\u00f3 en hacer una secuencia en cadenita, al igual que el programa de la cadena en la segunda tarea , programando entradas con 2 botones en C y ejecutando en el microcontrolador para encender la fila de 4 LEDs, cada LED con la salida de la numeraci\u00f3n correspondiente.</p> <pre><code>#include \"pico/stdlib.h\"\n\n#define LED0 0  \n#define LED1 1  \n#define LED2 3  \n#define LED3 4  \n\n#define Boton1 5\n#define Boton2 6\n\n#define LED_MASK ((1u &lt;&lt; LED0) | (1u &lt;&lt; LED1) | (1u &lt;&lt; LED2) | (1u &lt;&lt; LED3))\n\nconst uint LEDS[4] = {LED0, LED1, LED2, LED3};\n\nint main() {\n    stdio_init_all();\n\n    for (int i = 0; i &lt; 4; i++) {\n        gpio_init(LEDS[i]);\n        gpio_set_dir(LEDS[i], true);\n    }\n\n    gpio_init(Boton1);\n    gpio_set_dir(Boton1, false);  \n    gpio_pull_up(Boton1);\n\n    gpio_init(Boton2);\n    gpio_set_dir(Boton2, false);  \n    gpio_pull_up(Boton2);\n\n    int posicion = 0;\n    uint32_t Estadob1 = true;\n    uint32_t Estadob2 = true;\n\n    while (true) {\n        // Poner posici\u00f3n actual\n        gpio_clr_mask(LED_MASK);\n        gpio_set_mask(1u &lt;&lt; LEDS[posicion]);\n\n\n        uint32_t Avance = gpio_get(Boton1);\n        uint32_t Retroceso = gpio_get(Boton2);\n\n        if (!Avance &amp;&amp; Estadob1) {\n            posicion++;\n            if (posicion &gt; 3) posicion = 0;\n        }\n\n        if (!Retroceso &amp;&amp; Estadob2) {\n            posicion--;\n            if (posicion &lt; 0) posicion = 3;\n        }\n\n        Estadob1 = Avance;\n        Estadob2 = Retroceso;\n\n        sleep_ms(20);\n    }\n}\n</code></pre>"},{"location":"SistemasEmbebidos/Tareas/#esquematicos-y-videos_4","title":"Esquem\u00e1ticos y videos","text":""},{"location":"SistemasEmbebidos/Tareas/#tarea-4-pong-con-interrupciones","title":"Tarea 4 PONG con interrupciones","text":"<p>En esta tarea nos encargaron programar un mini-Pong con 5 LEDs en l\u00ednea y 2 botones usando interrupciones (ISR) para registrar el \u201cgolpe\u201d del jugador exactamente cuando la \u201cpelota\u201d (un LED encendido) llega al extremo de su lado. </p>"},{"location":"SistemasEmbebidos/Tareas/#reglas","title":"REGLAS","text":"<p>Pelota: es un \u00fanico LED encendido que se mueve autom\u00e1ticamente de un extremo al otro (L1\u2192L5\u2192L1\u2026) a un ritmo fijo.</p> <p>Golpe con ISR: cada bot\u00f3n genera una interrupci\u00f3n.</p> <p>El BTN_L solo cuenta si, en el instante de la ISR, la pelota est\u00e1 en L1.</p> <p>El BTN_R solo cuenta si, en el instante de la ISR, la pelota est\u00e1 en L5.</p> <p>Si coincide, la pelota rebota: invierte su direcci\u00f3n.</p> <p>Fallo y punto: si la pelota alcanza L1 y no hubo golpe v\u00e1lido del lado izquierdo en ese momento, anota el jugador derecho. An\u00e1logamente, si alcanza L5 sin golpe v\u00e1lido, anota el jugador izquierdo.</p> <p>Indicador de punto: al anotar, se parpadea el LED de punto 3 veces del jugador que meti\u00f3 el punto .</p> <p>Reinicio tras punto: despu\u00e9s del parpadeo, la pelota se reinicia en el centro (L3) y comienza a moverse hacia el jugador que meti\u00f3 el punto.</p> <p>Inicio del juego: al encender, la pelota inicia en L3 y no se mueve hasta que se presione un boton y debera moverse a la direccion opuesta del boton presionado.</p>"},{"location":"SistemasEmbebidos/Tareas/#programa","title":"Programa","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n\n#define Led 0\n#define Led2 1\n#define Led3 2   // LED central\n#define Led4 3\n#define Led5 4\n#define Led6p 6  \n#define Led7p 8   \n\n#define BotonIzq 14     \n#define BotonDer 15     \n\n#define LED_MASK ((1u &lt;&lt; Led) | (1u &lt;&lt; Led2) | (1u &lt;&lt; Led3) | (1u &lt;&lt; Led4) | (1u &lt;&lt; Led5))\n\nconst uint LEDS[5] = {Led, Led2, Led3, Led4, Led5};\nint posicion = 2;  \nint dir = 1;        \nbool fallo = false;\nint fallo_jugador = -1; \n\n// ISR para botones\nvoid boton_isr(uint gpio, uint32_t events) {\n    if (posicion == 0 &amp;&amp; gpio == BotonIzq) {\n        dir = 1;\n    } else if (posicion == 4 &amp;&amp; gpio == BotonDer) {\n        dir = -1;\n    } else {\n        fallo = true;\n        if (gpio == BotonIzq) {\n            fallo_jugador = 0; \n        } else if (gpio == BotonDer) {\n            fallo_jugador = 1; \n        }\n    }\n}\n\n\nvoid Inicioled() {\n    for (int i = 0; i &lt; 3; i++) {\n        gpio_put(Led3, 1);\n        sleep_ms(500);\n        gpio_put(Led3, 0); \n        sleep_ms(500);\n    }\n}\n\nint main() {\n    stdio_init_all();\n\n    for (int i = 0; i &lt; 5; i++) {\n        gpio_init(LEDS[i]);\n        gpio_set_dir(LEDS[i], true);\n    }\n\n    gpio_init(Led6p);\n    gpio_set_dir(Led6p, true);\n    gpio_init(Led7p);\n    gpio_set_dir(Led7p, true);\n\n    gpio_init(BotonIzq);\n    gpio_set_dir(BotonIzq, false);\n    gpio_pull_up(BotonIzq);\n    gpio_set_irq_enabled_with_callback(BotonIzq, GPIO_IRQ_EDGE_FALL, true, &amp;boton_isr);\n\n    gpio_init(BotonDer);\n    gpio_set_dir(BotonDer, false);\n    gpio_pull_up(BotonDer);\n    gpio_set_irq_enabled_with_callback(BotonDer, GPIO_IRQ_EDGE_FALL, true, &amp;boton_isr);\n\n\n    Inicioled();\n\n    while (true) {\n        gpio_clr_mask(LED_MASK); \n        gpio_set_mask(1u &lt;&lt; LEDS[posicion]); \n\n        sleep_ms(300);\n\n        if (fallo) {\n            gpio_clr_mask(LED_MASK);\n\n            if (fallo_jugador == 0) {\n                gpio_put(Led6p, 1);\n                sleep_ms(5000);\n                gpio_put(Led6p, 0);\n            } else if (fallo_jugador == 1) {\n                gpio_put(Led7p, 1);\n                sleep_ms(5000);\n                gpio_put(Led7p, 0);\n            }\n\n            // reiniciar juego\n            fallo = false;\n            fallo_jugador = -1;\n            posicion = 2;\n            dir = 1;\n\n\n            Inicioled();\n            continue;\n        }\n\n        posicion += dir;\n\n        // Rebote fallido\n        if (posicion &lt; 0) {\n            fallo = true;\n            fallo_jugador = 0;\n        } else if (posicion &gt; 4) {\n            fallo = true;\n            fallo_jugador = 1;\n        }\n    }\n}\n</code></pre>"},{"location":"SistemasEmbebidos/Tareas/#esquematicos-y-videos_5","title":"Esquem\u00e1ticos y videos","text":""},{"location":"SistemasEmbebidos/Tareas/#tarea-5-ejercicios-de-medicion","title":"Tarea 5 Ejercicios de medici\u00f3n","text":""},{"location":"SistemasEmbebidos/Tareas/#medicion-en-osciloscopio-del-periodo-y-jitter-usando-alarm0-modo-s","title":"Medici\u00f3n en osciloscopio del periodo y jitter usando ALARM0 (modo \u00b5s)","text":"<p>Genera una onda cuadrada por toggle de un pin de salida en la ISR de ALARM0, con rearme acumulativo y periodo nominal definido por ti (p. ej., 100 \u00b5s\u20135 ms). Mide con osciloscopio:</p> <p>Periodo promedio y tolerancia.</p> <p>Jitter pico-a-pico y, si tu equipo lo permite, RMS. Describe la configuraci\u00f3n del osciloscopio (acoplamiento, escala de tiempo/voltaje, modo de medici\u00f3n). No cambiar la resoluci\u00f3n del timer (mantener modo \u00b5s).</p>"},{"location":"SistemasEmbebidos/Tareas/#evidencia","title":"Evidencia","text":""},{"location":"SistemasEmbebidos/Tareas/#programa_1","title":"Programa","text":"<pre><code>// Blink con timer (SDK alto nivel): cambia BLINK_MS para ajustar\n#include \"pico/stdlib.h\"\n#include \"pico/time.h\"\n\n#define LED_PIN PICO_DEFAULT_LED_PIN\nstatic const int BLINK_MS = 1000;  // &lt;-- ajusta tu periodo aqu\u00ed\n\nbool blink_cb(repeating_timer_t *t) {\n    static bool on = false;\n    gpio_put(LED_PIN, on = !on);\n    return true; // seguir repitiendo la alarma\n}\n\nint main() {\n    stdio_init_all();\n\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, true);\n\n    repeating_timer_t timer;\n    // Programa una interrupci\u00f3n peri\u00f3dica cada BLINK_MS:\n    add_repeating_timer_ms(BLINK_MS, blink_cb, NULL, &amp;timer);\n\n    while (true) {\n        // El trabajo \"pesado\" deber\u00eda ir aqu\u00ed (no en la ISR).\n        tight_loop_contents();\n    }\n}\n</code></pre>"},{"location":"SistemasEmbebidos/Tareas/#diagrama","title":"Diagrama","text":"<p>An\u00e1lisis</p> <p>Al generar una se\u00f1al por medio de temporizadores, al momento de medirla en el osciloscopio se pudo observar el peque\u00f1o delay que se genera al usar este modo.</p> <p>Se configur\u00f3 el osciloscopio con un voltaje de 1V, para as\u00ed poder observar correctamente las se\u00f1ales. El tiempo de parpadeo era de 1 segundo y en el osciloscopio se obtuvo un ciclo de 1.001 s. Es decir que tiene un delay de 1 milisegundo</p>"},{"location":"SistemasEmbebidos/Tareas/#comparar-jitterprecision-con-osciloscopio-modo-s-vs-modo-ciclos","title":"Comparar jitter/precisi\u00f3n con osciloscopio: modo \u00b5s vs modo ciclos","text":"<p>Genera una se\u00f1al por toggle en la ISR de ALARM0, primero en modo \u00b5s y luego en modo ciclos de clk_sys (mismo periodo nominal). En ambos casos:</p> <p>Usa rearme acumulativo.</p> <p>Mant\u00e9n el resto del c\u00f3digo id\u00e9ntico. Con el osciloscopio, mide y registra para cada modo:</p> <p>Periodo promedio y desviaci\u00f3n respecto al nominal.</p> <p>Jitter pico-a-pico y/o RMS. Compara resultados y discute el compromiso entre resoluci\u00f3n de tick y horizonte de programaci\u00f3n.</p>"},{"location":"SistemasEmbebidos/Tareas/#evidencia_1","title":"Evidencia","text":""},{"location":"SistemasEmbebidos/Tareas/#programa_2","title":"Programa","text":"<pre><code>// Blink con timer de sistema (bajo nivel): programando ALARM0 e IRQ\n#include \"pico/stdlib.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n\n#define LED_PIN       PICO_DEFAULT_LED_PIN\n#define ALARM_NUM     0  // usaremos la alarma 0\n\n// Calcula el n\u00famero de IRQ para esa alarma \n#define ALARM_IRQ     timer_hardware_alarm_get_irq_num(timer_hw, ALARM_NUM)\n\nstatic volatile uint32_t next_deadline;   // pr\u00f3ximo instante (en us) en 32 bits bajos\n// Por defecto el timer cuenta \u00b5s (no cambiamos la fuente).\nstatic volatile uint32_t intervalo_us = 1000000u;    // periodo en microsegundos\n\nvoid on_alarm_irq(void) {\n    // 1) Limpiar el flag de la alarma\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM_NUM);\n\n    // 2) Hacer el trabajo toggle LED\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED_PIN;\n\n    // 3) Rearmar la siguiente alarma con \"deadline acumulativo\"\n    next_deadline += intervalo_us;\n    timer_hw-&gt;alarm[ALARM_NUM] = next_deadline;\n}\n\nint main() {\n    stdio_init_all();\n\n    // Configurar el LED\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, true);\n\n    // \"now\" = 32 bits bajos del contador (tiempo en \u00b5s)\n    uint32_t now_us = timer_hw-&gt;timerawl;          // lectura 32b (low) del contador\n    next_deadline = now_us + intervalo_us;         // primer deadline\n\n    // Programar la alarma\n    timer_hw-&gt;alarm[ALARM_NUM] = next_deadline;\n\n    // Crea un handler exclusivo para ligar el callback a la IRQ de la alarma\n    irq_set_exclusive_handler(ALARM_IRQ, on_alarm_irq);\n    // Habilitar dentro del perif\u00e9rico TIMER la fuente de interrupci\u00f3n para la alarma ALARM_NUM inte = interrupt enable\n    hw_set_bits(&amp;timer_hw-&gt;inte, 1u &lt;&lt; ALARM_NUM);\n    //Habilitar la IRQ en el NVIC (controlador de interrupciones del n\u00facleo)\n    irq_set_enabled(ALARM_IRQ, true);\n\n    while (true) {\n        // Mantener el bucle principal libre; lo pesado va aqu\u00ed, no en la ISR\n        tight_loop_contents();\n    }\n}\n</code></pre>"},{"location":"SistemasEmbebidos/Tareas/#diagrama_1","title":"Diagrama","text":""},{"location":"SistemasEmbebidos/Tareas/#comparacion","title":"Comparaci\u00f3n","text":"<p>Al comparar los dos modos, se encontr\u00f3 una diferencia entre el modo \u00b5s vs ciclos. El modo ciclos es m\u00e1s preciso y no genera ning\u00fan delay perceptible en el osciloscopio a diferncia del modo \u00b5s que tiene una diferencia de 1 ms.</p> <p>Con esta informaci\u00f3n se puede concluir que para tener un timer preciso el uso de los ciclos es el ideal y el mejor para implementar en futuros proyectos, ya que genera un timer \u00f3ptimo y sin delays.</p>"},{"location":"SistemasEmbebidos/Tareas/#tarea-6-ejercicios-de-programacion","title":"Tarea 6 Ejercicios de programaci\u00f3n","text":"<p>Esta tarea consisti\u00f3 en aprender a hacer programas utilizando timers y alarmas para hacer programas m\u00e1s optimizados.</p>"},{"location":"SistemasEmbebidos/Tareas/#primera-actividad","title":"Primera actividad","text":"<p>Esta actividad consisti\u00f3 en que, utilizando alarmas, encender y apagar simult\u00e1neamente 4 LEDs a velocidades distintas.</p>"},{"location":"SistemasEmbebidos/Tareas/#programa_3","title":"Programa","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n#include \"hardware/gpio.h\"\n\n#define LED0_PIN     0\n#define LED1_PIN     1\n#define LED2_PIN     3\n#define LED3_PIN     4\n\n#define ALARM0_NUM   0\n#define ALARM1_NUM   1\n#define ALARM2_NUM   2\n#define ALARM3_NUM   3\n\nstatic volatile uint32_t next0_us, next1_us, next2_us, next3_us;\nstatic const uint32_t INTERVALO0_US = 200000u;\nstatic const uint32_t INTERVALO1_US = 400000u;\nstatic const uint32_t INTERVALO2_US = 600000u;\nstatic const uint32_t INTERVALO3_US = 800000u;\n\n// ISR \u00daNICA para el TIMER\nstatic void on_timer_irq(void) {\n    uint32_t status = timer_hw-&gt;intr;  \n    timer_hw-&gt;intr = status;\n\n    if (status &amp; (1u &lt;&lt; ALARM0_NUM)) {\n        sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED0_PIN;\n        next0_us += INTERVALO0_US;\n        timer_hw-&gt;alarm[ALARM0_NUM] = next0_us;\n    }\n    if (status &amp; (1u &lt;&lt; ALARM1_NUM)) {\n        sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED1_PIN;\n        next1_us += INTERVALO1_US;\n        timer_hw-&gt;alarm[ALARM1_NUM] = next1_us;\n    }\n    if (status &amp; (1u &lt;&lt; ALARM2_NUM)) {\n        sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED2_PIN;\n        next2_us += INTERVALO2_US;\n        timer_hw-&gt;alarm[ALARM2_NUM] = next2_us;\n    }\n    if (status &amp; (1u &lt;&lt; ALARM3_NUM)) {\n        sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED3_PIN;\n        next3_us += INTERVALO3_US;\n        timer_hw-&gt;alarm[ALARM3_NUM] = next3_us;\n    }\n}\n\nint main() {\n    gpio_init(LED0_PIN); gpio_set_dir(LED0_PIN, GPIO_OUT); gpio_put(LED0_PIN, 0);\n    gpio_init(LED1_PIN); gpio_set_dir(LED1_PIN, GPIO_OUT); gpio_put(LED1_PIN, 0);\n    gpio_init(LED2_PIN); gpio_set_dir(LED2_PIN, GPIO_OUT); gpio_put(LED2_PIN, 0);\n    gpio_init(LED3_PIN); gpio_set_dir(LED3_PIN, GPIO_OUT); gpio_put(LED3_PIN, 0);\n\n    timer_hw-&gt;source = 0u;\n\n    uint32_t now_us = timer_hw-&gt;timerawl;\n\n    next0_us = now_us + INTERVALO0_US;\n    next1_us = now_us + INTERVALO1_US;\n    next2_us = now_us + INTERVALO2_US;\n    next3_us = now_us + INTERVALO3_US;\n\n    timer_hw-&gt;alarm[ALARM0_NUM] = next0_us;\n    timer_hw-&gt;alarm[ALARM1_NUM] = next1_us;\n    timer_hw-&gt;alarm[ALARM2_NUM] = next2_us;\n    timer_hw-&gt;alarm[ALARM3_NUM] = next3_us;\n\n    hw_clear_bits(&amp;timer_hw-&gt;intr,\n                  (1u &lt;&lt; ALARM0_NUM) |\n                  (1u &lt;&lt; ALARM1_NUM) |\n                  (1u &lt;&lt; ALARM2_NUM) |\n                  (1u &lt;&lt; ALARM3_NUM));\n\n    int irq_num = timer_hardware_alarm_get_irq_num(timer_hw, 0);\n    irq_set_exclusive_handler(irq_num, on_timer_irq);\n\n    hw_set_bits(&amp;timer_hw-&gt;inte,\n                (1u &lt;&lt; ALARM0_NUM) |\n                (1u &lt;&lt; ALARM1_NUM) |\n                (1u &lt;&lt; ALARM2_NUM) |\n                (1u &lt;&lt; ALARM3_NUM));\n\n    irq_set_enabled(irq_num, true);\n\n    while (true) {\n        tight_loop_contents();\n    }\n}\n</code></pre>"},{"location":"SistemasEmbebidos/Tareas/#diagrama-y-video","title":"Diagrama y video","text":""},{"location":"SistemasEmbebidos/Tareas/#segunda-actividad","title":"Segunda actividad","text":"<p>Esta actividad consisti\u00f3 en modificar el programa del Pong, coloc\u00e1ndole 2 botones extras que al presionarlos, aumenten o disminuyan la velocidad del barrido de los LEDs.</p>"},{"location":"SistemasEmbebidos/Tareas/#programa_4","title":"Programa","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n\n#define Leds 5\n#define Delayminimo 100\n#define Delaymaximo 1000\n#define Delay 100\n\nconst uint Boton1 = 14;     \nconst uint Boton2 = 15;  \nconst uint Botonmasvel = 13;  \nconst uint Botonmenosvel = 12;\nconst uint LEDS[Leds] = {0, 1, 2, 3, 4};\nconst uint LedP1 = 6;    // LED indicador derecha\nconst uint LedP2 = 8;    // LED indicador izquierda\n\nvolatile bool Reb1 = false;\nvolatile bool Reb2 = false;\nvolatile bool Subiovel = false;\nvolatile bool Bajovel = false;\n\nvoid button_isr(uint gpio, uint32_t events) {\n    if (gpio == Boton1) Reb1 = true;\n    else if (gpio == Boton2) Reb2 = true;\n    else if (gpio == Botonmasvel) Subiovel = true;\n    else if (gpio == Botonmenosvel) Bajovel = true;\n}\n\nvoid score_point(uint led) {\n    for (int i = 0; i &lt; 3; i++) {\n        gpio_put(led, 1);\n        sleep_ms(150);\n        gpio_put(led, 0);\n        sleep_ms(150);\n    }\n}\n\nint main() {\n    // Anotaci\u00f3n de puntos\n    gpio_init(LedP1); gpio_set_dir(LedP1, true);\n    gpio_init(LedP2); gpio_set_dir(LedP2, true);\n\n\n    gpio_init(Boton1); gpio_set_dir(Boton1, false); gpio_pull_up(Boton1);\n    gpio_set_irq_enabled_with_callback(Boton1, GPIO_IRQ_EDGE_FALL, true, &amp;button_isr);\n\n    gpio_init(Boton2); gpio_set_dir(Boton2, false); gpio_pull_up(Boton2);\n    gpio_set_irq_enabled(Boton2, GPIO_IRQ_EDGE_FALL, true);\n\n    gpio_init(Botonmasvel); gpio_set_dir(Botonmasvel, false); gpio_pull_up(Botonmasvel);\n    gpio_set_irq_enabled(Botonmasvel, GPIO_IRQ_EDGE_FALL, true);\n\n    gpio_init(Botonmenosvel); gpio_set_dir(Botonmenosvel, false); gpio_pull_up(Botonmenosvel);\n    gpio_set_irq_enabled(Botonmenosvel, GPIO_IRQ_EDGE_FALL, true);\n\n    // LEDs del juego\n    for (int i = 0; i &lt; Leds; i++) {\n        gpio_init(LEDS[i]);\n        gpio_set_dir(LEDS[i], true);\n    }\n\n    int current_led = Leds / 2;\n    int direction = 0;\n    bool game_started = false;\n    int delay_ms = 400; // velocidad inicial\n\n    gpio_put(LEDS[current_led], 1);\n\n    while (true) {\n        // Ajustar velocidad\n        if (Subiovel) {\n            if (delay_ms &gt; Delayminimo) delay_ms -= Delay;\n            Subiovel = false;\n        }\n        if (Bajovel) {\n            if (delay_ms &lt; Delaymaximo) delay_ms += Delay;\n            Bajovel = false;\n        }\n\n\n        if (!game_started) {\n            if (Reb1) { direction = 1; game_started = true; Reb1 = false; gpio_put(LEDS[current_led], 0);}\n            else if (Reb2) { direction = -1; game_started = true; Reb2 = false; gpio_put(LEDS[current_led], 0);}\n            else continue;\n        }\n\n        gpio_put(LEDS[current_led], 1);\n        sleep_ms(delay_ms);  //el delay depende del bot\u00f3n\n        gpio_put(LEDS[current_led], 0);\n\n        current_led += direction;\n\n        if (current_led == -1) {\n            if (Reb1) { direction = 1; current_led = 0; Reb1 = false; }\n            else { score_point(LedP1); current_led = Leds/2; direction = 1; }\n        }\n        if (current_led == Leds) {\n            if (Reb2) { direction = -1; current_led = Leds - 1; Reb2 = false; }\n            else { score_point(LedP2); current_led = Leds/2; direction = -1; }\n        }\n    }\n}\n</code></pre>"},{"location":"SistemasEmbebidos/Tareas/#diagrama-y-video_1","title":"Diagrama y video","text":""},{"location":"SistemasEmbebidos/Tareas/#tarea-7-pwm","title":"Tarea 7 PWM","text":"<p>Esta tarea consisti\u00f3 en aprender a hacer programas utilizando el generador de PWM de nuestro microcontrolador.</p>"},{"location":"SistemasEmbebidos/Tareas/#primera-actividad_1","title":"Primera actividad","text":"<p>Esta actividad consisti\u00f3 en que, mediante PWM vairemos el duty cycle con 2 botones para mover un motor DC a diferentes velocidades.</p>"},{"location":"SistemasEmbebidos/Tareas/#programa_5","title":"Programa","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n\n// Pines puente H TB6612\n#define PWMA   0   \n#define AIN1   1   \n#define AIN2   2   \n#define STBY   3   \n\n#define BTN_LOW   16\n#define BTN_MED   17\n#define BTN_HIGH  18\n\n#define F_PWM_HZ 2000   \n#define TOP 1023       \n\n#define DUTY_LOW   (TOP * 30 / 100)   // 30%\n#define DUTY_MED   (TOP * 60 / 100)   // 60%\n#define DUTY_HIGH  (TOP * 90 / 100)   // 90%\n\nint main() {\n    stdio_init_all();\n\n    gpio_init(AIN1);\n    gpio_set_dir(AIN1, GPIO_OUT);\n    gpio_put(AIN1, 1);\n\n    gpio_init(AIN2);\n    gpio_set_dir(AIN2, GPIO_OUT);\n    gpio_put(AIN2, 0);\n\n    gpio_init(STBY);\n    gpio_set_dir(STBY, GPIO_OUT);\n    gpio_put(STBY, 1);\n\n    gpio_set_function(PWMA, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(PWMA);\n    uint chan  = pwm_gpio_to_channel(PWMA);\n\n    float f_clk = 125000000.0f;\n    float div = f_clk / (F_PWM_HZ * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_wrap(slice, TOP);\n\n    pwm_set_chan_level(slice, chan, 0);\n    pwm_set_enabled(slice, true);\n\n    gpio_init(BTN_LOW);\n    gpio_set_dir(BTN_LOW, GPIO_IN);\n    gpio_pull_up(BTN_LOW);\n\n    gpio_init(BTN_HIGH);\n    gpio_set_dir(BTN_HIGH, GPIO_IN);\n    gpio_pull_up(BTN_HIGH);\n\n    while (1) {\n        if (!gpio_get(BTN_LOW)) {\n            pwm_set_chan_level(slice, chan, DUTY_LOW);\n        }\n\n        else if (!gpio_get(BTN_HIGH)) {\n            pwm_set_chan_level(slice, chan, DUTY_HIGH);\n        }\n        sleep_ms(100); \n    }\n}\n</code></pre>"},{"location":"SistemasEmbebidos/Tareas/#diagrama-y-video_2","title":"Diagrama y video","text":""},{"location":"SistemasEmbebidos/Tareas/#segunda-actividad_1","title":"Segunda actividad","text":"<p>Esta actividad consisti\u00f3 en hacer que con frecuencias generadas en el PWM un buzzer reprodujera una canci\u00f3n conocida.</p>"},{"location":"SistemasEmbebidos/Tareas/#programa_6","title":"Programa","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n#include &lt;stdint.h&gt;\n\n\n#define Buzzer 2\n#define TEMPO 200   // BPM\n\n#define DO3   34\n#define RE3   61\n#define MI3   68\n#define FA3   78\n#define SOL3  82\n#define SOLs3 111\n#define LA3   123\n#define SI3   151\n\n#define DO4   220\n#define DOs4  184\n#define RE4   250\n#define REs4  218\n#define MI4   282  \n#define FA4   300\n#define FAs4  277\n#define SOLb4 277\n#define SOL4  330\n#define SOLs4 350\n#define LAb4  350\n#define LA4   370\n#define LAs4  392\n#define SIb4  392\n#define SI4   420\n\n#define DO5   442\n#define DOs5  457\n#define RE5   495\n#define REs5  523\n#define MIb5  523\n#define MI5   560\n#define FA5   603\n#define FAs5  630\n#define SOL5  660\n#define SOLs5 735\n#define LA5   755\n#define LAs5  835\n#define SI5   845\n\n#define DO6   880\n\n#define SILENCIO 0\n\n\n// FIGURAS\n#define REDONDA   4.0f\n#define BLANCAP   3.0f\n#define BLANCA    2.0f\n#define NEGRA     1.0f\n#define CORCHEA   0.5f\n#define DCORCHEA  0.25f\n\nconst float reloj = 125000000.0f; // reloj 125 MHz\nuint slice_num;\nuint chan_num;\n\n\nstatic inline int duracion_ms(float figura) {\n    float negra_ms = 60000.0f / (float)TEMPO;\n    return (int)(figura * negra_ms + 0.5f);\n}\n\nvoid iniciar_pwm(uint gpio) {\n    gpio_set_function(gpio, GPIO_FUNC_PWM);\n    slice_num = pwm_gpio_to_slice_num(gpio);\n    chan_num  = pwm_gpio_to_channel(gpio);\n    pwm_set_enabled(slice_num, true);\n}\n\nvoid reproducir_nota(int frecuencia, float figura) {\n    if (frecuencia == SILENCIO) {\n        pwm_set_chan_level(slice_num, chan_num, 0);\n        sleep_ms(duracion_ms(figura));\n        return;\n    }\n\n    uint32_t wrap = 0;\n    float clkdiv = 1.0f;\n    for (int d = 1; d &lt;= 256; d++) {\n        float wrapf = reloj / ((float)d * (float)frecuencia) - 1.0f;\n        if (wrapf &gt;= 1.0f &amp;&amp; wrapf &lt;= 65535.0f) {\n            clkdiv = (float)d;\n            wrap = (uint32_t)(wrapf + 0.5f);\n            break;\n        }\n    }\n\n    if (wrap == 0) {\n        wrap = 65535;\n        clkdiv = reloj / ((wrap + 1) * (float)frecuencia);\n        if (clkdiv &lt; 1.0f) clkdiv = 1.0f;\n        if (clkdiv &gt; 256.0f) clkdiv = 256.0f;\n    }\n\n    pwm_set_clkdiv(slice_num, clkdiv);\n    pwm_set_wrap(slice_num, wrap);\n    pwm_set_chan_level(slice_num, chan_num, wrap / 2);\n\n    sleep_ms(duracion_ms(figura));\n\n    pwm_set_chan_level(slice_num, chan_num, 0);\n    sleep_ms(30);\n}\n\n\ntypedef struct {\n    int nota;\n    float figura;\n} Nota_t;\n\n\nNota_t escala[] = {\n    {MIb5, NEGRA},{SILENCIO, BLANCA}, {RE4, NEGRA}, {SILENCIO, BLANCA}, {MI4, NEGRA}, {SILENCIO, BLANCA}, {FA4, NEGRA}, {SILENCIO, BLANCA}, {SOL4, NEGRA}, {SILENCIO, BLANCA}, {LA4, NEGRA}, {SILENCIO, BLANCA}, {SI4, NEGRA}, {SILENCIO,BLANCA},\n {DO5, NEGRA}, {SILENCIO, BLANCA}, {RE5, NEGRA}, {SILENCIO, BLANCA}, {MI5, NEGRA}, {SILENCIO, BLANCA}, {FA5, NEGRA}, {SILENCIO, BLANCA}, {SOL5, NEGRA}, {SILENCIO, BLANCA}, {LA5, NEGRA}, {SILENCIO, BLANCA}, {SI5, NEGRA}, {SILENCIO,BLANCA}, {DO6,NEGRA}\n};\n\n\nNota_t cumple[] = {\n    {DO4, NEGRA}, {DO4, CORCHEA}, {RE4, CORCHEA}, {DO4, NEGRA}, {FA4, NEGRA}, {MI4, 2.0f},\n    {DO4, NEGRA}, {DO4, CORCHEA}, {RE4, CORCHEA}, {DO4, NEGRA}, {SOL4, NEGRA}, {FA4, 2.0f},\n    {DO4, NEGRA}, {DO4, CORCHEA}, {DO5, CORCHEA}, {LA4, NEGRA}, {FA4, NEGRA}, {MI4, NEGRA}, {RE4, 2.0f},\n    {SI4, NEGRA}, {SI4, CORCHEA}, {LA4, CORCHEA}, {FA4, NEGRA}, {SOL4, NEGRA}, {FA4, 2.0f}\n};\n\nNota_t mario[] = { {MI5, CORCHEA}, {MI5, CORCHEA}, {SILENCIO, CORCHEA}, {MI5, CORCHEA}, {SILENCIO, CORCHEA}, {DO5, CORCHEA}, {MI5, CORCHEA}, {SILENCIO, CORCHEA}, {SOL5, CORCHEA}, {SILENCIO, BLANCA}, {SOL4,CORCHEA}, {SILENCIO, CORCHEA},{SILENCIO, NEGRA},\n{DO5, NEGRA}, {SILENCIO, CORCHEA}, {SOL4, NEGRA}, {SILENCIO, CORCHEA}, {MI4, NEGRA}, {SILENCIO, CORCHEA}, {LA4, NEGRA}, {SI4, NEGRA}, {SIb4, CORCHEA}, {LA4, NEGRA}, {SOL4, CORCHEA}, {SILENCIO, DCORCHEA}, {MI5, CORCHEA}, {SILENCIO, DCORCHEA}, {SOL5, CORCHEA}, {SILENCIO, DCORCHEA}, {LA5, NEGRA}, {FA5, CORCHEA}, {SOL5, CORCHEA}, {SILENCIO, CORCHEA}, {MI5, NEGRA}, {DO5, CORCHEA}, {RE5, CORCHEA}, {SI4, NEGRA}, {SILENCIO, CORCHEA},\n{DO5, NEGRA}, {SILENCIO, CORCHEA}, {SOL4, NEGRA}, {SILENCIO, CORCHEA}, {MI4, NEGRA}, {SILENCIO, CORCHEA}, {LA4, NEGRA}, {SI4, NEGRA}, {SIb4, CORCHEA}, {LA4, NEGRA}, {SOL4, CORCHEA}, {SILENCIO, DCORCHEA}, {MI5, CORCHEA}, {SILENCIO, DCORCHEA}, {SOL5, CORCHEA}, {SILENCIO, DCORCHEA}, {LA5, NEGRA}, {FA5, CORCHEA}, {SOL5, CORCHEA}, {SILENCIO, CORCHEA}, {MI5, NEGRA}, {DO5, CORCHEA}, {RE5, CORCHEA}, {SI4, NEGRA}, {SILENCIO, NEGRA}, {SILENCIO, CORCHEA},\n{SOL5, CORCHEA}, {FAs5, CORCHEA}, {FA5, CORCHEA}, {REs5, NEGRA}, {MI5, CORCHEA}, {SILENCIO, CORCHEA}, {SOLs4, CORCHEA}, {LA4, CORCHEA}, {DO5, CORCHEA}, {SILENCIO, CORCHEA}, {LA4, CORCHEA}, {DO5, CORCHEA}, {RE5, CORCHEA}, {SILENCIO, NEGRA}, {SOL5, CORCHEA}, {FAs5, CORCHEA}, {FA5, CORCHEA}, {REs5, NEGRA}, {MI5, CORCHEA}, {SILENCIO, CORCHEA}, {DO6, NEGRA}, {DO6, CORCHEA}, {DO6, NEGRA}, {SILENCIO, BLANCA}, {SILENCIO, CORCHEA},\n{SOL5, CORCHEA}, {FAs5, CORCHEA}, {FA5, CORCHEA}, {REs5, NEGRA}, {MI5, CORCHEA}, {SILENCIO, CORCHEA}, {SOLs4, CORCHEA}, {LA4, CORCHEA}, {DO5, CORCHEA}, {SILENCIO, CORCHEA}, {LA4, CORCHEA}, {DO5, CORCHEA}, {RE5, CORCHEA}, {SILENCIO, NEGRA}, {MIb5, NEGRA}, {SILENCIO, CORCHEA}, {RE5, NEGRA}, {SILENCIO, CORCHEA}, {DO5, NEGRA}, {SILENCIO, BLANCA}, {SILENCIO, NEGRA},\n{SOL5, CORCHEA}, {FAs5, CORCHEA}, {FA5, CORCHEA}, {REs5, NEGRA}, {MI5, CORCHEA}, {SILENCIO, CORCHEA}, {SOLs4, CORCHEA}, {LA4, CORCHEA}, {DO5, CORCHEA}, {SILENCIO, CORCHEA}, {LA4, CORCHEA}, {DO5, CORCHEA}, {RE5, CORCHEA}, {SILENCIO, NEGRA}, {SOL5, CORCHEA}, {FAs5, CORCHEA}, {FA5, CORCHEA}, {REs5, NEGRA}, {MI5, CORCHEA}, {SILENCIO, CORCHEA}, {DO6, NEGRA}, {DO6, CORCHEA}, {DO6, NEGRA}, {SILENCIO, BLANCA}, {SILENCIO, CORCHEA},\n{SOL5, CORCHEA}, {FAs5, CORCHEA}, {FA5, CORCHEA}, {REs5, NEGRA}, {MI5, CORCHEA}, {SILENCIO, CORCHEA}, {SOLs4, CORCHEA}, {LA4, CORCHEA}, {DO5, CORCHEA}, {SILENCIO, CORCHEA}, {LA4, CORCHEA}, {DO5, CORCHEA}, {RE5, CORCHEA}, {SILENCIO, NEGRA}, {MIb5, NEGRA}, {SILENCIO, CORCHEA}, {RE5, NEGRA}, {SILENCIO, CORCHEA}, {DO5, NEGRA}, {SILENCIO, BLANCA},\n{DO5, CORCHEA}, {DO5, CORCHEA}, {SILENCIO, CORCHEA}, {DO5, CORCHEA}, {SILENCIO, CORCHEA}, {DO5, CORCHEA}, {RE5, NEGRA}, {MI5, CORCHEA}, {DO5, CORCHEA}, {SILENCIO, CORCHEA}, {LA4, CORCHEA}, {SOL4, BLANCA}, {DO5, CORCHEA}, {DO5, CORCHEA},  {SILENCIO, CORCHEA}, {DO5, CORCHEA}, {SILENCIO, CORCHEA}, {DO5, CORCHEA}, {RE5, CORCHEA}, {MI5, NEGRA}, {SILENCIO, REDONDA}, \n{DO5, CORCHEA}, {DO5, CORCHEA}, {SILENCIO, CORCHEA}, {DO5, CORCHEA}, {SILENCIO, CORCHEA}, {DO5, CORCHEA}, {RE5, NEGRA}, {MI5, CORCHEA}, {DO5, CORCHEA}, {SILENCIO, CORCHEA}, {LA4, CORCHEA}, {SOL4, BLANCA}, {SILENCIO, CORCHEA}, {MI5, CORCHEA}, {MI5, CORCHEA}, {SILENCIO, CORCHEA}, {MI5, CORCHEA}, {SILENCIO, CORCHEA}, {DO5, CORCHEA}, {MI5, CORCHEA}, {SILENCIO, CORCHEA}, {SOL5, CORCHEA}, {SILENCIO, BLANCA}, {SOL4,CORCHEA}, {SILENCIO, CORCHEA},{SILENCIO, NEGRA},\n{DO5, NEGRA}, {SILENCIO, CORCHEA}, {SOL4, NEGRA}, {SILENCIO, CORCHEA}, {MI4, NEGRA}, {SILENCIO, CORCHEA}, {LA4, NEGRA}, {SI4, NEGRA}, {SIb4, CORCHEA}, {LA4, NEGRA}, {SOL4, CORCHEA}, {SILENCIO, DCORCHEA}, {MI5, CORCHEA}, {SILENCIO, DCORCHEA}, {SOL5, CORCHEA}, {SILENCIO, DCORCHEA}, {LA5, NEGRA}, {FA5, CORCHEA}, {SOL5, CORCHEA}, {SILENCIO, CORCHEA}, {MI5, NEGRA}, {DO5, CORCHEA}, {RE5, CORCHEA}, {SI4, NEGRA}, {SILENCIO, CORCHEA},\n{DO5, NEGRA}, {SILENCIO, CORCHEA}, {SOL4, NEGRA}, {SILENCIO, CORCHEA}, {MI4, NEGRA}, {SILENCIO, CORCHEA}, {LA4, NEGRA}, {SI4, NEGRA}, {SIb4, CORCHEA}, {LA4, NEGRA}, {SOL4, CORCHEA}, {SILENCIO, DCORCHEA}, {MI5, CORCHEA}, {SILENCIO, DCORCHEA}, {SOL5, CORCHEA}, {SILENCIO, DCORCHEA}, {LA5, NEGRA}, {FA5, CORCHEA}, {SOL5, CORCHEA}, {SILENCIO, CORCHEA}, {MI5, NEGRA}, {DO5, CORCHEA}, {RE5, CORCHEA}, {SI4, NEGRA}, {SILENCIO, NEGRA}, {SILENCIO, NEGRA},\n{MI5, CORCHEA}, {DO5, NEGRA}, {SOL4, CORCHEA}, {SILENCIO, CORCHEA}, {SOLs4, NEGRA}, {LA4, CORCHEA}, {LA4, CORCHEA}, {FA5, NEGRA}, {FA5, CORCHEA}, {LA4, NEGRA}, {SILENCIO, NEGRA}, {SI4, CORCHEA}, {SILENCIO, DCORCHEA}, {LA5, CORCHEA}, {SILENCIO, DCORCHEA}, {LA5, CORCHEA}, {SILENCIO, DCORCHEA}, {LA5, CORCHEA}, {SILENCIO, DCORCHEA}, {SOL5, CORCHEA}, {SILENCIO, DCORCHEA}, {FA5, CORCHEA}, {SILENCIO, DCORCHEA}, {MI5, CORCHEA}, {DO5, NEGRA}, {LA4, CORCHEA}, {SOL4, NEGRA}, {SILENCIO, NEGRA},\n{MI5, CORCHEA}, {DO5, NEGRA}, {SOL4, CORCHEA}, {SILENCIO, CORCHEA}, {SOLs4, NEGRA}, {LA4, CORCHEA}, {LA4, CORCHEA}, {FA5, NEGRA}, {FA5, CORCHEA}, {LA4, NEGRA}, {SILENCIO, NEGRA}, {SI4, CORCHEA}, {FA5, NEGRA}, {FA5, CORCHEA}, {FA5, CORCHEA}, {SILENCIO, DCORCHEA}, {MI5, CORCHEA}, {SILENCIO, DCORCHEA}, {RE5, CORCHEA}, {SILENCIO,DCORCHEA}, {DO5, CORCHEA}, {SILENCIO, DCORCHEA}, {SOL4, CORCHEA}, {SILENCIO, DCORCHEA}, {MI4, CORCHEA}, {DO4, NEGRA}, {SILENCIO, NEGRA},\n{MI5, CORCHEA}, {DO5, NEGRA}, {SOL4, CORCHEA}, {SILENCIO, CORCHEA}, {SOLs4, NEGRA}, {LA4, CORCHEA}, {LA4, CORCHEA}, {FA5, NEGRA}, {FA5, CORCHEA}, {LA4, NEGRA}, {SILENCIO, NEGRA}, {SI4, CORCHEA}, {SILENCIO, DCORCHEA}, {LA5, CORCHEA}, {SILENCIO, DCORCHEA}, {LA5, CORCHEA}, {SILENCIO, DCORCHEA}, {LA5, CORCHEA}, {SILENCIO, DCORCHEA}, {SOL5, CORCHEA}, {SILENCIO, DCORCHEA}, {FA5, CORCHEA}, {SILENCIO, DCORCHEA}, {MI5, CORCHEA}, {DO5, NEGRA}, {LA4, CORCHEA}, {SOL4, NEGRA}, {SILENCIO, NEGRA},\n{MI5, CORCHEA}, {DO5, NEGRA}, {SOL4, CORCHEA}, {SILENCIO, CORCHEA}, {SOLs4, NEGRA}, {LA4, CORCHEA}, {LA4, CORCHEA}, {FA5, NEGRA}, {FA5, CORCHEA}, {LA4, NEGRA}, {SILENCIO, NEGRA}, {SI4, CORCHEA}, {FA5, NEGRA}, {FA5, CORCHEA}, {FA5, CORCHEA}, {SILENCIO, DCORCHEA}, {MI5, CORCHEA}, {SILENCIO, DCORCHEA}, {RE5, CORCHEA}, {SILENCIO,DCORCHEA}, {DO5, CORCHEA}, {SILENCIO, DCORCHEA}, {SOL4, CORCHEA}, {SILENCIO, DCORCHEA}, {MI4, CORCHEA}, {DO4, NEGRA}, {SILENCIO, BLANCA},\n{DO5, BLANCA}, {SILENCIO, DCORCHEA}, {SOL4, BLANCA}, {SILENCIO, DCORCHEA}, {MI4, NEGRA}, {SILENCIO, CORCHEA}, {LA4, NEGRA}, {SILENCIO, DCORCHEA}, {SI4, NEGRA}, {SILENCIO, DCORCHEA}, {SIb4, NEGRA}, {SILENCIO, DCORCHEA}, {LAb4, NEGRA}, {SILENCIO, DCORCHEA}, {SIb4, NEGRA}, {SILENCIO, DCORCHEA}, {LAb4, NEGRA}, {SILENCIO, DCORCHEA}, {SOL4, CORCHEA}, {FA4, CORCHEA}, {SOL4, BLANCAP}, {SILENCIO, REDONDA}, {SILENCIO, REDONDA}\n};\n\n\n// ---------- Funci\u00f3n gen\u00e9rica ----------\nvoid reproducir_melodia(Nota_t *melodia, int n) {\n    for (int i = 0; i &lt; n; i++) {\n        reproducir_nota(melodia[i].nota, melodia[i].figura);\n    }\n}\n\nint main() {\n    stdio_init_all();\n    iniciar_pwm(Buzzer);\n\n    Nota_t *melodia = mario;  // seleccionar la funci\u00f3n de melod\u00eda, cambiar mario por la que sea\n    int n = sizeof(mario) / sizeof(mario[0]);\n\n\n    while (1) {\n        reproducir_melodia(melodia, n);\n        sleep_ms(500); // pausa para el bucle de la melod\u00eda\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"SistemasEmbebidos/Tareas/#diagrama-y-video_3","title":"Diagrama y video","text":""},{"location":"SistemasEmbebidos/Tareas/#tercera-actividad","title":"Tercera actividad","text":"<p>Esta actividad consisti\u00f3 en generar una se\u00f1al PWM en la raspberry para pasarla por un filtro RC y medir la se\u00f1al, el objetivo fue hacer una se\u00f1al senosoidal observable en el osciloscopio.</p>"},{"location":"SistemasEmbebidos/Tareas/#programa_7","title":"Programa","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n#include \"hardware/pwm.h\"\n#include &lt;math.h&gt;\n\n#define PWMA 0       // GPIO 0 salida PWM\n#define FS   2000    // Frecuencia de muestreo de la tabla (Hz)\n#define F_SENO 60    // Frecuencia de la se\u00f1al senoidal (Hz)\n#define TOP   1023   // Resoluci\u00f3n PWM (10 bits)\n\n#define ALARM0_NUM 0\n#define ALARM0_IRQ timer_hardware_alarm_get_irq_num(timer_hw, ALARM0_NUM)\n\n#define TABLA_T (FS / F_SENO)\n\nuint16_t tabla_sen[TABLA_T];\nvolatile int x = 0;\n\nvoid alarm0_isr() {\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM0_NUM);\n    // Actualizar PWM con el siguiente valor del seno\n    pwm_set_gpio_level(PWMA, tabla_sen[x]);\n    x = (x + 1) % TABLA_T;\n    uint64_t now = time_us_64();\n    timer_hw-&gt;alarm[ALARM0_NUM] = (uint32_t)(now + 1000000 / FS);\n}\n\nint main() {\n    stdio_init_all();\n\n    for (int i = 0; i &lt; TABLA_T; i++) {\n        float ang = 2 * M_PI * i / TABLA_T;\n        float s = (sinf(ang) + 1.0f) / 2.0f;  // Normalizado 0\u20131\n        tabla_sen[i] = (uint16_t)(s * TOP);\n    }\n\n\n    gpio_set_function(PWMA, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(PWMA);\n    float f_clk = 125000000.0f; // clock base 125 MHz\n    float div = f_clk / (FS * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_wrap(slice, TOP);\n    pwm_set_enabled(slice, true);\n\n\n    irq_set_exclusive_handler(ALARM0_IRQ, alarm0_isr);\n    irq_set_enabled(ALARM0_IRQ, true);\n\n\n    uint64_t now = time_us_64();\n    timer_hw-&gt;alarm[ALARM0_NUM] = (uint32_t)(now + 1000000 / FS);\n\n    while (1) {\n        tight_loop_contents(); // loop vac\u00edo\n    }\n}\n</code></pre>"},{"location":"SistemasEmbebidos/Tareas/#fotos-de-comprobacion-y-diagrama","title":"Fotos de comprobaci\u00f3n y diagrama","text":""},{"location":"SistemasEmbebidos/Tareas/#tarea-8-uart","title":"Tarea 8 UART","text":"<p>Esta tarea consisti\u00f3 en aprender a hacer programas utilizando la comunicaci\u00f3n del puerto serial para hacer conexiones entre microcontroladores con el objetivo de leer, mandar, procesar, recibir y comparar comandos para activar leds.</p>"},{"location":"SistemasEmbebidos/Tareas/#primera-actividad_2","title":"Primera actividad","text":"<p>Esta actividad consisti\u00f3 en que, utilizando conexi\u00f3n serial entre dos RPP 2 y un comando, encender un led parpadeante.</p>"},{"location":"SistemasEmbebidos/Tareas/#programa_8","title":"Programa","text":"<pre><code>#include \"pico/stdlib.h\"\n#include &lt;stdio.h&gt;\n\n#define UART_ID uart1\n#define BAUD_RATE 115200\n#define TX_PIN 0\n#define RX_PIN 1\n\n\n\nint main() {\n    stdio_init_all();\n\n\n    gpio_set_function(TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(RX_PIN, GPIO_FUNC_UART);\n\n    uart_init(UART_ID, BAUD_RATE);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n\n\n    sleep_ms(2000); // tiempo para enumeraci\u00f3n USB\n\n    while (getchar_timeout_us(0) != PICO_ERROR_TIMEOUT) {\n    // solo leer y descartar cualquier car\u00e1cter residual\n}\n\n    printf(\"\\n[Pico USB] Conexi\u00f3n lista. Escribe algo y Enter.\\n\");\n\n    while (true) {\n        int ch = getchar_timeout_us(0);\n        if (ch != PICO_ERROR_TIMEOUT) {\n            printf(\"Eco: %c\\n\", (char)ch);\n            uart_putc(UART_ID, (char)ch); \n        }\n        sleep_ms(10);\n    }\n}\n</code></pre>"},{"location":"SistemasEmbebidos/Tareas/#video","title":"Video","text":""},{"location":"SistemasEmbebidos/Tareas/#segunda-actividad_2","title":"Segunda actividad","text":"<p>Esta actividad consisti\u00f3 en que, utilizando conexi\u00f3n serial UART de 2 RPP2, se use la terminal para encender el led contrario con un comando escrito \"on\" y \"off\".</p>"},{"location":"SistemasEmbebidos/Tareas/#programa_9","title":"Programa","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n#include &lt;string&gt;\n\n#define UART_ID uart0\n#define BAUD_RATE 115200\n#define UART_TX_PIN 0\n#define UART_RX_PIN 1\n#define LED_PIN 2\n\nusing namespace std;\n\nint main() {\n    stdio_init_all(); // Inicializa USB serial\n    sleep_ms(2000);\n\n    printf(\"\\n[Pico listo] Comunicaci\u00f3n UART iniciando...\\n\");\n\n    // Inicializa UART antes de asignar pines\n    uart_init(UART_ID, BAUD_RATE);\n    gpio_set_function(UART_TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(UART_RX_PIN, GPIO_FUNC_UART);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n    uart_set_fifo_enabled(UART_ID, true);\n\n    // Configuraci\u00f3n del LED\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, GPIO_OUT);\n    gpio_put(LED_PIN, 0);\n\n    string mensaje_usb = \"\";\n    string mensaje_uart = \"\";\n\n    while (true) {\n        //Escritura mensaje\n        int ch = getchar_timeout_us(0); // no bloqueante\n        if (ch != PICO_ERROR_TIMEOUT) {\n            if (ch == '\\n' || ch == '\\r') {\n                if (!mensaje_usb.empty()) {\n                    uart_puts(UART_ID, (mensaje_usb + \"\\n\").c_str());\n                    printf(\"Mensaje enviado: %s\\n\", mensaje_usb.c_str());\n                    mensaje_usb = \"\";\n                }\n            } else {\n                mensaje_usb += (char)ch;\n            }\n        }\n\n        //Lectura en UART\n        while (uart_is_readable(UART_ID)) {\n            char ch_uart = uart_getc(UART_ID);\n\n            if (ch_uart == '\\n' || ch_uart == '\\r') {\n                if (!mensaje_uart.empty()) {\n                    printf(\"Mensaje recibido: %s\\n\", mensaje_uart.c_str());\n\n                    // Comparar informaci\u00f3n\n                    if (mensaje_uart == \"on\" || mensaje_uart == \"ON\") {\n                        gpio_put(LED_PIN, 1);\n                        printf(\"LED encendido\\n\");\n                    } else if (mensaje_uart == \"off\" || mensaje_uart == \"OFF\") {\n                        gpio_put(LED_PIN, 0);\n                        printf(\"LED apagado\\n\");\n                    } else {\n                        printf(\"Comando desconocido.\\n\");\n                    }\n\n                    mensaje_uart = \"\";\n                }\n            } else {\n                mensaje_uart += ch_uart;\n            }\n        }\n\n        sleep_ms(10);\n    }\n}\n</code></pre>"},{"location":"SistemasEmbebidos/Tareas/#video_1","title":"Video","text":""},{"location":"SistemasEmbebidos/Tareas/#tercera-actividad_1","title":"Tercera actividad","text":"<p>Esta actividad consisti\u00f3 en que, utilizando conexi\u00f3n serial UART de 2 RPP2, se confirme la conexi\u00f3n con un programa de comandos en la terminal tipo \"handshake\" para empezar a ejecutar el programa de la actividad anterior, el que trataba sobre encender el led contrario con un comando escrito \"on\" y \"off\".</p>"},{"location":"SistemasEmbebidos/Tareas/#programa-del-emisor-a","title":"Programa del emisor (A)","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n#include &lt;string&gt;\n\n#define UART_ID uart0\n#define BAUD_RATE 115200\n#define UART_TX_PIN 0\n#define UART_RX_PIN 1\n#define LED_PIN 2\n\nusing namespace std;\n\nint main() {\n    stdio_init_all();\n    sleep_ms(2000);\n\n    printf(\"\\n[Pico A listo] Escribe 'conectar' para iniciar handshake.\\n\");\n\n    uart_init(UART_ID, BAUD_RATE);\n    gpio_set_function(UART_TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(UART_RX_PIN, GPIO_FUNC_UART);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n    uart_set_fifo_enabled(UART_ID, true);\n\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, GPIO_OUT);\n    gpio_put(LED_PIN, 0);\n\n    string usb_msg = \"\";\n    string uart_msg = \"\";\n    bool conectado = false;\n\n    while (true) {\n        // Leer comandos desde USB\n        int ch = getchar_timeout_us(0);\n        if (ch != PICO_ERROR_TIMEOUT) {\n            if (ch == '\\n' || ch == '\\r') {\n                if (!usb_msg.empty()) {\n                    uart_puts(UART_ID, (usb_msg + \"\\n\").c_str());\n                    printf(\"[Enviado por UART]: %s\\n\", usb_msg.c_str());\n                    usb_msg = \"\";\n                }\n            } else usb_msg += (char)ch;\n        }\n\n        // Leer mensajes por UART\n        while (uart_is_readable(UART_ID)) {\n            char c = uart_getc(UART_ID);\n            if (c == '\\n' || c == '\\r') {\n                if (!uart_msg.empty()) {\n                    printf(\"[Recibido]: %s\\n\", uart_msg.c_str());\n\n                    if (!conectado) {\n                        if (uart_msg == \"ok\") {\n                            printf(\"Pico B respondi\u00f3 OK.\\n\");\n                        } else if (uart_msg == \"conectado\") {\n                            printf(\"Conexi\u00f3n establecida \\n\");\n                            conectado = true;\n                        } else {\n                            printf(\"[Error] Mensaje inesperado durante handshake.\\n\");\n                        }\n                    } else {\n                        if (uart_msg == \"on\" || uart_msg == \"ON\") {\n                            gpio_put(LED_PIN, 1);\n                            printf(\"[LED] Encendido (por comando remoto)\\n\");\n                        } else if (uart_msg == \"off\" || uart_msg == \"OFF\") {\n                            gpio_put(LED_PIN, 0);\n                            printf(\"[LED] Apagado (por comando remoto)\\n\");\n                        } else {\n                            printf(\"Error: Comando desconocido tras conexi\u00f3n.\\n\");\n                        }\n                    }\n                    uart_msg = \"\";\n                }\n            } else uart_msg += c;\n        }\n\n        sleep_ms(10);\n    }\n}\n</code></pre>"},{"location":"SistemasEmbebidos/Tareas/#programa-del-receptor-b","title":"Programa del receptor (B)","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n#include &lt;string&gt;\n\n#define UART_ID uart0\n#define BAUD_RATE 115200\n#define UART_TX_PIN 0\n#define UART_RX_PIN 1\n#define LED_PIN 2\n\nusing namespace std;\n\nint main() {\n    stdio_init_all();\n    sleep_ms(2000);\n\n    printf(\"\\nPico B listo, Esperando handshake desde el otro dispositivo...\\n\");\n\n    uart_init(UART_ID, BAUD_RATE);\n    gpio_set_function(UART_TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(UART_RX_PIN, GPIO_FUNC_UART);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n    uart_set_fifo_enabled(UART_ID, true);\n\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, GPIO_OUT);\n    gpio_put(LED_PIN, 0);\n\n    string uart_msg = \"\";\n    string usb_msg = \"\";\n    bool conectado = false;\n\n    while (true) {\n        // Leer mensajes entrantes por UART\n        while (uart_is_readable(UART_ID)) {\n            char c = uart_getc(UART_ID);\n            if (c == '\\n' || c == '\\r') {\n                if (!uart_msg.empty()) {\n                    printf(\"Recibido: %s\\n\", uart_msg.c_str());\n\n                    if (!conectado) {\n                        if (uart_msg == \"conectar\") {\n                            uart_puts(UART_ID, \"ok\\n\");\n                            sleep_ms(300);\n                            uart_puts(UART_ID, \"conectado\\n\");\n                            conectado = true;\n                            printf(\"Conexi\u00f3n establecida\\n\");\n                        } else {\n                            uart_puts(UART_ID, \"error\\n\");\n                            printf(\"Error, mensaje inesperado durante handshake.\\n\");\n                        }\n                    } else {\n                        if (uart_msg == \"on\" || uart_msg == \"ON\") {\n                            gpio_put(LED_PIN, 1);\n                            printf(\"LED encendido\\n\");\n                        } else if (uart_msg == \"off\" || uart_msg == \"OFF\") {\n                            gpio_put(LED_PIN, 0);\n                            printf(\"LED apagado\\n\");\n                        } else {\n                            printf(\"[Error] Comando desconocido tras conexi\u00f3n.\\n\");\n                        }\n                    }\n                    uart_msg = \"\";\n                }\n            } else uart_msg += c;\n        }\n\n\n        int ch = getchar_timeout_us(0);\n        if (ch != PICO_ERROR_TIMEOUT) {\n            if (ch == '\\n' || ch == '\\r') {\n                if (!usb_msg.empty()) {\n                    uart_puts(UART_ID, (usb_msg + \"\\n\").c_str());\n                    printf(\"[Enviado por UART]: %s\\n\", usb_msg.c_str());\n                    usb_msg = \"\";\n                }\n            } else usb_msg += (char)ch;\n        }\n\n        sleep_ms(10);\n    }\n}\n</code></pre>"},{"location":"SistemasEmbebidos/Tareas/#video_2","title":"Video","text":""}]}