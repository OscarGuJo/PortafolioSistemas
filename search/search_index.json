{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"About me","text":"<p>Cuenta: 199064</p> <p>Este es mi portafolio personal, donde voy a publicar todos mis avances, procedimientos, observaciones y resultados de mis proyectos dentro de mi carrera a partir del quinto semestre.  </p> <p>Me llamo Oscar Guzman Jorge, soy un alumno que cursa la carrera de mecatr\u00f3nica en la Universidad Iberoamericana Puebla, actualmente, en Agosto de 2025 tengo 20 a\u00f1os. Estoy cursando el quinto semestre, pero he hecho numerosos aportes personales (IEEE) y para mi universidad.</p>"},{"location":"Ejemplos%20y%20Gu%C3%ADas/comandos/","title":"Encabezados","text":"<pre><code># T\u00edtulo H1\n## T\u00edtulo H2\n### T\u00edtulo H3\n</code></pre>"},{"location":"Ejemplos%20y%20Gu%C3%ADas/comandos/#titulo-h1","title":"T\u00edtulo H1","text":""},{"location":"Ejemplos%20y%20Gu%C3%ADas/comandos/#titulo-h2","title":"T\u00edtulo H2","text":""},{"location":"Ejemplos%20y%20Gu%C3%ADas/comandos/#titulo-h3","title":"T\u00edtulo H3","text":""},{"location":"Ejemplos%20y%20Gu%C3%ADas/comandos/#enfasis-y-codigo-en-linea","title":"\u00c9nfasis y c\u00f3digo en l\u00ednea","text":"<pre><code>**negritas**, *cursivas*, ~~tachado~~, `c\u00f3digo en l\u00ednea`\n</code></pre> <p>negritas, cursivas, ~~tachado~~, <code>c\u00f3digo en l\u00ednea</code></p>"},{"location":"Ejemplos%20y%20Gu%C3%ADas/comandos/#citas-blockquote","title":"Citas (blockquote)","text":"<pre><code>&gt; Esta es una cita destacada.\n&gt; Puede tener m\u00faltiples l\u00edneas.\n</code></pre> <p>Esta es una cita destacada. Puede tener m\u00faltiples l\u00edneas.</p>"},{"location":"Ejemplos%20y%20Gu%C3%ADas/comandos/#enlaces","title":"Enlaces","text":"<pre><code>[Enlace directo](https://www.iberopuebla.mx/)\n\n[Texto del enlace de referencia][doc-ref]\n\n[doc-ref]: https://www.iberopuebla.mx//docs \"T\u00edtulo opcional\"\n</code></pre> <p>Enlace directo</p> <p>Texto del enlace de referencia</p>"},{"location":"Ejemplos%20y%20Gu%C3%ADas/comandos/#listas-vinetas-numeradas-y-de-tareas","title":"Listas: vi\u00f1etas, numeradas y de tareas","text":"<pre><code>- Item A\n    * Subitem A.1\n    * Subitem A.2\n- Item B\n    - Subitem B.1\n    - Subitem B.2\n\n1.  Paso 1\n    1.  Paso 1.1\n    2.  Paso 1.2\n        1.  Paso 1.2.1\n        2.  Paso 1.2.2\n\n- [x] Hecho\n- [ ] Pendiente\n</code></pre> <ul> <li>Item A<ul> <li>Subitem A.1</li> <li>Subitem A.2</li> </ul> </li> <li>Item B<ul> <li>Subitem B.1</li> <li>Subitem B.2</li> </ul> </li> </ul> <ol> <li> <p>Paso 1</p> <ol> <li>Paso 1.1</li> <li>Paso 1.2<ol> <li>Paso 1.2.1</li> <li>Paso 1.2.2</li> </ol> </li> </ol> </li> <li> <p> Hecho</p> </li> <li> Pendiente</li> </ol>"},{"location":"Ejemplos%20y%20Gu%C3%ADas/comandos/#tablas","title":"Tablas","text":"<pre><code>| Componente | Cant. | Nota        |\n|-----------:|:-----:|-------------|\n| Sensor X   | 2     | I2C         |\n| MCU Y      | 1     | WiFi/BLE    |\n</code></pre> Componente Cant. Nota Sensor X 2 I2C MCU Y 1 WiFi/BLE"},{"location":"Ejemplos%20y%20Gu%C3%ADas/comandos/#imagenes","title":"Im\u00e1genes","text":"<pre><code>![Diagrama del sistema](recursos/imgs/ibero.jpeg)\n\n&lt;!-- Control de tama\u00f1o usando HTML (cuando se requiera) --&gt;\n&lt;img src=\"../recursos/imgs/ibero.jpeg\" alt=\"Diagrama del sistema\" width=\"420\"&gt;\n</code></pre>"},{"location":"Ejemplos%20y%20Gu%C3%ADas/comandos/#pdfs-enlace-y-embebido","title":"PDFs (enlace y embebido)","text":"<pre><code>[Descargar especificaci\u00f3n (PDF)](recursos/archivos/Calendario.pdf)\n\n&lt;!-- Embed (requiere navegador compatible) --&gt;\n&lt;object data=\"recursos/archivos/Calendario.pdf\" type=\"application/pdf\" width=\"100%\" height=\"600\"&gt;\n  &lt;p&gt;No se pudo mostrar el PDF. &lt;a href=\"../recursos/archivos/Calendario.pdf\"&gt;Descargar&lt;/a&gt;&lt;/p&gt;\n&lt;/object&gt;\n</code></pre> <p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"Ejemplos%20y%20Gu%C3%ADas/comandos/#admonitions-material","title":"Admonitions (Material)","text":"<pre><code>!!! note \"Nota\"\n    Esto es una nota informativa.\n\n!!! tip \"Sugerencia\"\n    Un consejo breve para el usuario.\n\n!!! warning \"Advertencia\"\n    Precauciones o riesgos a considerar.\n\n??? info \"M\u00e1s informaci\u00f3n (colapsable)\"\n    Contenido adicional que se puede expandir.\n</code></pre> <p>Nota</p> <p>Esto es una nota informativa.</p> <p>Sugerencia</p> <p>Un consejo breve para el usuario.</p> <p>Advertencia</p> <p>Precauciones o riesgos a considerar.</p> M\u00e1s informaci\u00f3n (colapsable) <p>Contenido adicional que se puede expandir.</p>"},{"location":"Ejemplos%20y%20Gu%C3%ADas/comandos/#codigo-con-resaltado","title":"C\u00f3digo con resaltado","text":"<p><pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre> <pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre></p>"},{"location":"Ejemplos%20y%20Gu%C3%ADas/comandos/#separador-horizontal","title":"Separador horizontal","text":"<pre><code>---\n</code></pre>"},{"location":"Ejemplos%20y%20Gu%C3%ADas/comandos/#listas-anidadas-con-codigo-y-notas","title":"Listas anidadas con c\u00f3digo y notas","text":"<pre><code>- **M\u00f3dulo A**\n  - Funci\u00f3n: `procesar()`\n  - Entrada:\n    - `signal` (float)\n    - `freq` (Hz)\n  - Salida:\n    - JSON con `valor`, `unidad`\n  - !!! note\n        Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> <ul> <li>M\u00f3dulo A</li> <li>Funci\u00f3n: <code>procesar()</code></li> <li>Entrada:<ul> <li><code>signal</code> (float)</li> <li><code>freq</code> (Hz)</li> </ul> </li> <li>Salida:<ul> <li>JSON con <code>valor</code>, <code>unidad</code></li> </ul> </li> <li> <p>Note</p> <pre><code>Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> </li> </ul>"},{"location":"Ejemplos%20y%20Gu%C3%ADas/comandos/#bloques-de-cita-con-codigo-pseudo-logs","title":"Bloques de cita con c\u00f3digo (pseudo-logs)","text":"<pre><code>&gt; **Log:**\n&gt; ```\n&gt; [12:00:00] Init OK\n&gt; [12:00:01] Conectando a I2C...\n&gt; [12:00:02] Lectura: 523 mV\n&gt; ```\n</code></pre> <p>Log: <pre><code>[12:00:00] Init OK\n[12:00:01] Conectando a I2C...\n[12:00:02] Lectura: 523 mV\n</code></pre></p>"},{"location":"Ejemplos%20y%20Gu%C3%ADas/ejemplo/","title":"\ud83d\udcda Ejemplo de Documentaci\u00f3n del Proyecto","text":"<p>Plantilla gen\u00e9rica para documentar proyectos acad\u00e9micos o de ingenier\u00eda. Copia y adapta las secciones seg\u00fan tu necesidad.</p>"},{"location":"Ejemplos%20y%20Gu%C3%ADas/ejemplo/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Mi Proyecto </li> <li>Equipo / Autor(es): Nombre(s) </li> <li>Curso / Asignatura: Nombre del curso </li> <li>Fecha: DD/MM/AAAA </li> <li>Descripci\u00f3n breve: Una o dos l\u00edneas que expliquen qu\u00e9 hace y por qu\u00e9.</li> </ul> <p>Consejo</p> <p>Mant\u00e9n este resumen corto (m\u00e1x. 5 l\u00edneas). Lo dem\u00e1s va en secciones espec\u00edficas.</p>"},{"location":"Ejemplos%20y%20Gu%C3%ADas/ejemplo/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Qu\u00e9 se pretende lograr en t\u00e9rminos amplios.</li> <li>Espec\u00edficos:</li> <li>OE1\u2026</li> <li>OE2\u2026</li> <li>OE3\u2026</li> </ul>"},{"location":"Ejemplos%20y%20Gu%C3%ADas/ejemplo/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: Qu\u00e9 funcionalidades/entregables s\u00ed est\u00e1n en el proyecto.</li> <li>No incluye: Qu\u00e9 queda fuera para evitar malentendidos.</li> </ul>"},{"location":"Ejemplos%20y%20Gu%C3%ADas/ejemplo/#4-requisitos","title":"4) Requisitos","text":"<p>Software - SO compatible (Windows/Linux/macOS) - Python 3.x / Node 18+ / Arduino IDE / etc. - Dependencias (p. ej., pip/requirements, npm packages)</p> <p>Hardware (si aplica) - MCU / Sensores / Actuadores / Fuente de poder - Herramientas (mult\u00edmetro, caut\u00edn, etc.)</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en X - Electr\u00f3nica b\u00e1sica - Git/GitHub</p>"},{"location":"Ejemplos%20y%20Gu%C3%ADas/ejemplo/#5-instalacion","title":"5) Instalaci\u00f3n","text":"<pre><code># 1) Clonar\ngit clone https://github.com/&lt;usuario&gt;/&lt;repo&gt;.git\ncd &lt;repo&gt;\n\n# 2) (Opcional) Crear entorno virtual\npython -m venv .venv\n# macOS/Linux\nsource .venv/bin/activate\n# Windows (PowerShell)\n.venv\\Scripts\\Activate.ps1\n\n# 3) Instalar dependencias (ejemplos)\npip install -r requirements.txt\n# o, si es Node:\nnpm install\n</code></pre>"},{"location":"Ejemplos%20y%20Gu%C3%ADas/gitcmds/","title":"\ud83d\ude80 Comandos b\u00e1sicos de Git (primeros pasos)","text":"<p>En este curso solo usaremos los comandos esenciales de Git para trabajar con repositorios.</p>"},{"location":"Ejemplos%20y%20Gu%C3%ADas/gitcmds/#1-clonar-un-repositorio","title":"1. Clonar un repositorio","text":"<p>Copia un proyecto de GitHub a tu computadora.</p> <pre><code>git clone https://github.com/usuario/repositorio.git\n</code></pre>"},{"location":"Ejemplos%20y%20Gu%C3%ADas/gitcmds/#2-verificar-cambios","title":"2. Verificar cambios","text":"<p>Muestra qu\u00e9 archivos has modificado o agregado.</p> <pre><code>git status\n</code></pre>"},{"location":"Ejemplos%20y%20Gu%C3%ADas/gitcmds/#3-preparar-cambios","title":"3. Preparar cambios","text":"<p>Agrega archivos para guardarlos en el pr\u00f3ximo commit.</p> <pre><code>git add archivo.txt\ngit add .   # agrega todos los archivos modificados\n</code></pre>"},{"location":"Ejemplos%20y%20Gu%C3%ADas/gitcmds/#4-guardar-cambios-commit","title":"4. Guardar cambios (commit)","text":"<p>Guarda tus cambios con un mensaje descriptivo.</p> <pre><code>git commit -m \"Descripci\u00f3n breve de los cambios\"\n</code></pre>"},{"location":"Ejemplos%20y%20Gu%C3%ADas/gitcmds/#5-subir-cambios-al-repositorio-push","title":"5. Subir cambios al repositorio (push)","text":"<p>Env\u00eda tus commits locales al repositorio en GitHub.</p> <pre><code>git push origin main\n</code></pre>"},{"location":"Ejemplos%20y%20Gu%C3%ADas/gitcmds/#6-traer-cambios-del-remoto-pull","title":"6. Traer cambios del remoto (pull)","text":"<p>Actualiza tu proyecto con los \u00faltimos cambios de GitHub.</p> <pre><code>git pull origin main\n</code></pre>"},{"location":"Ejemplos%20y%20Gu%C3%ADas/gitcmds/#flujo-tipico-de-trabajo","title":"Flujo t\u00edpico de trabajo","text":"<ol> <li> <p>Traer cambios del remoto <pre><code>git pull origin main\n</code></pre></p> </li> <li> <p>Editar tus archivos de proyecto.</p> </li> <li> <p>Preparar los cambios <pre><code>git add .\n</code></pre></p> </li> <li> <p>Guardar los cambios <pre><code>git commit -m \"Mensaje descriptivo\"\n</code></pre></p> </li> <li> <p>Enviar los cambios al remoto <pre><code>git push origin main\n</code></pre></p> </li> </ol> <p>Consejo</p> <p>Piensa en este ciclo como un loop infinito: cada vez que quieras contribuir \u2192 primero <code>pull</code>, despu\u00e9s <code>add</code> + <code>commit</code>, y finalmente <code>push</code>.</p>"},{"location":"EmbededSystems_II/Exams/","title":"EXAMS","text":""},{"location":"EmbededSystems_II/Exams/#primer-parcial","title":"Primer Parcial:","text":""},{"location":"EmbededSystems_II/Homework/","title":"ASSIGNMENTS OF THE COURSE","text":""},{"location":"EmbededSystems_II/Homework/#assignment-1-tasks-1-5","title":"Assignment 1: Tasks 1-5","text":""},{"location":"EmbededSystems_II/Homework/#objective","title":"Objective","text":"<p>The goal of this exercise is to train you to identify logical FreeRTOS tasks from system behavior, even when no RTOS code is shown.</p> <p>You should focus on:</p> <p>-Timing requirements.</p> <p>-Blocking behavior.</p> <p>-Safety and criticality.</p> <p>-Independent execution flows.</p> <p>Think in terms of \"what must happen independently\", not functions or lines of code.</p>"},{"location":"EmbededSystems_II/Homework/#description","title":"Description","text":"<p>The system:</p> <p>-Reads a temperature sensor every 50 ms.</p> <p>-Sends sensor data via Wi-Fi every 2 seconds.</p> <p>-Monitors an emergency button continuously.</p> <p>-Blinks a status LED at 1 Hz.</p> <p>-Stores error messages when failures occur.</p> <p>Assume:</p> <p>-The system runs on a microcontroller.</p> <p>-Timing matters.</p> <p>-Some operations may block (Wi-Fi, storage).</p>"},{"location":"EmbededSystems_II/Homework/#exercise-1-identify-logical-tasks","title":"Exercise 1 - Identify Logical Tasks","text":"<p>List the logical tasks that exist in this system.</p> <p></p>"},{"location":"EmbededSystems_II/Homework/#exercise-2-task-characteristics","title":"Exercise 2 - Task Characteristics","text":"<p>For each task you identified, answer the following:</p> <p>-Is it time-critical? (Yes/No).</p> <p>-Can it block safely? (Yes/No).</p> <p>-What happens if this task is delayed?.</p> <p>Write short, technical answers.</p> <p></p>"},{"location":"EmbededSystems_II/Homework/#excersice-3-priority-reasoning","title":"Excersice 3 - Priority Reasoning","text":"<p>Assign a relative priority to each task:</p> <p>-High.</p> <p>-Medium.</p> <p>-Low.</p> <p>Then justify each choice in one sentece.</p> <p></p>"},{"location":"EmbededSystems_II/Homework/#exercise-4-design-judgment-trick-question","title":"Exercise 4 - Design Judgment (Trick Question)","text":"<p>Which of the following should NOT necessarily be implemented as a FreeRTOS task?</p> <p>-Emergency button monitoring.</p> <p>-Wi-Fi trnsmission.</p> <p>-Error logging.</p> <p>-Status LED blinking.</p> <p>Explain why in 2-3 sentences.</p> <p></p>"},{"location":"EmbededSystems_II/Homework/#assignment-2-lab-1-3","title":"Assignment 2: LAB 1-3","text":""},{"location":"EmbededSystems_II/Homework/#lab-1","title":"Lab 1","text":"<p>Create two tasks:</p> <p>blink_task: toggles an LED every 300 ms</p> <p>hello_task: prints a message every 1 second</p>"},{"location":"EmbededSystems_II/Homework/#what-to-watch-for","title":"What to watch for","text":"<ul> <li>Both tasks run (interleave).</li> <li>Changing priority can change which task runs \u201cmore\u201d or \u201cfirst\u201d.</li> <li>If you remove a delay from a task, it may hog the CPU.</li> </ul>"},{"location":"EmbededSystems_II/Homework/#code-lab-1","title":"Code Lab 1","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"driver/gpio.h\"\n#include \"esp_log.h\"\n\n#define LED_GPIO GPIO_NUM_2   // CHANGE for your board\n\nstatic const char *TAG = \"LAB1\";\n\nstatic void blink_task(void *pvParameters)\n{\n    gpio_reset_pin(LED_GPIO);\n    gpio_set_direction(LED_GPIO, GPIO_MODE_OUTPUT);\n\n    while (1) {\n        gpio_set_level(LED_GPIO, 1);\n        vTaskDelay(pdMS_TO_TICKS(300));\n        gpio_set_level(LED_GPIO, 0);\n        vTaskDelay(pdMS_TO_TICKS(300));\n    }\n}\n\nstatic void hello_task(void *pvParameters)\n{\n    int n = 0;\n    while (1) {\n        ESP_LOGI(TAG, \"hello_task says hi, n=%d\", n++);\n        vTaskDelay(pdMS_TO_TICKS(1000));\n    }\n}\n\nvoid app_main(void)\n{\n    ESP_LOGI(TAG, \"Starting Lab 1 (two tasks)\");\n\n    // Stack size in ESP-IDF FreeRTOS is in BYTES\n    xTaskCreate(blink_task, \"blink_task\", 2048, NULL, 5, NULL);\n    xTaskCreate(hello_task, \"hello_task\", 2048, NULL, 5, NULL);\n}\n</code></pre> <ol> <li>Priority experiment: change hello_task priority from 5 to 2.</li> <li>Does behavior change? Why might it (or might it not)?</li> <li>Starvation demo: temporarily remove vTaskDelay(...) from hello_task.</li> <li>What happens to blinking?</li> <li>Put the delay back and explain in one sentence why blocking helps.</li> </ol>"},{"location":"EmbededSystems_II/Homework/#answers","title":"Answers","text":"<p>1.-Priority experiment (hello_task priority 5 \u2192 2):</p> <p>The blink_task runs more consistently, while hello_task still runs but may execute less frequently.</p> <p>2.- Does behavior change? Why might it (or might it not)?</p> <p>The behavior changes slightly because a higher-priority task is scheduled first, but both tasks still run since they block using delays.</p> <p>3.- Starvation demo (remove vTaskDelay from hello_task):</p> <p>hello_task runs continuously and at some point the CPU crashes.</p> <p>4.- What happens to blinking?</p> <p>The LED stops blinking or becomes very irregular because blink_task is starved of CPU time.</p> <p>5.- Why blocking helps (one sentence):</p> <p>Blocking with delays allows to switch tasks fairly and prevents one task from monopolizing the CPU.</p>"},{"location":"EmbededSystems_II/Homework/#lab-2","title":"Lab 2","text":"<p>Use a queue to pass integers from a producer task to a consumer task.</p> <p>Why it matters: - Queues are a clean way to pass data without sharing global variables.</p>"},{"location":"EmbededSystems_II/Homework/#code-lab-2","title":"Code Lab 2","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/queue.h\"\n#include \"esp_log.h\"\n\nstatic const char *TAG = \"LAB2\";\nstatic QueueHandle_t q_numbers;\n\nstatic void producer_task(void *pvParameters)\n{\n    int value = 0;\n\n    while (1) {\n        value++;\n\n        // Send to queue; wait up to 50ms if full\n        if (xQueueSend(q_numbers, &amp;value, pdMS_TO_TICKS(50)) == pdPASS) {\n            ESP_LOGI(TAG, \"Produced %d\", value);\n        } else {\n            ESP_LOGW(TAG, \"Queue full, dropped %d\", value);\n        }\n\n        vTaskDelay(pdMS_TO_TICKS(200));\n    }\n}\n\nstatic void consumer_task(void *pvParameters)\n{\n    int rx = 0;\n\n    while (1) {\n        // Wait up to 1000ms for data\n        if (xQueueReceive(q_numbers, &amp;rx, pdMS_TO_TICKS(1000)) == pdPASS) {\n            ESP_LOGI(TAG, \"Consumed %d\", rx);\n        } else {\n            ESP_LOGW(TAG, \"No data in 1s\");\n        }\n    }\n}\n\nvoid app_main(void)\n{\n    ESP_LOGI(TAG, \"Starting Lab 2 (queue)\");\n\n    q_numbers = xQueueCreate(5, sizeof(int)); // length 5\n    if (q_numbers == NULL) {\n        ESP_LOGE(TAG, \"Queue create failed\");\n        return;\n    }\n\n    xTaskCreate(producer_task, \"producer_task\", 2048, NULL, 5, NULL);\n    xTaskCreate(consumer_task, \"consumer_task\", 2048, NULL, 5, NULL);\n}\n</code></pre> <p>1.- Make the producer faster: change producer delay 200ms \u2192 20ms. 2.-  When do you see \u201cQueue full\u201d? 3.-  Increase the queue length 5 \u2192 20. 4.-  What changes? 5.-  Make the consumer \u201cslow\u201d: after a successful receive, add: 6.-  What pattern is happening now (buffering / backlog)?</p>"},{"location":"EmbededSystems_II/Homework/#answers_1","title":"answers","text":"<p>1.- Make the producer faster (200ms \u2192 20ms):</p> <p>The producer generates data much faster than the consumer can process it.</p> <p>2.- When do you see \u201cQueue full\u201d?</p> <p>Right now it never appears, but it would appear if the producer fills the queue faster than the consumer removes items from it.</p> <p>3.- Increase the queue length (5 \u2192 20):</p> <p>The queue can store more items before becoming full.</p> <p>4.- What changes?</p> <p>Queue full never appears or takes a lot of time to appear.</p> <p>5.- Make the consumer \u201cslow\u201d:</p> <p>After adding a delay, the consumer processes items more slowly than they are produced.</p> <p>6.- What pattern is happening now (buffering / backlog)?</p> <p>A backlog forms where items accumulate in the queue faster than they are consumed.</p>"},{"location":"EmbededSystems_II/Homework/#lab-3-mutex","title":"Lab 3 Mutex","text":"<p>See a race condition happen with a shared counter, then fix it with a mutex.</p>"},{"location":"EmbededSystems_II/Homework/#code-lab-3-part-a","title":"Code Lab 3 Part A","text":"<p><pre><code>#include &lt;stdio.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"esp_log.h\"\n\nstatic const char *TAG = \"LAB3A\";\n\nstatic volatile int shared_counter = 0;\n\nstatic void increment_task(void *pvParameters)\n{\n    const char *name = (const char *)pvParameters;\n\n    while (1) {\n        // NOT safe: read-modify-write without protection\n        int local = shared_counter;\n        local++;\n        shared_counter = local;\n\n        if ((shared_counter % 1000) == 0) {\n            ESP_LOGI(TAG, \"%s sees counter=%d\", name, shared_counter);\n        }\n\n        vTaskDelay(pdMS_TO_TICKS(1));\n    }\n}\n\nvoid app_main(void)\n{\n    ESP_LOGI(TAG, \"Starting Lab 3A (race demo)\");\n\n    xTaskCreate(increment_task, \"incA\", 2048, \"TaskA\", 5, NULL);\n    xTaskCreate(increment_task, \"incB\", 2048, \"TaskB\", 5, NULL);\n}\n</code></pre> Why can the counter be wrong?</p> <p>Because both tasks access and modify the shared variable at the same time without synchronization, causing race conditions.</p>"},{"location":"EmbededSystems_II/Homework/#code-lab-3-part-b","title":"Code Lab 3 Part B","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/semphr.h\"\n#include \"esp_log.h\"\n\nstatic const char *TAG = \"LAB3B\";\n\nstatic volatile int shared_counter = 0;\nstatic SemaphoreHandle_t counter_mutex;\n\nstatic void increment_task(void *pvParameters)\n{\n    const char *name = (const char *)pvParameters;\n\n    while (1) {\n        xSemaphoreTake(counter_mutex, portMAX_DELAY);\n\n        int local = shared_counter;\n        local++;\n        shared_counter = local;\n\n        xSemaphoreGive(counter_mutex);\n\n        if ((shared_counter % 1000) == 0) {\n            ESP_LOGI(TAG, \"%s sees counter=%d\", name, shared_counter);\n        }\n\n        vTaskDelay(pdMS_TO_TICKS(1));\n    }\n}\n\nvoid app_main(void)\n{\n    ESP_LOGI(TAG, \"Starting Lab 3B (mutex fix)\");\n\n    counter_mutex = xSemaphoreCreateMutex();\n    if (counter_mutex == NULL) {\n        ESP_LOGE(TAG, \"Mutex create failed\");\n        return;\n    }\n\n    xTaskCreate(increment_task, \"incA\", 2048, \"TaskA\", 5, NULL);\n    xTaskCreate(increment_task, \"incB\", 2048, \"TaskB\", 5, NULL);\n}\n</code></pre> <p>1.- Remove the mutex again. Do you ever see weird behavior? 2.- Change priorities: TaskA priority 6, TaskB priority 4. 3.- What do you expect and why? 4.- In one sentence: what does a mutex \u201cguarantee\u201d?</p>"},{"location":"EmbededSystems_II/Homework/#answers_2","title":"answers","text":"<p>1.- Remove the mutex again. Do you ever see weird behavior?</p> <p>Yes, the counter sometimes skips or repeats values due to race conditions.</p> <p>2.- Change priorities (TaskA = 6, TaskB = 4):</p> <p>TaskA runs more often because it has higher priority.</p> <p>3.- What do you expect and why?</p> <p>TaskA increments the counter more frequently since the scheduler favors higher-priority tasks.</p> <p>4.- In one sentence: what does a mutex \u201cguarantee\u201d?</p> <p>A mutex guarantees exclusive access to a shared variable so only one task can use it at a time.</p>"},{"location":"EmbededSystems_II/Homework/#task-excercise","title":"Task Excercise","text":""},{"location":"EmbededSystems_II/Homework/#goal","title":"Goal","text":"<p>Use the task\u00b4s learned commands to create a program that uses 7 different tasks</p>"},{"location":"EmbededSystems_II/Homework/#what-to-watch-for_1","title":"What to watch for","text":"<p>-Task 1: Heartbeat</p> <p>-Task 2: Alive task</p> <p>-Task 3: Queue Struct Send</p> <p>-Task 4: Queue Struct Receive</p> <p>-Task 5 and 6: Mutex reading a button</p> <p>-Task 7: Error loggin for task 1-6</p>"},{"location":"EmbededSystems_II/Homework/#code","title":"Code","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/queue.h\"\n#include \"freertos/semphr.h\"\n#include \"driver/gpio.h\"\n#include \"esp_log.h\"\n\n#define LED_GPIO GPIO_NUM_20\n#define BUTTON   GPIO_NUM_21 \n\nstatic const char *TAG = \"LAB1\";\n\nstatic SemaphoreHandle_t btn_mutex = NULL;\nstatic uint32_t task_counters[6] = {0};\n\ntypedef struct {\n    char id[20];\n    int value;\n} DataMessage;\n\nQueueHandle_t structQueue;\n\nstatic void blink_task(void *pvParameters)\n{\n    gpio_reset_pin(LED_GPIO);\n    gpio_set_direction(LED_GPIO, GPIO_MODE_OUTPUT);\n\n    while (1) {\n        task_counters[0]++;\n\n        gpio_set_level(LED_GPIO, 1);\n        vTaskDelay(pdMS_TO_TICKS(150));\n        gpio_set_level(LED_GPIO, 0);\n        vTaskDelay(pdMS_TO_TICKS(150));\n        gpio_set_level(LED_GPIO, 1);\n        vTaskDelay(pdMS_TO_TICKS(150));\n        gpio_set_level(LED_GPIO, 0);\n        vTaskDelay(pdMS_TO_TICKS(150));\n        vTaskDelay(pdMS_TO_TICKS(500));\n    }\n}\n\nstatic void Live(void *pvParameters)\n{\n    while (1) {\n        task_counters[1]++;\n        ESP_LOGI(TAG, \"The pacient is alive (BPM=95)\");\n        vTaskDelay(pdMS_TO_TICKS(2000));\n    }\n}\n\nstatic void sender_task(void *pvParameters)\n{\n    DataMessage myData;\n    strcpy(myData.id, \"CHARLY\");\n    int count = 0;\n\n    while (1) {\n        task_counters[2]++;\n        myData.value = count;\n\n        if (xQueueSend(structQueue, &amp;myData, pdMS_TO_TICKS(100)) == pdPASS) {\n\n        }\n\n        count++;\n        vTaskDelay(pdMS_TO_TICKS(1000)); \n    }\n}\n\nstatic void receiver_task(void *pvParameters)\n{\n    DataMessage receivedData;\n\n    while (1) {\n        task_counters[3]++;\n\n        if (xQueueReceive(structQueue, &amp;receivedData, portMAX_DELAY) == pdTRUE) {\n            ESP_LOGI(TAG, \"QUEUE RECIEVED, PATIENT: %s, VALUE: %d\", receivedData.id, receivedData.value);\n        }\n    }\n}\n\nstatic void mutex_button_task(void *pvParameters) {\n    int task_idx = (int)pvParameters; \n    const char* message = (task_idx == 4) ? \"I hate charly\" : \"I hate Javi\";\n\n    while (1) {\n        task_counters[task_idx]++;\n\n        if (xSemaphoreTake(btn_mutex, portMAX_DELAY) == pdTRUE) {\n\n            if (gpio_get_level(BUTTON) == 0) {\n                 ESP_LOGI(TAG, \"%s\", message);\n                 vTaskDelay(pdMS_TO_TICKS(200)); \n            }\n\n            xSemaphoreGive(btn_mutex); \n        }\n        vTaskDelay(pdMS_TO_TICKS(100));\n    }\n}\n\nstatic void monitor_task(void *pvParameters) {\n    uint32_t last_counters[6] = {0};\n\n    while (1) {\n        vTaskDelay(pdMS_TO_TICKS(5000));\n\n        for (int i = 0; i &lt; 6; i++) {\n            if (task_counters[i] == last_counters[i]) {\n                ESP_LOGE(\"MONITOR\", \"ERROR: Tarea %d detenida\", i);\n            } else {\n                last_counters[i] = task_counters[i];\n            }\n        }\n    }\n}\n\nvoid app_main(void)\n{\n    ESP_LOGI(TAG, \"Starting Lab 1\");\n\n    gpio_reset_pin(BUTTON);\n    gpio_set_direction(BUTTON, GPIO_MODE_INPUT);\n    gpio_pullup_en(BUTTON);\n\n    structQueue = xQueueCreate(10, sizeof(DataMessage));\n    btn_mutex = xSemaphoreCreateMutex();\n\n    if (structQueue == NULL || btn_mutex == NULL) {\n        ESP_LOGE(TAG, \"Error creating Queue or Mutex\");\n        return;\n    }\n\n    xTaskCreate(blink_task, \"blink_task\", 2048, NULL, 5, NULL);\n    xTaskCreate(Live, \"Live\", 2048, NULL, 5, NULL);\n    xTaskCreate(sender_task, \"sender\", 2048, NULL, 5, NULL);\n    xTaskCreate(receiver_task, \"receiver\", 2048, NULL, 5, NULL);\n    xTaskCreate(mutex_button_task, \"BtnCharly\", 2048, (void*)4, 5, NULL);\n    xTaskCreate(mutex_button_task, \"BtnJavi\", 2048, (void*)5, 5, NULL);\n    xTaskCreate(monitor_task, \"Monitor\", 2048, NULL, 6, NULL);\n}\n</code></pre>"},{"location":"EmbededSystems_II/Homework/#evidence","title":"Evidence","text":""},{"location":"EmbededSystems_II/Homework/#assignment-4-browser","title":"Assignment 4: Browser","text":""},{"location":"EmbededSystems_II/Homework/#instructions","title":"Instructions","text":"<p>A running system where:</p> <p>Phone/PC opens http:/// and sees a webpage <ul> <li>Webpage can turn LED ON/OFF</li> <li>API works:</li> <li>GET /api/led \u2192 {\"state\":0|1}</li> <li>POST /api/led with {\"state\":0|1} \u2192 {\"ok\":true}</li> </ul> <p>With this base wee need to document the codes to:</p> <ul> <li>turn2 leds from a browser</li> <li>read a button and print it to the browser</li> <li>control the speed of a motor with a slider from the browser</li> </ul> <p>Also answer the questions from the labs of HTTP.</p>"},{"location":"EmbededSystems_II/Homework/#excercise-1-code","title":"Excercise 1 code:","text":"<pre><code>/*\n * LAB 3 \u2014 ESP32-C6 Wi-Fi + HTTP LED Control \n *\n * Features:\n *  - Wi-Fi STA connect + reconnect using events\n *  - Wait for IP (WIFI_CONNECTED_BIT)\n *  - Simple GPIO LED control (gpio_reset_pin + gpio_set_direction)\n *  - HTTP server:\n *      GET  /         -&gt; HTML UI\n *      GET  /api/led  -&gt; JSON {\"state\":0|1}\n *      POST /api/led  -&gt; JSON {\"state\":0|1} sets LED, returns {\"ok\":true}\n *\n */\n// String handling and standard libraries\n#include &lt;string.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n// FreeRTOS and event groups\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/event_groups.h\"\n// ESP-IDF Logging and error handling\n#include \"esp_log.h\"\n#include \"esp_err.h\"\n// Wi-Fi and network\n#include \"nvs_flash.h\"\n#include \"esp_netif.h\"\n#include \"esp_event.h\"\n#include \"esp_wifi.h\"\n// GPIO control\n#include \"driver/gpio.h\"\n// HTTP server\n#include \"esp_http_server.h\"\n\n/* ===================== User config ===================== */\n#define WIFI_SSID \"OPPO Reno7 5G\"\n#define WIFI_PASS \"Ar1356673\"\n\n/* LED pin */\n#define LED_GPIO  21\n#define LED2_GPIO 20\n#define BUTTON 22\n/* Reconnect policy */\n#define MAX_RETRY 10\n\n/* ===================== Globals ===================== */\nstatic const char *TAG = \"LAB_3\";\n\n// Wi-Fi event group and bit seen in Lab 2\nstatic EventGroupHandle_t s_wifi_event_group;\n#define WIFI_CONNECTED_BIT BIT0\n\n\nstatic int s_retry = 0;// Retry count for Wi-Fi reconnects\n\nstatic int s_led_state = 0;               // 0=OFF, 1=ON\nstatic int s_led2_state = 0;\nstatic int button_state = 0;\nstatic httpd_handle_t s_server = NULL;    // HTTP server handle\n\n/* ===================== LED helpers ===================== */\nstatic void led_init(void)\n{\n    gpio_reset_pin(LED_GPIO);\n    gpio_reset_pin(LED2_GPIO);\n    gpio_set_direction(LED_GPIO, GPIO_MODE_OUTPUT);\n    gpio_set_direction(LED2_GPIO, GPIO_MODE_OUTPUT);\n    s_led_state = 0;\n    s_led2_state = 0;\n    gpio_set_level(LED_GPIO, s_led_state);\n    gpio_set_level(LED2_GPIO, s_led2_state);\n\n    ESP_LOGI(TAG, \"LED initialized on GPIO %d (state=%d)\", LED_GPIO, s_led_state);\n    ESP_LOGI(TAG, \"LED2 initialized on GPIO %d (state=%d)\", LED2_GPIO, s_led2_state);\n}\n\n/*Function to set the LED from the state*/\nstatic void led_set(int on)\n{\n    s_led_state = (on != 0);\n    gpio_set_level(LED_GPIO, s_led_state);\n    ESP_LOGI(TAG, \"LED set to %d\", s_led_state);\n}\n\nstatic void led2_set(int on)\n{\n    s_led2_state = (on != 0);\n    gpio_set_level(LED2_GPIO, s_led2_state);\n    ESP_LOGI(TAG, \"LED2 set to %d\", s_led2_state);\n}\n\nstatic void button_init(int on){\n    gpio_set_level(BUTTON) ;\n    gpio_set_direction(BUTTON,GPIO_MODE_INPUT);\n    gpio_pullup_en(BUTTON);\n}\nstatic int button_read(){\n    return gpio_get_level(BUTTON)\n}\n\n/* ===================== HTTP handlers ===================== */\n/*Remember, handlers are special functions that process HTTP requests and generate responses*/\n\n\nstatic esp_err_t api_led_get(httpd_req_t *req)\n{\n    /* resp is a buffer to hold the JSON response  text in this case our jason is\n       either {\"state\":0} or {\"state\":1} */\n    char resp[32];\n    /*sprintf is a normal printf for strings, snprintf is safer because it \n    limits the number of characters written to the buffer\n\n    Here we build the JSON string with the current LED state. \n    */\n    snprintf(resp, sizeof(resp), \"{\\\"state\\\":%d}\", s_led_state);\n\n    /* Tell the client (browser/Postman/etc.) that the payload is JSON.\n       This sets the HTTP header: Content-Type: application/json */\n    httpd_resp_set_type(req, \"application/json\");\n\n    /* Send the response body to the client.\n       - 'resp' is the payload\n       - HTTPD_RESP_USE_STRLEN tells ESP-IDF to compute the string length automatically\n         (it treats resp as a null-terminated C string). */\n    httpd_resp_send(req, resp, HTTPD_RESP_USE_STRLEN);\n\n    /* Return ESP_OK so the HTTP server knows the request was handled correctly. */\n    return ESP_OK;\n}\n\nstatic esp_err_t api_led_post(httpd_req_t *req)\n{\n    // Basic safety: reject empty or very large payloads\n    if (req-&gt;content_len &lt;= 0 || req-&gt;content_len &gt; 256) {\n        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, \"Invalid Content-Length\");\n        return ESP_FAIL;\n    }\n\n    char buf[257] = {0}; // +1 for null terminator\n    int received = httpd_req_recv(req, buf, req-&gt;content_len);\n    if (received &lt;= 0) {\n        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, \"Empty body\");\n        return ESP_FAIL;\n    }\n    buf[received] = '\\0';\n\n    // Minimal parse: find \"state\":&lt;number&gt;\n    int state = -1;\n    char *p = strstr(buf, \"\\\"state\\\"\");\n    if (p) {\n        p = strchr(p, ':');\n        if (p) state = atoi(p + 1);\n    }\n\n    if (state != 0 &amp;&amp; state != 1) {\n        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, \"state must be 0 or 1\");\n        return ESP_FAIL;\n    }\n\n    led_set(state);\n    led2_set(state);\n    httpd_resp_set_type(req, \"application/json\");\n    httpd_resp_sendstr(req, \"{\\\"ok\\\":true}\");\n    return ESP_OK;\n}\n\nstatic esp_err_t root_get_handler(httpd_req_t *req)\n{\n    // Readable inline HTML\n    static const char *INDEX_HTML =\n        \"&lt;!doctype html&gt;\\n\"\n        \"&lt;html&gt;\\n\"\n        \"&lt;head&gt;\\n\"\n        \"  &lt;meta charset='utf-8'&gt;\\n\"\n        \"  &lt;meta name='viewport' content='width=device-width, initial-scale=1'&gt;\\n\"\n        \"  &lt;title&gt;ESP32-C6 LED&lt;/title&gt;\\n\"\n        \"&lt;/head&gt;\\n\"\n        \"&lt;body&gt;\\n\"\n        \"  &lt;h2&gt;ESP32-C6 LED Control&lt;/h2&gt;\\n\"\n        \"  &lt;button onclick='setLed(1)'&gt;ON&lt;/button&gt;\\n\"\n        \"  &lt;button onclick='setLed(0)'&gt;OFF&lt;/button&gt;\\n\"\n        \"  &lt;button onclick='setLed2(1)'&gt;ON&lt;/button&gt;\\n\"\n        \"  &lt;button onclick='setLed2(0)'&gt;OFF&lt;/button&gt;\\n\"\n        \"  &lt;p id='st'&gt;State: ?&lt;/p&gt;\\n\"\n        \"\\n\"\n        \"  &lt;script&gt;\\n\"\n        \"    async function refresh(){\\n\"\n        \"      const r = await fetch('/api/led');\\n\"\n        \"      const j = await r.json();\\n\"\n        \"      document.getElementById('st').innerText = 'State: ' + j.state;\\n\"\n        \"    }\\n\"\n        \"    async function setLed(v){\\n\"\n        \"      await fetch('/api/led', {\\n\"\n        \"        method: 'POST',\\n\"\n        \"        headers: {'Content-Type':'application/json'},\\n\"\n        \"        body: JSON.stringify({state:v})\\n\"\n        \"      });\\n\"\n        \"      refresh();\\n\"\n        \"    }\\n\"\n        \"    setInterval(refresh, 1000);\\n\"\n        \"    refresh();\\n\"\n        \"  &lt;/script&gt;\\n\"\n        \"&lt;/body&gt;\\n\"\n        \"&lt;/html&gt;\\n\";\n\n    httpd_resp_set_type(req, \"text/html\");\n    httpd_resp_send(req, INDEX_HTML, HTTPD_RESP_USE_STRLEN);\n    return ESP_OK;\n}\n\nstatic void http_server_start(void)\n{\n    httpd_config_t config = HTTPD_DEFAULT_CONFIG();\n    ESP_ERROR_CHECK(httpd_start(&amp;s_server, &amp;config));\n    ESP_LOGI(TAG, \"HTTP server started\");\n\n    httpd_uri_t root = {\n        .uri      = \"/\",\n        .method   = HTTP_GET,\n        .handler  = root_get_handler,\n        .user_ctx = NULL\n    };\n\n    httpd_uri_t led_get = {\n        .uri      = \"/api/led\",\n        .method   = HTTP_GET,\n        .handler  = api_led_get,\n        .user_ctx = NULL\n    };\n\n    httpd_uri_t led_post = {\n        .uri      = \"/api/led\",\n        .method   = HTTP_POST,\n        .handler  = api_led_post,\n        .user_ctx = NULL\n    };\n\n    ESP_ERROR_CHECK(httpd_register_uri_handler(s_server, &amp;root));\n    ESP_ERROR_CHECK(httpd_register_uri_handler(s_server, &amp;led_get));\n    ESP_ERROR_CHECK(httpd_register_uri_handler(s_server, &amp;led_post));\n\n    ESP_LOGI(TAG, \"Routes registered: /  ,  GET/POST /api/led\");\n}\n\n/* ===================== Wi-Fi STA connect + events ===================== */\n\nstatic void wifi_event_handler(void *arg,\n                               esp_event_base_t event_base,\n                               int32_t event_id,\n                               void *event_data)\n{\n    if (event_base == WIFI_EVENT &amp;&amp; event_id == WIFI_EVENT_STA_START) {\n        ESP_LOGI(TAG, \"WIFI_EVENT_STA_START -&gt; esp_wifi_connect()\");\n        ESP_ERROR_CHECK(esp_wifi_connect());\n        return;\n    }\n\n    if (event_base == WIFI_EVENT &amp;&amp; event_id == WIFI_EVENT_STA_DISCONNECTED) {\n        if (s_retry &lt; MAX_RETRY) {\n            s_retry++;\n            ESP_LOGW(TAG, \"Disconnected. Retrying (%d/%d)...\", s_retry, MAX_RETRY);\n            ESP_ERROR_CHECK(esp_wifi_connect());\n        } else {\n            ESP_LOGE(TAG, \"Failed to connect after %d retries.\", MAX_RETRY);\n        }\n        return;\n    }\n\n    if (event_base == IP_EVENT &amp;&amp; event_id == IP_EVENT_STA_GOT_IP) {\n        ip_event_got_ip_t *event = (ip_event_got_ip_t *)event_data;\n        ESP_LOGI(TAG, \"Got IP: \" IPSTR, IP2STR(&amp;event-&gt;ip_info.ip));\n\n        s_retry = 0;\n        xEventGroupSetBits(s_wifi_event_group, WIFI_CONNECTED_BIT);\n        return;\n    }\n}\n\nstatic void wifi_init_sta(void)\n{\n    s_wifi_event_group = xEventGroupCreate();\n\n    ESP_ERROR_CHECK(esp_netif_init());\n    ESP_ERROR_CHECK(esp_event_loop_create_default());\n    esp_netif_create_default_wifi_sta();\n\n    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();\n    ESP_ERROR_CHECK(esp_wifi_init(&amp;cfg));\n\n    ESP_ERROR_CHECK(esp_event_handler_register(WIFI_EVENT, ESP_EVENT_ANY_ID, &amp;wifi_event_handler, NULL));\n    ESP_ERROR_CHECK(esp_event_handler_register(IP_EVENT, IP_EVENT_STA_GOT_IP, &amp;wifi_event_handler, NULL));\n\n    wifi_config_t wifi_config = {0};\n    strncpy((char *)wifi_config.sta.ssid, WIFI_SSID, sizeof(wifi_config.sta.ssid));\n    strncpy((char *)wifi_config.sta.password, WIFI_PASS, sizeof(wifi_config.sta.password));\n\n    ESP_LOGI(TAG, \"Configuring Wi-Fi STA: SSID='%s'\", WIFI_SSID);\n\n    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));\n    ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_STA, &amp;wifi_config));\n    ESP_ERROR_CHECK(esp_wifi_start());\n}\n\n/* ===================== app_main ===================== */\n\nvoid app_main(void)\n{\n    ESP_LOGI(TAG, \"Lab D start: Wi-Fi + HTTP + LED control.\");\n\n    // NVS init (required by Wi-Fi)\n    esp_err_t ret = nvs_flash_init();\n    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {\n        ESP_ERROR_CHECK(nvs_flash_erase());\n        ESP_ERROR_CHECK(nvs_flash_init());\n    } else {\n        ESP_ERROR_CHECK(ret);\n    }\n\n    // Connect to Wi-Fi (STA)\n    wifi_init_sta();\n\n    // Wait for \"got IP\" (connected)\n    EventBits_t bits = xEventGroupWaitBits(\n        s_wifi_event_group,\n        WIFI_CONNECTED_BIT,\n        pdFALSE,\n        pdTRUE,\n        pdMS_TO_TICKS(30000)\n    );\n\n    if (!(bits &amp; WIFI_CONNECTED_BIT)) {\n        ESP_LOGE(TAG, \"Timeout waiting for Wi-Fi connection. Check SSID/PASS and 2.4 GHz.\");\n        return;\n    }\n\n    // Start peripherals + HTTP\n    led_init();\n    http_server_start();\n\n    ESP_LOGI(TAG, \"Open: http://&lt;ESP_IP&gt;/ from a device on the same network.\");\n}\n</code></pre>"},{"location":"EmbededSystems_II/Homework/#video","title":"Video","text":""},{"location":"EmbededSystems_II/Homework/#excercise-2-code","title":"Excercise 2 code:","text":"<pre><code>/*\n * LAB 3 \u2014 ESP32-C6 Wi-Fi + HTTP LED Control \n */\n\n#include &lt;string.h&gt;\n#include &lt;stdio.h&gt;\n\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/event_groups.h\"\n\n#include \"esp_log.h\"\n#include \"esp_err.h\"\n\n#include \"nvs_flash.h\"\n#include \"esp_netif.h\"\n#include \"esp_event.h\"\n#include \"esp_wifi.h\"\n\n#include \"driver/gpio.h\"\n#include \"esp_http_server.h\"\n\n/* ===================== User config ===================== */\n/*\n * LAB 3 \u2014 ESP32-C6 Wi-Fi + HTTP LED Control \n */\n\n#include &lt;string.h&gt;\n#include &lt;stdio.h&gt;\n\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/event_groups.h\"\n\n#include \"esp_log.h\"\n#include \"esp_err.h\"\n\n#include \"nvs_flash.h\"\n#include \"esp_netif.h\"\n#include \"esp_event.h\"\n#include \"esp_wifi.h\"\n\n#include \"driver/gpio.h\"\n#include \"esp_http_server.h\"\n\n/* ===================== User config ===================== */\n#define WIFI_SSID \"OPPO Reno7 5G\"\n#define WIFI_PASS \"Ar1356673\"\n\n#define LED1_GPIO  21\n#define LED2_GPIO  20\n#define BUTTON     22   \n#define MAX_RETRY 10\n\n// Pines puente H TB6612\n#define PWMA   0   \n#define AIN1   1   \n#define AIN2   2   \n#define STBY   3   \n\n#define F_PWM_HZ 2000   \n#define TOP 1023       \n/* ===================== Globals ===================== */\nstatic const char *TAG = \"LAB_3\";\n\nstatic EventGroupHandle_t s_wifi_event_group;\n#define WIFI_CONNECTED_BIT BIT0\n\nstatic int s_retry = 0;\nstatic int s_led_state1 = 0;            // 0=OFF, 1=ON\nstatic int s_led_state2 = 0;            // 0=OFF, 1=ON\nstatic int button_state = 0;            // 0=not pressed, 1=pressed\nstatic httpd_handle_t s_server = NULL;\n\n/* ===================== LED helpers ===================== */\nstatic void led_init(void)\n{\n    gpio_reset_pin(LED1_GPIO);\n    gpio_set_direction(LED1_GPIO, GPIO_MODE_OUTPUT);\n    gpio_reset_pin(LED2_GPIO);\n    gpio_set_direction(LED2_GPIO, GPIO_MODE_OUTPUT);\n\n    s_led_state1 = 0;\n    s_led_state2 = 0;\n    gpio_set_level(LED1_GPIO, s_led_state1);\n    gpio_set_level(LED2_GPIO, s_led_state2);\n\n    ESP_LOGI(TAG, \"LEDs initialized on GPIO %d and %d (state=%d)\", LED1_GPIO, LED2_GPIO, s_led_state1);\n}\n\n\nstatic void led_set1(int on)\n{\n    s_led_state1 = (on != 0);\n    gpio_set_level(LED1_GPIO, s_led_state1);\n}\n\nstatic void led_set2(int on)\n{\n    s_led_state2 = (on != 0);\n    gpio_set_level(LED2_GPIO, s_led_state2);\n}\n\nstatic void button_init(void)\n{\n    gpio_reset_pin(BUTTON);\n    gpio_set_direction(BUTTON, GPIO_MODE_INPUT);\n    gpio_pullup_en(BUTTON);\n}\nstatic int button_read(void)\n{\n    return gpio_get_level(BUTTON);\n}\n/* ===================== HTTP Handlers ===================== */\n\n\nstatic esp_err_t root_get_handler(httpd_req_t *req)\n{\n    char response[2048];\n\n    // Read REAL GPIO button\n    int level = button_read();\n\n    // If using pull-up: pressed = 0\n    const char *state_str = (level == 0) ? \"RELEASED\" : \"PRESSED\";\n\n    snprintf(response, sizeof(response),\n        \"&lt;!doctype html&gt;\\n\"\n        \"&lt;html&gt;&lt;head&gt;\\n\"\n        \"  &lt;meta charset='utf-8'&gt;\\n\"\n        \"  &lt;meta name='viewport' content='width=device-width, initial-scale=1'&gt;\\n\"\n        \"  &lt;meta http-equiv='refresh' content='1'&gt;\\n\"\n        \"  &lt;title&gt;ESP32-C6 LED&lt;/title&gt;\\n\"\n        \"&lt;/head&gt;&lt;body&gt;\\n\"\n        \"  &lt;h2&gt;ESP32-C6 LED Control (GET-only)&lt;/h2&gt;\\n\"\n        \"  &lt;p&gt;Use the buttons below to send HTTP GET requests to the ESP32.&lt;/p&gt;\\n\"\n        \"  &lt;p&gt;\\n\"\n        \"    &lt;a href='/ledon1'&gt;&lt;button&gt;LED1 ON&lt;/button&gt;&lt;/a&gt;\\n\"\n        \"    &lt;a href='/ledoff1'&gt;&lt;button&gt;LED1 OFF&lt;/button&gt;&lt;/a&gt;\\n\"\n        \"  &lt;/p&gt;\\n\"\n        \"  &lt;p&gt;\\n\"\n        \"    &lt;a href='/ledon2'&gt;&lt;button&gt;LED2 ON&lt;/button&gt;&lt;/a&gt;\\n\"\n        \"    &lt;a href='/ledoff2'&gt;&lt;button&gt;LED2 OFF&lt;/button&gt;&lt;/a&gt;\\n\"\n        \"  &lt;/p&gt;\\n\"\n        \"  &lt;p&gt;\\n\"\n        \"    &lt;strong&gt;External Button STATE:&lt;/strong&gt; %s\\n\"\n        \"  &lt;/p&gt;\\n\"\n        \"  &lt;p&gt;Direct URLs:&lt;/p&gt;\\n\"\n        \"  &lt;ul&gt;\\n\"\n        \"    &lt;li&gt;&lt;code&gt;/ledon1&lt;/code&gt;&lt;/li&gt;\\n\"\n        \"    &lt;li&gt;&lt;code&gt;/ledoff1&lt;/code&gt;&lt;/li&gt;\\n\"\n        \"    &lt;li&gt;&lt;code&gt;/ledon2&lt;/code&gt;&lt;/li&gt;\\n\"\n        \"    &lt;li&gt;&lt;code&gt;/ledoff2&lt;/code&gt;&lt;/li&gt;\\n\"\n        \"  &lt;/ul&gt;\\n\"\n        \"&lt;/body&gt;&lt;/html&gt;\\n\",\n        state_str\n    );\n\n    httpd_resp_set_type(req, \"text/html\");\n    httpd_resp_send(req, response, HTTPD_RESP_USE_STRLEN);\n\n    return ESP_OK;\n}\n\n\nstatic esp_err_t ledon_get_handler1(httpd_req_t *req)\n{\n    // Application logic: turn LED ON\n    led_set1(1);\n\n    // Response: simple HTML confirmation page\n    static const char *RESP =\n        \"&lt;!doctype html&gt;&lt;html&gt;&lt;body&gt;\"\n        \"&lt;h3&gt;LED is now: ON&lt;/h3&gt;\"\n        \"&lt;p&gt;&lt;a href='/'&gt;&lt;button&gt;Back&lt;/button&gt;&lt;/a&gt;&lt;/p&gt;\"\n        \"&lt;/body&gt;&lt;/html&gt;\";\n\n    httpd_resp_set_type(req, \"text/html\");\n    httpd_resp_send(req, RESP, HTTPD_RESP_USE_STRLEN);\n    return ESP_OK;\n}\n\nstatic esp_err_t ledon_get_handler2(httpd_req_t *req)\n{\n    // Application logic: turn LED ON\n    led_set2(1);\n    // Response: simple HTML confirmation page\n    static const char *RESP =\n        \"&lt;!doctype html&gt;&lt;html&gt;&lt;body&gt;\"\n        \"&lt;h3&gt;LED is now: ON&lt;/h3&gt;\"\n        \"&lt;p&gt;&lt;a href='/'&gt;&lt;button&gt;Back&lt;/button&gt;&lt;/a&gt;&lt;/p&gt;\"\n        \"&lt;/body&gt;&lt;/html&gt;\";\n\n    httpd_resp_set_type(req, \"text/html\");\n    httpd_resp_send(req, RESP, HTTPD_RESP_USE_STRLEN);\n    return ESP_OK;\n}\n\nstatic esp_err_t ledoff_get_handler1(httpd_req_t *req)\n{\n    // Application logic: turn LED OFF\n    led_set1(0);\n    // Response: simple HTML confirmation page\n    static const char *RESP =\n        \"&lt;!doctype html&gt;&lt;html&gt;&lt;body&gt;\"\n        \"&lt;h3&gt;LED is now: OFF&lt;/h3&gt;\"\n        \"&lt;p&gt;&lt;a href='/'&gt;&lt;button&gt;Back&lt;/button&gt;&lt;/a&gt;&lt;/p&gt;\"\n        \"&lt;/body&gt;&lt;/html&gt;\";\n\n    httpd_resp_set_type(req, \"text/html\");\n    httpd_resp_send(req, RESP, HTTPD_RESP_USE_STRLEN);\n    return ESP_OK;\n}\n\nstatic esp_err_t ledoff_get_handler2(httpd_req_t *req)\n{\n    // Application logic: turn LED OFF\n    led_set2(0);\n\n    // Response: simple HTML confirmation page\n    static const char *RESP =\n        \"&lt;!doctype html&gt;&lt;html&gt;&lt;body&gt;\"\n        \"&lt;h3&gt;LED is now: OFF&lt;/h3&gt;\"\n        \"&lt;p&gt;&lt;a href='/'&gt;&lt;button&gt;Back&lt;/button&gt;&lt;/a&gt;&lt;/p&gt;\"\n        \"&lt;/body&gt;&lt;/html&gt;\";\n\n    httpd_resp_set_type(req, \"text/html\");\n    httpd_resp_send(req, RESP, HTTPD_RESP_USE_STRLEN);\n    return ESP_OK;\n}\n\nstatic esp_err_t button_1_get_handler(httpd_req_t *req)\n{\n    button_state = 1;\n    // Response: simple HTML confirmation page\n    static const char *RESP =\n        \"&lt;!doctype html&gt;&lt;html&gt;&lt;body&gt;\"\n        \"&lt;h3&gt;BUTTON is now: PRESSED&lt;/h3&gt;\"\n        \"&lt;p&gt;&lt;a href='/'&gt;&lt;button&gt;Back&lt;/button&gt;&lt;/a&gt;&lt;/p&gt;\"\n        \"&lt;/body&gt;&lt;/html&gt;\";\n\n    httpd_resp_set_type(req, \"text/html\");\n    httpd_resp_send(req, RESP, HTTPD_RESP_USE_STRLEN);\n    return ESP_OK;\n}\n\nstatic esp_err_t button_0_get_handler(httpd_req_t *req)\n{\n    button_state = 0;\n    // Response: simple HTML confirmation page\n    static const char *RESP =\n        \"&lt;!doctype html&gt;&lt;html&gt;&lt;body&gt;\"\n        \"&lt;h3&gt;BUTTON is now: RELEASED&lt;/h3&gt;\"\n        \"&lt;p&gt;&lt;a href='/'&gt;&lt;button&gt;Back&lt;/button&gt;&lt;/a&gt;&lt;/p&gt;\"\n        \"&lt;/body&gt;&lt;/html&gt;\";\n\n    httpd_resp_set_type(req, \"text/html\");\n    httpd_resp_send(req, RESP, HTTPD_RESP_USE_STRLEN);\n    return ESP_OK;\n}\n\n/* ===================== HTTP Server Start + Route Registration ===================== */\n\nstatic void http_server_start(void)\n{\n    httpd_config_t config = HTTPD_DEFAULT_CONFIG();\n    ESP_ERROR_CHECK(httpd_start(&amp;s_server, &amp;config));\n    ESP_LOGI(TAG, \"HTTP server started (port %d)\", config.server_port);\n\n    httpd_uri_t root = {\n        .uri      = \"/\",\n        .method   = HTTP_GET,\n        .handler  = root_get_handler,\n        .user_ctx = NULL\n    };\n\n    httpd_uri_t ledon1 = {\n        .uri      = \"/ledon1\",\n        .method   = HTTP_GET,\n        .handler  = ledon_get_handler1,\n        .user_ctx = NULL\n    };\n\n        httpd_uri_t ledon2 = {\n        .uri      = \"/ledon2\",\n        .method   = HTTP_GET,\n        .handler  = ledon_get_handler2,\n        .user_ctx = NULL\n    };\n\n    httpd_uri_t ledoff1 = {\n        .uri      = \"/ledoff1\",\n        .method   = HTTP_GET,\n        .handler  = ledoff_get_handler1,\n        .user_ctx = NULL\n    };\n\n    httpd_uri_t ledoff2 = {\n        .uri      = \"/ledoff2\",\n        .method   = HTTP_GET,\n        .handler  = ledoff_get_handler2,\n        .user_ctx = NULL\n    };\n\n    httpd_uri_t button_1 = {\n        .uri      = \"/button_1\",\n        .method   = HTTP_GET,\n        .handler  = button_1_get_handler,\n        .user_ctx = NULL\n    };\n\n    httpd_uri_t button_0 = {\n        .uri      = \"/button_0\",\n        .method   = HTTP_GET,\n        .handler  = button_0_get_handler,\n        .user_ctx = NULL\n    };\n\n    ESP_ERROR_CHECK(httpd_register_uri_handler(s_server, &amp;root));\n    ESP_ERROR_CHECK(httpd_register_uri_handler(s_server, &amp;ledon1));\n    ESP_ERROR_CHECK(httpd_register_uri_handler(s_server, &amp;ledoff1));\n    ESP_ERROR_CHECK(httpd_register_uri_handler(s_server, &amp;ledon2));\n    ESP_ERROR_CHECK(httpd_register_uri_handler(s_server, &amp;ledoff2));\n    ESP_ERROR_CHECK(httpd_register_uri_handler(s_server, &amp;button_1));\n    ESP_ERROR_CHECK(httpd_register_uri_handler(s_server, &amp;button_0));\n\n    ESP_LOGI(TAG, \"Routes: GET /, GET /ledon1, GET /ledoff1, GET /ledon2, GET /ledoff2, GET /button_1, GET /button_0\");\n}\n\n/* ===================== Wi-Fi STA connect + events ===================== */\n\nstatic void wifi_event_handler(void *arg,\n                               esp_event_base_t event_base,\n                               int32_t event_id,\n                               void *event_data)\n{\n    if (event_base == WIFI_EVENT &amp;&amp; event_id == WIFI_EVENT_STA_START) {\n        ESP_LOGI(TAG, \"WIFI_EVENT_STA_START -&gt; connecting...\");\n        ESP_ERROR_CHECK(esp_wifi_connect());\n        return;\n    }\n\n    if (event_base == WIFI_EVENT &amp;&amp; event_id == WIFI_EVENT_STA_DISCONNECTED) {\n        if (s_retry &lt; MAX_RETRY) {\n            s_retry++;\n            ESP_LOGW(TAG, \"Disconnected. Retrying (%d/%d)...\", s_retry, MAX_RETRY);\n            ESP_ERROR_CHECK(esp_wifi_connect());\n        } else {\n            ESP_LOGE(TAG, \"Failed to connect after %d retries.\", MAX_RETRY);\n        }\n        return;\n    }\n\n    if (event_base == IP_EVENT &amp;&amp; event_id == IP_EVENT_STA_GOT_IP) {\n        ip_event_got_ip_t *event = (ip_event_got_ip_t *)event_data;\n        ESP_LOGI(TAG, \"Got IP: \" IPSTR, IP2STR(&amp;event-&gt;ip_info.ip));\n\n        s_retry = 0;\n        xEventGroupSetBits(s_wifi_event_group, WIFI_CONNECTED_BIT);\n        return;\n    }\n}\n\nstatic void wifi_init_sta(void)\n{\n    s_wifi_event_group = xEventGroupCreate();\n\n    ESP_ERROR_CHECK(esp_netif_init());\n    ESP_ERROR_CHECK(esp_event_loop_create_default());\n    esp_netif_create_default_wifi_sta();\n\n    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();\n    ESP_ERROR_CHECK(esp_wifi_init(&amp;cfg));\n\n    ESP_ERROR_CHECK(esp_event_handler_register(WIFI_EVENT, ESP_EVENT_ANY_ID, &amp;wifi_event_handler, NULL));\n    ESP_ERROR_CHECK(esp_event_handler_register(IP_EVENT, IP_EVENT_STA_GOT_IP, &amp;wifi_event_handler, NULL));\n\n    wifi_config_t wifi_config = {0};\n    strncpy((char *)wifi_config.sta.ssid, WIFI_SSID, sizeof(wifi_config.sta.ssid));\n    strncpy((char *)wifi_config.sta.password, WIFI_PASS, sizeof(wifi_config.sta.password));\n\n    ESP_LOGI(TAG, \"Configuring Wi-Fi STA: SSID='%s'\", WIFI_SSID);\n\n    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));\n    ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_STA, &amp;wifi_config));\n    ESP_ERROR_CHECK(esp_wifi_start());\n}\n\n/* ===================== app_main ===================== */\n\nvoid app_main(void)\n{\n    ESP_LOGI(TAG, \"Lab 3 start: Wi-Fi + HTTP.\");\n\n    // NVS init\n    esp_err_t ret = nvs_flash_init();\n    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {\n        ESP_ERROR_CHECK(nvs_flash_erase());\n        ESP_ERROR_CHECK(nvs_flash_init());\n    } else {\n        ESP_ERROR_CHECK(ret);\n    }\n\n    wifi_init_sta();\n\n    // Wait for IP\n    EventBits_t bits = xEventGroupWaitBits(\n        s_wifi_event_group,\n        WIFI_CONNECTED_BIT,\n        pdFALSE,\n        pdTRUE,\n        pdMS_TO_TICKS(30000)\n    );\n\n    if (!(bits &amp; WIFI_CONNECTED_BIT)) {\n        ESP_LOGE(TAG, \"Timeout waiting for Wi-Fi connection. Check SSID/PASS and 2.4 GHz.\");\n        return;\n    }\n\n    led_init();\n    http_server_start();\n\n    ESP_LOGI(TAG, \"Open: http://&lt;ESP_IP&gt;/ \");\n    ESP_LOGI(TAG, \"Direct control: http://&lt;ESP_IP&gt;/ledon  and  http://&lt;ESP_IP&gt;/ledoff\");\n}\n</code></pre>"},{"location":"EmbededSystems_II/Homework/#videos","title":"videos:","text":""},{"location":"EmbededSystems_II/Homework/#excercise-3-code","title":"Excercise 3 code:","text":"<pre><code>/*\n * LAB D \u2014 ESP32-C6 Wi-Fi + HTTP + 2 LEDs + Button + Motor (TB6612)\n * ESP-IDF v5.x\n */\n\n#include &lt;string.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/event_groups.h\"\n#include \"freertos/task.h\"\n\n#include \"esp_log.h\"\n#include \"esp_err.h\"\n\n#include \"nvs_flash.h\"\n#include \"esp_netif.h\"\n#include \"esp_event.h\"\n#include \"esp_wifi.h\"\n\n#include \"driver/gpio.h\"\n#include \"driver/ledc.h\"\n#include \"esp_http_server.h\"\n\n/* ===================== CONFIG ===================== */\n#define WIFI_SSID \"iPhone de Carlos\"\n#define WIFI_PASS \"dogui123\"\n\n#define LED1_GPIO 8\n#define LED2_GPIO  // 1\n#define BUTTON_GPIO 10\n\n// TB6612 (CANAL A)\n#define MOTOR_PWM_GPIO   4   // PWMA\n#define MOTOR_IN1_GPIO   5   // AIN1\n#define MOTOR_IN2_GPIO   6   // AIN2\n#define MOTOR_STBY_GPIO  1  // STBY 13  &lt;-- CAMBIO IMPORTANTE (elige un pin libre)\n\n// LEDC\n#define MOTOR_LEDC_TIMER     LEDC_TIMER_0\n#define MOTOR_LEDC_MODE      LEDC_LOW_SPEED_MODE\n#define MOTOR_LEDC_CHANNEL   LEDC_CHANNEL_0\n#define MOTOR_LEDC_DUTY_RES  LEDC_TIMER_10_BIT\n#define MOTOR_LEDC_FREQUENCY 5000\n\n/* ===================== GLOBALS ===================== */\nstatic const char *TAG = \"LAB_3\";\n\nstatic EventGroupHandle_t s_wifi_event_group;\n#define WIFI_CONNECTED_BIT BIT0\n\nstatic int s_led1_state = 0;\nstatic int s_led2_state = 0;\nstatic int s_button_last_state = -1;\nstatic int s_motor_speed = 0;\n\nstatic httpd_handle_t s_server = NULL;\n\n/* ===================== LED ===================== */\nstatic void led_init(void)\n{\n    gpio_reset_pin(LED1_GPIO);\n    gpio_set_direction(LED1_GPIO, GPIO_MODE_OUTPUT);\n    gpio_set_level(LED1_GPIO, 0);\n\n    gpio_reset_pin(LED2_GPIO);\n    gpio_set_direction(LED2_GPIO, GPIO_MODE_OUTPUT);\n    gpio_set_level(LED2_GPIO, 0);\n}\n\nstatic void led_set(int led, int state)\n{\n    if (led == 1) {\n        s_led1_state = state;\n        gpio_set_level(LED1_GPIO, state);\n        ESP_LOGI(TAG, \"LED 1 -&gt; %s\", state ? \"ON\" : \"OFF\");\n    } else if (led == 2) {\n        s_led2_state = state;\n        gpio_set_level(LED2_GPIO, state);\n        ESP_LOGI(TAG, \"LED 2 -&gt; %s\", state ? \"ON\" : \"OFF\");\n    }\n}\n\n/* ===================== BUTTON ===================== */\nstatic void button_init(void)\n{\n    gpio_reset_pin(BUTTON_GPIO);\n    gpio_set_direction(BUTTON_GPIO, GPIO_MODE_INPUT);\n    gpio_set_pull_mode(BUTTON_GPIO, GPIO_PULLUP_ONLY); // pressed=0\n}\n\nstatic void button_task(void *arg)\n{\n    while (1)\n    {\n        int level = gpio_get_level(BUTTON_GPIO);\n        int pressed = (level == 0);\n\n        if (pressed != s_button_last_state)\n        {\n            s_button_last_state = pressed;\n            ESP_LOGI(TAG, \"Button -&gt; %s\", pressed ? \"PRESSED\" : \"RELEASED\");\n        }\n\n        vTaskDelay(pdMS_TO_TICKS(100));\n    }\n}\n\n/* ===================== MOTOR (TB6612) ===================== */\nstatic void motor_init(void)\n{\n    // DIR pins\n    gpio_reset_pin(MOTOR_IN1_GPIO);\n    gpio_set_direction(MOTOR_IN1_GPIO, GPIO_MODE_OUTPUT);\n\n    gpio_reset_pin(MOTOR_IN2_GPIO);\n    gpio_set_direction(MOTOR_IN2_GPIO, GPIO_MODE_OUTPUT);\n\n    // STBY (CR\u00cdTICO)\n    gpio_reset_pin(MOTOR_STBY_GPIO);\n    gpio_set_direction(MOTOR_STBY_GPIO, GPIO_MODE_OUTPUT);\n    gpio_set_level(MOTOR_STBY_GPIO, 1); // habilitar driver\n\n    // default direction\n    gpio_set_level(MOTOR_IN1_GPIO, 1);\n    gpio_set_level(MOTOR_IN2_GPIO, 0);\n\n    ledc_timer_config_t timer = {\n        .speed_mode = MOTOR_LEDC_MODE,\n        .timer_num = MOTOR_LEDC_TIMER,\n        .duty_resolution = MOTOR_LEDC_DUTY_RES,\n        .freq_hz = MOTOR_LEDC_FREQUENCY,\n        .clk_cfg = LEDC_AUTO_CLK\n    };\n    ESP_ERROR_CHECK(ledc_timer_config(&amp;timer));\n\n    ledc_channel_config_t channel = {\n        .speed_mode = MOTOR_LEDC_MODE,\n        .channel = MOTOR_LEDC_CHANNEL,\n        .timer_sel = MOTOR_LEDC_TIMER,\n        .intr_type = LEDC_INTR_DISABLE,\n        .gpio_num = MOTOR_PWM_GPIO, // PWMA\n        .duty = 0,\n        .hpoint = 0\n    };\n    ESP_ERROR_CHECK(ledc_channel_config(&amp;channel));\n\n    ESP_LOGI(TAG, \"Motor init: PWMA=%d AIN1=%d AIN2=%d STBY=%d\",\n             MOTOR_PWM_GPIO, MOTOR_IN1_GPIO, MOTOR_IN2_GPIO, MOTOR_STBY_GPIO);\n}\n\nstatic void motor_set_speed(int percent)\n{\n    if (percent &lt; 0) percent = 0;\n    if (percent &gt; 100) percent = 100;\n    s_motor_speed = percent;\n\n    // habilita driver cuando hay velocidad\n    gpio_set_level(MOTOR_STBY_GPIO, (percent &gt; 0) ? 1 : 0);\n\n    // duty 0..1023\n    uint32_t duty = (percent * 1023) / 100;\n\n    ledc_set_duty(MOTOR_LEDC_MODE, MOTOR_LEDC_CHANNEL, duty);\n    ledc_update_duty(MOTOR_LEDC_MODE, MOTOR_LEDC_CHANNEL);\n\n    ESP_LOGI(TAG, \"Motor speed: %d%% (duty=%lu)\", percent, (unsigned long)duty);\n}\n\n/* ===================== HTTP API ===================== */\nstatic esp_err_t api_status_get(httpd_req_t *req)\n{\n    char resp[128];\n    int button_pressed = (gpio_get_level(BUTTON_GPIO) == 0);\n\n    snprintf(resp, sizeof(resp),\n             \"{\\\"led1\\\":%d,\\\"led2\\\":%d,\\\"button\\\":%d,\\\"motor\\\":%d}\",\n             s_led1_state, s_led2_state, button_pressed, s_motor_speed);\n\n    httpd_resp_set_type(req, \"application/json\");\n    httpd_resp_send(req, resp, HTTPD_RESP_USE_STRLEN);\n    return ESP_OK;\n}\n\nstatic esp_err_t api_led_post(httpd_req_t *req)\n{\n    char buf[256] = {0};\n    int r = httpd_req_recv(req, buf, sizeof(buf)-1);\n    if (r &lt;= 0) return ESP_FAIL;\n    buf[r] = '\\0';\n\n    int led = -1, state = -1;\n\n    char *p_led = strstr(buf, \"\\\"led\\\"\");\n    if (p_led) { char *c = strchr(p_led, ':'); if (c) led = atoi(c + 1); }\n\n    char *p_state = strstr(buf, \"\\\"state\\\"\");\n    if (p_state) { char *c = strchr(p_state, ':'); if (c) state = atoi(c + 1); }\n\n    if ((led == 1 || led == 2) &amp;&amp; (state == 0 || state == 1))\n        led_set(led, state);\n\n    httpd_resp_set_type(req, \"application/json\");\n    httpd_resp_sendstr(req, \"{\\\"ok\\\":true}\");\n    return ESP_OK;\n}\n\nstatic esp_err_t api_motor_post(httpd_req_t *req)\n{\n    char buf[128] = {0};\n    int r = httpd_req_recv(req, buf, sizeof(buf)-1);\n    if (r &lt;= 0) return ESP_FAIL;\n    buf[r] = '\\0';\n\n    char *p_speed = strstr(buf, \"\\\"speed\\\"\");\n    if (p_speed) {\n        char *c = strchr(p_speed, ':');\n        if (c) motor_set_speed(atoi(c + 1));\n    }\n\n    httpd_resp_set_type(req, \"application/json\");\n    httpd_resp_sendstr(req, \"{\\\"ok\\\":true}\");\n    return ESP_OK;\n}\n\nstatic esp_err_t root_get_handler(httpd_req_t *req)\n{\n    static const char *INDEX_HTML =\n        \"&lt;!doctype html&gt;\\n\"\n        \"&lt;html&gt;\\n\"\n        \"&lt;head&gt;\\n\"\n        \"  &lt;meta charset='utf-8'&gt;\\n\"\n        \"  &lt;meta name='viewport' content='width=device-width, initial-scale=1'&gt;\\n\"\n        \"  &lt;title&gt;ESP32-C6 Control&lt;/title&gt;\\n\"\n        \"&lt;/head&gt;\\n\"\n        \"&lt;body&gt;\\n\"\n\n        \"  &lt;h2&gt;ESP32-C6 Control Panel&lt;/h2&gt;\\n\"\n\n        \"  &lt;hr&gt;\\n\"\n        \"  &lt;h3&gt;LED 1&lt;/h3&gt;\\n\"\n        \"  &lt;button onclick='setLed(1,1)'&gt;ON&lt;/button&gt;\\n\"\n        \"  &lt;button onclick='setLed(1,0)'&gt;OFF&lt;/button&gt;\\n\"\n        \"  &lt;p id='led1'&gt;State: ?&lt;/p&gt;\\n\"\n\n        \"  &lt;hr&gt;\\n\"\n        \"  &lt;h3&gt;LED 2&lt;/h3&gt;\\n\"\n        \"  &lt;button onclick='setLed(2,1)'&gt;ON&lt;/button&gt;\\n\"\n        \"  &lt;button onclick='setLed(2,0)'&gt;OFF&lt;/button&gt;\\n\"\n        \"  &lt;p id='led2'&gt;State: ?&lt;/p&gt;\\n\"\n\n        \"  &lt;hr&gt;\\n\"\n        \"  &lt;h3&gt;Push Button&lt;/h3&gt;\\n\"\n        \"  &lt;p id='button'&gt;Waiting...&lt;/p&gt;\\n\"\n\n        \"  &lt;hr&gt;\\n\"\n        \"  &lt;h3&gt;Motor Speed&lt;/h3&gt;\\n\"\n        \"  &lt;p&gt;Speed: &lt;span id='motor'&gt;0&lt;/span&gt;%&lt;/p&gt;\\n\"\n        \"  &lt;input type='range' min='0' max='100' value='0' \"\n        \"         oninput='setMotor(this.value)'&gt;\\n\"\n\n        \"\\n\"\n        \"  &lt;script&gt;\\n\"\n\n        \"    async function refresh(){\\n\"\n        \"      const r = await fetch('/api/status');\\n\"\n        \"      const j = await r.json();\\n\"\n\n        \"      document.getElementById('led1').innerText = 'State: ' + j.led1;\\n\"\n        \"      document.getElementById('led2').innerText = 'State: ' + j.led2;\\n\"\n        \"      document.getElementById('motor').innerText = j.motor;\\n\"\n        \"      document.getElementById('button').innerText = \"\n        \"          (j.button == 1) ? 'PRESSED' : 'RELEASED';\\n\"\n        \"    }\\n\"\n\n        \"    async function setLed(l,v){\\n\"\n        \"      await fetch('/api/led', {\\n\"\n        \"        method:'POST',\\n\"\n        \"        headers:{'Content-Type':'application/json'},\\n\"\n        \"        body:JSON.stringify({led:l,state:v})\\n\"\n        \"      });\\n\"\n        \"      refresh();\\n\"\n        \"    }\\n\"\n\n        \"    async function setMotor(v){\\n\"\n        \"      document.getElementById('motor').innerText = v;\\n\"\n        \"      await fetch('/api/motor', {\\n\"\n        \"        method:'POST',\\n\"\n        \"        headers:{'Content-Type':'application/json'},\\n\"\n        \"        body:JSON.stringify({speed:parseInt(v)})\\n\"\n        \"      });\\n\"\n        \"    }\\n\"\n\n        \"    setInterval(refresh, 1000);\\n\"\n        \"    refresh();\\n\"\n\n        \"  &lt;/script&gt;\\n\"\n\n        \"&lt;/body&gt;\\n\"\n        \"&lt;/html&gt;\\n\";\n\n    httpd_resp_set_type(req, \"text/html\");\n    httpd_resp_send(req, INDEX_HTML, HTTPD_RESP_USE_STRLEN);\n    return ESP_OK;\n}\nstatic void http_server_start(void)\n{\n    httpd_config_t config = HTTPD_DEFAULT_CONFIG();\n    ESP_ERROR_CHECK(httpd_start(&amp;s_server, &amp;config));\n\n    httpd_uri_t root = {\n        .uri = \"/\",\n        .method = HTTP_GET,\n        .handler = root_get_handler,\n        .user_ctx = NULL\n    };\n    httpd_uri_t status = {\n        .uri = \"/api/status\",\n        .method = HTTP_GET,\n        .handler = api_status_get,\n        .user_ctx = NULL\n    };\n    httpd_uri_t led = {\n        .uri = \"/api/led\",\n        .method = HTTP_POST,\n        .handler = api_led_post,\n        .user_ctx = NULL\n    };\n    httpd_uri_t motor = {\n        .uri = \"/api/motor\",\n        .method = HTTP_POST,\n        .handler = api_motor_post,\n        .user_ctx = NULL\n    };\n\n    ESP_ERROR_CHECK(httpd_register_uri_handler(s_server, &amp;root));\n    ESP_ERROR_CHECK(httpd_register_uri_handler(s_server, &amp;status));\n    ESP_ERROR_CHECK(httpd_register_uri_handler(s_server, &amp;led));\n    ESP_ERROR_CHECK(httpd_register_uri_handler(s_server, &amp;motor));\n}\n\n/* ===================== Wi-Fi ===================== */\nstatic void wifi_event_handler(void *arg, esp_event_base_t event_base, int32_t event_id, void *event_data)\n{\n    if (event_base == WIFI_EVENT &amp;&amp; event_id == WIFI_EVENT_STA_START) {\n        esp_wifi_connect();\n    }\n\n    if (event_base == IP_EVENT &amp;&amp; event_id == IP_EVENT_STA_GOT_IP) {\n        ip_event_got_ip_t *event = (ip_event_got_ip_t *)event_data;\n        ESP_LOGI(TAG, \"Got IP: \" IPSTR, IP2STR(&amp;event-&gt;ip_info.ip));\n        xEventGroupSetBits(s_wifi_event_group, WIFI_CONNECTED_BIT);\n    }\n}\n\nstatic void wifi_init_sta(void)\n{\n    s_wifi_event_group = xEventGroupCreate();\n\n    ESP_ERROR_CHECK(esp_netif_init());\n    ESP_ERROR_CHECK(esp_event_loop_create_default());\n    esp_netif_create_default_wifi_sta();\n\n    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();\n    ESP_ERROR_CHECK(esp_wifi_init(&amp;cfg));\n\n    ESP_ERROR_CHECK(esp_event_handler_register(WIFI_EVENT, ESP_EVENT_ANY_ID, &amp;wifi_event_handler, NULL));\n    ESP_ERROR_CHECK(esp_event_handler_register(IP_EVENT, IP_EVENT_STA_GOT_IP, &amp;wifi_event_handler, NULL));\n\n    wifi_config_t wifi_config = {0};\n    strcpy((char*)wifi_config.sta.ssid, WIFI_SSID);\n    strcpy((char*)wifi_config.sta.password, WIFI_PASS);\n\n    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));\n    ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_STA, &amp;wifi_config));\n    ESP_ERROR_CHECK(esp_wifi_start());\n}\n\nvoid app_main(void)\n{\n    esp_err_t ret = nvs_flash_init();\n    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {\n        ESP_ERROR_CHECK(nvs_flash_erase());\n        ESP_ERROR_CHECK(nvs_flash_init());\n    } else {\n        ESP_ERROR_CHECK(ret);\n    }\n\n    wifi_init_sta();\n\n    xEventGroupWaitBits(s_wifi_event_group, WIFI_CONNECTED_BIT,\n                        pdFALSE, pdTRUE, portMAX_DELAY);\n\n    led_init();\n    button_init();\n    motor_init();\n    http_server_start();\n\n    xTaskCreate(button_task, \"button_task\", 2048, NULL, 5, NULL);\n\n    ESP_LOGI(TAG, \"Open http://&lt;ESP_IP&gt;/ in your browser\");\n}\n</code></pre>"},{"location":"EmbededSystems_II/Homework/#images-and-videos","title":"Images and videos:","text":""},{"location":"ProyectoDeIng4/Proyecto%20final/","title":"PROYECTO FINAL","text":"<p>Este es el apartado del resultado de nuestro aprendizaje en el curso, que consisti\u00f3 en realizar un sensor de rayos UV que monitoree los datos en tiempo real y, dependiendo de tu configuraci\u00f3n de tu tez de piel (Desde muy clara hasta muy oscura), haga c\u00e1lculos y te notifique si usar bloqueador y en cu\u00e1nto tiempo reemplazarlo.</p>"},{"location":"ProyectoDeIng4/Proyecto%20final/#introduccion-propuesta","title":"Introducci\u00f3n-propuesta","text":"<p>Los rayos UV son uno de los problemas m\u00e1s comunes del d\u00eda a d\u00eda para la salud, ya que la exposici\u00f3n prolongada puede ocasionar desde da\u00f1os leves, envejecimiento acelerado, generaci\u00f3n de acn\u00e9 o incluso enfermedades terminales en la piel.</p> <p>La mayor parte de los da\u00f1os graves son gracias al descuido o desinformaci\u00f3n sobre el impacto del nivel y la alta exposici\u00f3n a los rayos UV. Esto es muy riesgoso, sobretodo en nuestra generaci\u00f3n actual, ya que gracias a la contaminaci\u00f3n ambiental y la reducci\u00f3n de la capa de ozono estamos viviendo con el nivel de rayos UV m\u00e1s alto registrado hasta la fecha.</p> <p>Nuestra propuesta es construir un sensor de monitorizaci\u00f3n de rayos UV barato y personalizable seg\u00fan tu fisionom\u00eda de la piel , que monitoree en tiempo real la cantidad de rayos UV que est\u00e1 recibiendo, y accione una alarma que te avise si es necesario ponerse bloqueador, volverse a poner o si no es necesario, podr\u00e1 ser implementado en diveros equipajes (mochilas, loncheras, bolsas, tableros de auto, etc.).</p>"},{"location":"ProyectoDeIng4/Proyecto%20final/#caracteristicas-que-debe-de-tener-el-producto","title":"Caracter\u00edsticas que debe de tener el producto:","text":"<p>Debe de ser capaz de detectar en tiempo real los niveles de rayos UV en el ambiente y mostrar una alarma o notificaci\u00f3n, alertando del riesgo para la piel a tiempo para evitar en mayor medida un da\u00f1o f\u00edsico. Debe de ser barato, confiable, f\u00e1cil de construir, con un dise\u00f1o amigable, port\u00e1til y f\u00e1cil de implementar.</p>"},{"location":"ProyectoDeIng4/Proyecto%20final/#link-de-la-presentacion","title":"Link de la presentaci\u00f3n","text":"<p>Presentaci\u00f3n de ideas.</p>"},{"location":"ProyectoDeIng4/Proyecto%20final/#boceto","title":"Boceto","text":""},{"location":"ProyectoDeIng4/Proyecto%20final/#desarrollo-del-proyecto","title":"Desarrollo del proyecto","text":"<p>El proyecto fue dise\u00f1ado, programado, fabricado y comercializado por nuestro equipo, utilizando m\u00faltiples competencias como son el modelado e impresi\u00f3n 3D, dise\u00f1o de placas tipo PCB, programaci\u00f3n avanzada y algoritmos, Metodolog\u00eda de la investigaci\u00f3n y m\u00e1rketing profesional.</p> <p> </p>"},{"location":"ProyectoDeIng4/Proyecto%20final/#paginas-de-trabajo-en-tiempo-real","title":"P\u00e1ginas de trabajo en tiempo real","text":"<p>P\u00e1gina de Trello</p> <p>P\u00e1gina de Jira</p>"},{"location":"ProyectoDeIng4/Proyecto%20final/#mercado-y-diagrama-porter","title":"Mercado y diagrama Porter","text":"<p>IDEO Buisness</p> <p>Sensor de rayos UV</p> <p>Diagrama de Porter</p> <p>Insightful</p> <p>Costo de arranque</p>"},{"location":"ProyectoDeIng4/Proyecto%20final/#costos-del-excell","title":"Costos del Excell","text":"<p>Hicimos una tabla de costos para nuestro prototipo con el objetivo de tener una visi\u00f3n clara y organizada de los recursos necesarios para su desarrollo desde cero. En ella se desglosan tanto los costos de producci\u00f3n \u2014como materiales, componentes electr\u00f3nicos, herramientas y mano de obra\u2014, como los costos de distribuci\u00f3n que se planean adoptar, incluyendo empaque, transporte y posibles canales de venta, asimismo, se calcularon los impuestos del ISR y del IVA para dar una predicci\u00f3n real de la cantidad de dinero ganada dentro de los 5 a\u00f1os a futuro (VF) desde la inversi\u00f3n (VP). Esta tabla nos permite estimar la viabilidad econ\u00f3mica del proyecto y planificar una estrategia de producci\u00f3n sostenible, asegurando que el prototipo no solo sea funcional, sino tambi\u00e9n accesible y realista para su futura implementaci\u00f3n o comercializaci\u00f3n.</p> <p>Creando la oferta Al crear la oferta de nuestro producto, es necesario dividir los costos individuales que se requieren para la producci\u00f3n unitaria de dicho prototipo, de manera que se pueda crear un an\u00e1lisis en relaci\u00f3n de todo lo que conlleva hacer que el producto llegue a las manos del usuario como la ganancia que \u00e9ste va a generar.</p> <p>Excell Costos y Ganancias Dermasense</p>"},{"location":"ProyectoDeIng4/Proyecto%20final/#termino-del-proyecto","title":"T\u00e9rmino del proyecto","text":"<p>Se realiz\u00f3 con \u00e9xito el prototipo de nuestro proyecto y se present\u00f3 frente a catedr\u00e1ticos, haciendo una simulaci\u00f3n tipo \"Shark tank\" a cada uno se le di\u00f3 dinero simulado con el objetivo de invertirlo en los proyectos que presenten la clase. Aqu\u00ed pusimos en pr\u00e1ctica todo lo que vimos en el curso para poder vender m\u00e1s que una idea, una visi\u00f3n y una inversi\u00f3n muy redituable.</p>"},{"location":"ProyectoDeIng4/Proyecto%20final/#archivos-de-documentacion-final","title":"Archivos de documentaci\u00f3n final","text":"<p>Excell de ventas</p> <p>Presentaci\u00f3n Power Point de Ventas</p> <p>Documentaci\u00f3n del Proyecto Word</p>"},{"location":"ProyectoDeIng4/Proyecto/","title":"Propuesta de proyecto","text":""},{"location":"ProyectoDeIng4/Proyecto/#sensor-de-rayos-uv","title":"Sensor de rayos UV","text":"<p>Los rayos UV son uno de los problemas m\u00e1s comunes del d\u00eda a d\u00eda para la salud, ya que la exposici\u00f3n prolongada puede ocasionar desde da\u00f1os leves, envejecimiento acelerado, generaci\u00f3n de acn\u00e9 o incluso enfermedades terminales en la piel.</p> <p>La mayor parte de los da\u00f1os graves son gracias al descuido o desinformaci\u00f3n sobre el impacto del nivel y la alta exposici\u00f3n a los rayos UV. Esto es muy riesgoso, sobretodo en nuestra generaci\u00f3n actual, ya que gracias a la contaminaci\u00f3n ambiental y la reducci\u00f3n de la capa de ozono estamos viviendo con el nivel de rayos UV m\u00e1s alto registrado hasta la fecha.</p> <p>Nuestra propuesta es construir un sensor de monitorizaci\u00f3n de rayos UV barato y personalizable seg\u00fan tu fisionom\u00eda de la piel , que monitoree en tiempo real la cantidad de rayos UV que est\u00e1 recibiendo, y accione una alarma que te avise si es necesario ponerse bloqueador, volverse a poner o si no es necesario, podr\u00e1 ser implementado en diveros equipajes (mochilas, loncheras, bolsas, tableros de auto, etc.).</p>"},{"location":"ProyectoDeIng4/Proyecto/#caracteristicas-que-debe-de-tener-el-producto","title":"Caracter\u00edsticas que debe de tener el producto:","text":"<p>Debe de ser capaz de detectar en tiempo real los niveles de rayos UV en el ambiente y mostrar una alarma o notificaci\u00f3n, alertando del riesgo para la piel a tiempo para evitar en mayor medida un da\u00f1o f\u00edsico. Debe de ser barato, confiable, f\u00e1cil de construir, con un dise\u00f1o amigable, port\u00e1til y f\u00e1cil de implementar.</p>"},{"location":"ProyectoDeIng4/Proyecto/#link-de-la-presentacion","title":"Link de la presentaci\u00f3n","text":"<p>Presentaci\u00f3n de ideas.</p>"},{"location":"ProyectoDeIng4/Proyecto/#boceto","title":"Boceto","text":""},{"location":"ProyectoDeIng4/Proyecto/#tarea-1-syllabus-firmado","title":"Tarea 1 SYLLABUS Firmado","text":"<p>\ud83d\udcc4 Ver y descargar PDF del Syllabus firmado</p>"},{"location":"ProyectoDeIng4/Proyecto/#tarea-2-investigacion-de-maquinas-de-capsulas-de-cafe","title":"TAREA 2 Investigaci\u00f3n de m\u00e1quinas de c\u00e1psulas de caf\u00e9","text":"<p>Caf\u00e9 de c\u00e1psulas</p>"},{"location":"ProyectoDeIng4/Proyecto/#tarea-3-diagrama-de-gantt","title":"TAREA 3 Diagrama de Gantt","text":"<p>Diagrama de Gantt proyecto</p>"},{"location":"ProyectoDeIng4/Proyecto/#tarea-4-marco-real-ganar-vale-la-pena-aplicado-a-mi-proyecto","title":"TAREA 4 Marco \u201creal-ganar-vale la pena\u201d aplicado a mi proyecto","text":"<p>Real-Ganar Vale la pena</p>"},{"location":"ProyectoDeIng4/Proyecto/#paginas-de-trabajo-en-tiempo-real","title":"P\u00e1ginas de trabajo en tiempo real","text":"<p>P\u00e1gina de Trello</p> <p>P\u00e1gina de Jira</p>"},{"location":"ProyectoDeIng4/Proyecto/#tarea-5-mercado-y-diagrama-porter","title":"TAREA 5 Mercado y diagrama Porter","text":"<p>IDEO Buisness</p> <p>Sensor de rayos UV</p> <p>Diagrama de Porter</p> <p>Insightful</p> <p>Costo de arranque</p>"},{"location":"ProyectoDeIng4/Proyecto/#costos-del-excell","title":"Costos del Excell","text":"<p>Hicimos una tabla de costos para nuestro prototipo con el objetivo de tener una visi\u00f3n clara y organizada de los recursos necesarios para su desarrollo desde cero. En ella se desglosan tanto los costos de producci\u00f3n \u2014como materiales, componentes electr\u00f3nicos, herramientas y mano de obra\u2014, como los costos de distribuci\u00f3n que se planean adoptar, incluyendo empaque, transporte y posibles canales de venta. Esta tabla nos permite estimar el presupuesto total, evaluar la viabilidad econ\u00f3mica del proyecto y planificar una estrategia de producci\u00f3n sostenible, asegurando que el prototipo no solo sea funcional, sino tambi\u00e9n accesible y realista para su futura implementaci\u00f3n o comercializaci\u00f3n.</p> <p>Creando la oferta Al crear la oferta de nuestro producto, es necesario dividir los costos individuales que se requieren para la producci\u00f3n unitaria de dicha prototipo, de manera que se pueda crear un an\u00e1lisis en relaci\u00f3n a un a\u00f1o (nosotros elegimos un a\u00f1o) de cu\u00e1nto costar\u00eda la producci\u00f3n de una cantidad determinada del producto terminado.</p> <p>En este caso, nosotros separamos nuestros costos de manera que se pueda identificar, cu\u00e1les son aquellos que diferencian a nuestro producto de los dem\u00e1s.</p> <p>Dsitribuci\u00f3n del producto La distribuci\u00f3n del producto es ESENCIAL para la creaci\u00f3n y venta de una idea, ya que se tiene que considerar \u00bfa qui\u00e9n? y \u00bfc\u00f3mo? vas a hacer llegar tu idea.</p> <p>Costos dermasense (Excell)</p>"},{"location":"SistemasEmbebidos/Examenes/","title":"Examenes Del Curso","text":""},{"location":"SistemasEmbebidos/Examenes/#primer-parcial-simon-dice","title":"Primer Parcial: Sim\u00f3n Dice","text":"<p>En este parcial, nuestro reto consisti\u00f3 en hacer utilizando todos los conocimientos previos un juego de sim\u00f3n dice en raspberry Pi Pico 2, con las siguientes normas:</p> <p>1.- La secuencia crece +1 por ronda, de 1 hasta 15.</p> <p>2.- La persona jugadora debe repetir la secuencia con 4 botones dentro de un tiempo l\u00edmite por ronda (En nuestro caso se anul\u00f3 esta regla porque Sebasti\u00e1n qued\u00f3 en podio del Kahoot).</p> <p>3.- Tiempo l\u00edmite por ronda (fase de entrada): TL = longitud + 5 segundos (p. ej., Ronda 7 \u2192 12 s). (No lo aplicamos).</p> <p>4.- Puntaje (0\u201315): mostrar la m\u00e1xima ronda alcanzada en un display de 7 segmentos en hex (0\u20139, A, b, C, d, E, F).</p> <p>5.- Aleatoriedad obligatoria: la secuencia debe ser impredecible en cada ejecuci\u00f3n.</p>"},{"location":"SistemasEmbebidos/Examenes/#reglas-del-juego-obligatorias","title":"Reglas del juego (obligatorias):","text":"<p>1.- Encendido/Reset: el 7 segmentos muestra \u201c0\u201d y queda en espera de Start (cualquier bot\u00f3n permite iniciar).</p> <p>2.- Reproducci\u00f3n: mostrar la secuencia actual (LEDs uno por uno con separaci\u00f3n clara).</p> <p>3.- Entrada: al terminar la reproducci\u00f3n, la persona debe repetir la secuencia completa dentro de TL.</p> <p>4.- Fallo (Game Over): bot\u00f3n incorrecto, falta/extra de entradas o exceder TL.</p> <p>5.- Progresi\u00f3n: si acierta, puntaje = n\u00famero de ronda, agrega 1 color aleatorio y avanza.</p> <p>6.- Fin: al fallar o completar la Ronda 15. Mostrar puntaje final en 7 segmentos (hex).</p>"},{"location":"SistemasEmbebidos/Examenes/#programa","title":"Programa","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/adc.h\"\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n\n#define Rondas 15\n#define Parpadeo 400\n#define Pausa 250\n#define Debounce 50\n\n#define LED0 0\n#define LED1 1\n#define LED2 3\n#define LED3 4\n\n#define BTN0 27\n#define BTN1 28\n#define BTN2 14\n#define BTN3 15\n\n#define SegmentoA  16\n#define SegmentoB  17\n#define SegmentoC  18\n#define SegmentoD 26\n#define SegmentoDp  20\n#define SegmentoE  21\n#define SegmentoF  22\n#define SegmentoG  2\n\n// arrays de pines para recorrer\nconst uint LEDS[4] = {LED0, LED1, LED2, LED3};\nconst uint Botones[4] = {BTN0, BTN1, BTN2, BTN3};\nconst uint Segmentos[8] = {SegmentoA, SegmentoB, SegmentoC, SegmentoDp, SegmentoE, SegmentoF, SegmentoG, SegmentoD};\n\n//\u00c1nodo com\u00fan, 0=1, 1=0\nconst bool MapaDisplay[16][8] = {\n    {0,0,0,0,0,0,1,1}, // 0\n    {1,0,0,1,1,1,1,1}, // 1\n    {0,0,1,0,0,1,0,1}, // 2\n    {0,0,0,0,1,1,0,1}, // 3\n    {1,0,0,1,1,0,0,1}, // 4\n    {0,1,0,0,1,0,0,1}, // 5\n    {0,1,0,0,0,0,0,1}, // 6\n    {0,0,0,1,1,1,1,1}, // 7\n    {0,0,0,0,0,0,0,1}, // 8\n    {0,0,0,0,1,0,0,1}, // 9\n    {0,0,0,1,0,0,0,1}, // A\n    {1,1,0,0,0,0,0,1}, // b\n    {0,1,1,0,0,0,1,1}, // C\n    {1,0,0,0,0,1,0,1}, // d\n    {0,1,1,0,0,0,0,1}, // E\n    {0,1,1,1,0,0,0,1}  // F\n};\n\nuint8_t Sequencia[Rondas];\nint Num_sequencia = 0;\n\nvoid MuestraDisplay(uint8_t n) {\n    for (int i = 0; i &lt; 8; i++) {\n        gpio_put(Segmentos[i], MapaDisplay[n &amp; 0xF][i]);\n    }\n}\n\nvoid Blink(uint8_t iL, uint32_t ms) {\n    gpio_put(LEDS[iL], 1);\n    sleep_ms(ms);\n    gpio_put(LEDS[iL], 0);\n}\n\nint PresionaBoton() {\n    while (1) {\n        for (int i = 0; i &lt; 4; i++) {\n            if (!gpio_get(Botones[i])) { \n                sleep_ms(Debounce);\n                while (!gpio_get(Botones[i])); \n                return i;\n            }\n        }\n        sleep_ms(10);\n    }\n}\n\nvoid EsperarBoton() {\n    while (1) {\n        for (int i = 0; i &lt; 4; i++) {\n            if (!gpio_get(Botones[i])) {\n                sleep_ms(Debounce);\n                while (!gpio_get(Botones[i])); // espera a quitar el bot\u00f3n presionado\n                return;\n            }\n        }\n        sleep_ms(10);\n    }\n}\n\nvoid IniciarLeds() {\n    for (int i = 0; i &lt; 4; i++) {\n        gpio_init(LEDS[i]);\n        gpio_set_dir(LEDS[i], true);\n    }\n}\n\nvoid IniciarBotones() {\n    for (int i = 0; i &lt; 4; i++) {\n        gpio_init(Botones[i]);\n        gpio_set_dir(Botones[i], false);\n        gpio_pull_up(Botones[i]);\n    }\n}\n\nvoid IniciarDisplay() {\n    for (int i = 0; i &lt; 8; i++) {\n        gpio_init(Segmentos[i]);\n        gpio_set_dir(Segmentos[i], true);\n    }\n}\n\n// Reproduce la secuencia actual\nvoid ReproducirSecuencia(int lim) {\n    sleep_ms(300);\n    for (int i = 0; i &lt; lim; i++) {\n        Blink(Sequencia[i], Parpadeo);\n        sleep_ms(Pausa);\n    }\n}\n\n// Game Over\nvoid GameOver(uint8_t score) {\n    MuestraDisplay(score &gt; 15 ? 15 : score);\n\n\n    for (int j = 0; j &lt; 6; j++) {\n        for (int i = 0; i &lt; 4; i++) gpio_put(LEDS[i], 1);\n        sleep_ms(120);\n        for (int i = 0; i &lt; 4; i++) gpio_put(LEDS[i], 0);\n        sleep_ms(120);\n    }\n\n\n    EsperarBoton();\n\n    Num_sequencia = 0;\n    MuestraDisplay(0);\n}\n\n// Genera un nuevo color aleatorio y lo agrega a la secuencia\nvoid SiguienteRonda() {\n    Sequencia[Num_sequencia++] = rand() &amp; 0x3;\n    if (Num_sequencia &gt; Rondas) Num_sequencia = Rondas;\n}\n\nbool PresionarSecuencia() { //La funci\u00f3n que tiene que hacer el jugador f\u00edsicamente\n    for (int i = 0; i &lt; Num_sequencia; i++) {\n        int presionar = PresionaBoton();\n        Blink(presionar, 120);\n        if (presionar != Sequencia[i]) return false;\n    }\n    return true;\n}\n\n\n\nint main() {\n    stdio_init_all();\n    IniciarLeds();\n    IniciarBotones();\n    IniciarDisplay();\n\n    // Aleatoriedad: ADC + tiempo\n    adc_init();\n    adc_gpio_init(26);\n    adc_select_input(0);\n    uint16_t noise = adc_read();\n    srand(to_us_since_boot(get_absolute_time()) ^ noise);\n\n    MuestraDisplay(0);\n\n    while (1) {\n\n        EsperarBoton();\n\n        while (1) {\n            SiguienteRonda();\n            MuestraDisplay(Num_sequencia);\n            sleep_ms(400);\n            ReproducirSecuencia(Num_sequencia);\n\n            bool Correcto = PresionarSecuencia();\n\n            if (!Correcto) {\n                GameOver(Num_sequencia - 1);\n                break; // reinicia juego\n            }\n\n            if (Num_sequencia &gt;= Rondas) {\n                GameOver(Rondas);\n                break; // reinicia juego\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"SistemasEmbebidos/Examenes/#diagrama-y-video","title":"Diagrama y video","text":""},{"location":"SistemasEmbebidos/Examenes/#segundo-parcial-control-de-servomotor","title":"Segundo Parcial: Control de Servomotor","text":"<p>En este parcial, nuestro reto consisti\u00f3 en utilizar la conexi\u00f3n con el puerto serial de una raspberry pi pico 2 y hacer un programa en C++ de multifase para mover un sevomotor, con configuraciones que t\u00fa puedes establecer, borrar, reproducir indefinidamente o moverlo paso a paso con botones, las reglas son las siguientes:</p>"},{"location":"SistemasEmbebidos/Examenes/#reglas-del-servoobligatorias","title":"Reglas del servo(obligatorias):","text":"<p>Hardware m\u00ednimo</p> <p>1 \u00d7 servomotor en un pin PWM (50 Hz).</p> <p>3 \u00d7 botones:</p> <p>BTN_MODE: cambia el modo activo (c\u00edclico: Entrenamiento \u2192 Continuo \u2192 Step \u2192 \u2026).</p> <p>BTN_NEXT: avanza a la siguiente posici\u00f3n (s\u00f3lo en Step).</p> <p>BTN_PREV: retrocede a la posici\u00f3n anterior (s\u00f3lo en Step).</p> <p>Pi pico 2</p> <p>Modos de operaci\u00f3n 1) Modo Entrenamiento Se recibe texto por USB-serial con los comandos siguientes (se aceptan min\u00fasculas/may\u00fasculas indistintamente y tambi\u00e9n sus alias en ingl\u00e9s):</p> <p>Borrar (alias: clear, borrar)</p> <p>Sintaxis: Borrar</p> <p>Efecto: elimina la lista completa de posiciones.</p> <p>Respuesta: OK.</p> <p>Escribir (alias: write, escribir)</p> <p>Sintaxis: Escribir, v1, v2, ..., vn</p> <p>vi son enteros en 0\u2013180.</p> <p>Efecto: sobrescribe la lista con los valores dados en ese orden.</p> <p>Respuesta: OK si todos son v\u00e1lidos y la lisa de posiciones; si alguno est\u00e1 fuera de rango o la lista queda vac\u00eda \u2192 Error argumento invalido.</p> <p>Reemplazar (alias: replace, reemplazar)</p> <p>Sintaxis: Reemplazar, i, v</p> <p>\u00cdndice i en base 1 (1 = primera posici\u00f3n).</p> <p>v en 0\u2013180.</p> <p>Efecto: reemplaza el elemento i por v.</p> <p>Respuesta: OK. Si i no existe \u2192 Error indice invalido. Si v fuera de rango \u2192 Error argumento invalido.</p> <p>2) Modo Continuo Recorre todas las posiciones de la lista en orden, moviendo el servo e imprimiendo cada 1.5 s:</p> <p>Formato: posX: V (por ejemplo, pos1: 90), donde X es base 1.</p> <p>Si la lista est\u00e1 vac\u00eda: imprimir cada 1.5 s Error no hay pos y no mover el servo.</p> <p>Al cambiar a otro modo, el ciclo se detiene inmediatamente.</p> <p>3) Modo Step BTN_NEXT: avanza una posici\u00f3n (si ya est\u00e1 en la \u00faltima, se mantiene en esa \u00faltima).</p> <p>BTN_PREV: retrocede una posici\u00f3n (si ya est\u00e1 en la primera, se mantiene en la primera).</p> <p>En cada cambio de posici\u00f3n:</p> <p>mover el servo a la posici\u00f3n seleccionada;</p> <p>imprimir posX: V.</p> <p>Si la lista est\u00e1 vac\u00eda: al presionar BTN_NEXT o BTN_PREV, imprimir Error no hay pos y no mover el servo.</p> <p>INFO IMPORTANTE: El movimiento de un servo requiere alimentacion 5-6v y en el pin de signal, un pwm a 50 HZ con un pulso de 1-2ms que representa 0-180 grados</p>"},{"location":"SistemasEmbebidos/Examenes/#programa_1","title":"Programa","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string&gt;\n#include &lt;cctype&gt;\n#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n#include \"hardware/gpio.h\"\n\nusing namespace std;\n\n#define SERVO_PIN 2\n#define BTN_ATRAS 14\n#define BTN_ADELANTE 13\n#define BTN_MODE 16\n#define UARTID uart0\n#define BAUDIOS 115200\n#define TX 0\n#define RX 1\n#define MAX_POS 10\n#define TOP 20000\n\nint posiciones[MAX_POS] = {0};\nint num_pos = 0;\nint modo = 1, idx = 0;\nvolatile bool cambio_modo = false;\n\n// FUNCIONES \ninline int angle_to_pulse(int a){return 450+(a*1200)/180;}\ninline void set_servo(uint s,uint c,int a){pwm_set_chan_level(s,c,angle_to_pulse(a));}\n\ninline void borrar_lista(){\n    for(int i=0;i&lt;MAX_POS;i++) \n    posiciones[i]=0;\n    num_pos=0;\n}\ninline bool lista_vacia(){\n    if(num_pos==0) return true;\n    for(int i=0;i&lt;num_pos;i++) if(posiciones[i]!=0) return false;\n    return true;\n}\ninline void imprimir_lista(){\n    printf(\"Lista actual: \");\n    for(int i=0;i&lt;MAX_POS;i++){\n        printf(\"%d\",posiciones[i]); if(i&lt;MAX_POS-1)printf(\", \"); \n    }\n    printf(\"\\n\");\n}\nvoid str_tolower(string &amp;s){for(auto &amp;c:s)c=tolower(c);}\n\n//ISR\nvoid cambio_isr(uint gpio,uint32_t events){cambio_modo=true;}\n\nint main(){\n    stdio_init_all();\n    sleep_ms(1500);\n\n    uart_init(UARTID,BAUDIOS);\n    gpio_set_function(TX,GPIO_FUNC_UART);\n    gpio_set_function(RX,GPIO_FUNC_UART);\n    uart_set_format(UARTID,8,1,UART_PARITY_NONE);\n\n    // SERVO\n    gpio_set_function(SERVO_PIN,GPIO_FUNC_PWM);\n    uint slice=pwm_gpio_to_slice_num(SERVO_PIN);\n    uint chan=pwm_gpio_to_channel(SERVO_PIN);\n    pwm_set_clkdiv(slice,150.0f); \n    pwm_set_wrap(slice,TOP);\n    pwm_set_enabled(slice,true);\n\n    gpio_init(BTN_ATRAS\n); gpio_set_dir(BTN_ATRAS\n    ,false); gpio_pull_up(BTN_ATRAS\n);\n    gpio_init(BTN_ADELANTE);  gpio_set_dir(BTN_ADELANTE,false);  gpio_pull_up(BTN_ADELANTE);\n    gpio_init(BTN_MODE); gpio_set_dir(BTN_MODE,false); gpio_pull_up(BTN_MODE);\n    gpio_set_irq_enabled_with_callback(BTN_MODE,GPIO_IRQ_EDGE_FALL,true,&amp;cambio_isr);\n\n    printf(\"\\n=== MODO 1: ENTRENAMIENTO ===\\nComandos: escribir / borrar\\n\");\n\n    string input;\n    bool prev_fwd=1,prev_back=1;\n\n    while(true){\n        //CAMBIO DE MODO\n        if(cambio_modo){\n            cambio_modo=false;\n            modo=(modo%3)+1;\n            idx=0;\n            printf(\"\\n=== CAMBIO A MODO %d ===\\n\",modo);\n\n            if(!lista_vacia()){\n                set_servo(slice,chan,posiciones[0]);\n                sleep_ms(500);\n            }\n\n            if(modo==1) printf(\"Modo entrenamiento: escribir / borrar\\n\");\n            if(modo==2) printf(\"Modo repetici\u00f3n autom\u00e1tica.\\n\");\n            if(modo==3) printf(\"Modo paso a paso con botones.\\n\");\n        }\n\n        //MODO 1 \n        if(modo==1){\n            int ch=getchar_timeout_us(0);\n            if(ch!=PICO_ERROR_TIMEOUT){\n                if(ch=='\\r'||ch=='\\n'){\n                    if(!input.empty()){\n                        string cmd=input; str_tolower(cmd);\n                        if(cmd==\"borrar\"||cmd==\"clear\"){borrar_lista();printf(\"OK.\\n\");imprimir_lista();}\n                        else if(cmd.find(\"escribir\")==0||cmd.find(\"write\")==0){\n                            printf(\"\u00bfCu\u00e1ntos valores (1\u201310)?: \");\n                            fflush(stdout);\n                            string n_str;\n                            while(true){\n                                int c=getchar_timeout_us(0);\n                                if(c!=PICO_ERROR_TIMEOUT){\n                                    if(c=='\\r'||c=='\\n')break; n_str+=(char)c;\n                                }\n                            }\n                            int n=stoi(n_str);\n                            if(n&lt;1||n&gt;MAX_POS){\n                                printf(\"Fuera de rango.\\n\");input.clear();continue;\n                            }\n                            printf(\"Ingrese %d valores (0\u2013180) separados por espacios:\\n\",n);\n                            fflush(stdout);\n                            string val_str;\n                            while(true){\n                                int c=getchar_timeout_us(0);\n                                if(c!=PICO_ERROR_TIMEOUT){\n                                    if(c=='\\r'||c=='\\n')break; val_str+=(char)c;\n                                }\n                            }\n                            borrar_lista();\n                            int i=0; size_t pos=0;\n                            while(i&lt;n &amp;&amp; pos&lt;val_str.size()){\n                                size_t e=val_str.find(' ',pos);\n                                int v=stoi(val_str.substr(pos,e-pos));\n                                if(v&lt;0||v&gt;180){printf(\"Valor fuera de rango.\\n\");break;}\n                                posiciones[i++]=v;\n                                if(e==string::npos)break; pos=e+1;\n                            }\n                            num_pos=i;\n                            printf(\"OK.\\n\");imprimir_lista();\n                        }\n                        else printf(\"Comando no reconocido.\\n\");\n                        input.clear();\n                    }\n                } else input+=(char)ch;\n            }\n        }\n\n        //MODO 2\n        else if(modo==2){\n            if(lista_vacia()){\n                printf(\"SIN MOVIMIENTO, LISTA EN 0\\n\");sleep_ms(1000);\n            }\n            else{\n                for(int i=0;i&lt;num_pos;i++){\n                    if(cambio_modo)break;\n                    set_servo(slice,chan,posiciones[i]);\n                    sleep_ms(1000);\n                }\n            }\n        }\n\n        //MODO 3\n        else if(modo==3){\n            if(lista_vacia()){\n                printf(\"SIN MOVIMIENTO, LISTA EN 0\\n\");sleep_ms(1000);\n            }\n            else{\n                set_servo(slice,chan,posiciones[idx]);\n                bool fwd=gpio_get(BTN_ADELANTE);\n                bool back=gpio_get(BTN_ATRAS\n            );\n\n                if(!fwd &amp;&amp; prev_fwd){ \n                    if(idx&lt;num_pos-1 &amp;&amp; posiciones[idx+1]!=0){\n                        idx++;set_servo(slice,chan,posiciones[idx]);\n                        printf(\"Avance a paso %d (%d\u00b0)\\n\",idx+1,posiciones[idx]);\n                    } else printf(\"Fin de secuencia.\\n\");\n                }\n                if(!back &amp;&amp; prev_back){\n                    if(idx&gt;0){\n                        idx--;set_servo(slice,chan,posiciones[idx]);\n                        printf(\"Retroceso a paso %d (%d\u00b0)\\n\",idx+1,posiciones[idx]);\n                    } else printf(\"Inicio de secuencia.\\n\");\n                }\n                prev_fwd=fwd; \n                prev_back=back;\n                sleep_ms(100);\n            }\n        }\n\n        sleep_ms(10);\n    }\n}\n</code></pre>"},{"location":"SistemasEmbebidos/Examenes/#video","title":"Video","text":""},{"location":"SistemasEmbebidos/PinOuts/","title":"PINOUTS","text":"<p>En esta secci\u00f3n de mi p\u00e1gina colocar\u00e9 los pinouts que encuentre de las placas que ocupamos, esto con la finalidad de tener a la mano toda la informaci\u00f3n necesaria para hacer diversos proyectos.</p>"},{"location":"SistemasEmbebidos/PinOuts/#microcontroladores","title":"Microcontroladores","text":""},{"location":"SistemasEmbebidos/PinOuts/#esp32","title":"ESP32","text":""},{"location":"SistemasEmbebidos/PinOuts/#xiao-esp32-c3","title":"XIAO ESP32-C3","text":""},{"location":"SistemasEmbebidos/PinOuts/#attiny-85","title":"Attiny 85","text":""},{"location":"SistemasEmbebidos/PinOuts/#raspberry-pi-pico-2","title":"Raspberry Pi Pico 2","text":""},{"location":"SistemasEmbebidos/PinOuts/#puentes-h","title":"Puentes H","text":""},{"location":"SistemasEmbebidos/PinOuts/#tb6612fng","title":"TB6612FNG","text":""},{"location":"SistemasEmbebidos/PinOuts/#l293d","title":"L293D","text":"<p>Nota: Este puente h es peque\u00f1o, adaptable a la protoboard pero su desventaja es que como funciona con 5v se volvi\u00f3 obsoleto ante los microcontroladores modernos que usan 3.3v para funcionar, as\u00ed que lo m\u00e1s recomendable es utilizar Arduino UNO.</p> <p></p>"},{"location":"SistemasEmbebidos/Tareas/","title":"TAREAS DEL CURSO","text":""},{"location":"SistemasEmbebidos/Tareas/#tarea-1-cuadro-comparativo","title":"Tarea 1: Cuadro comparativo","text":"<p>En esta tarea se realizar\u00e1 un cuadro comparativo entre 4 microcontroladores reconocidos, tomando en cuenta varias caracter\u00edsticas, tambi\u00e9n los voy a rankear por puesto y dir\u00e9 cu\u00e1l es mejor para m\u00ed y el por qu\u00e9.</p> Par\u00e1metro Arduino Uno (ATmega328P) ESP32 PIC16F877A Raspberry Pi Pico 2 (RP2350) Perif\u00e9ricos 14 GPIO, 6 entradas ADC, PWM, UART, SPI M\u00e1s de 30 GPIO, WiFi, Bluetooth, ADC, DAC, PWM, UART, SPI 33 GPIO, 8 canales ADC, UART, SPI, PWM 30 GPIO, 3 UART, 2 SPI, PWM, ADC, PIO programables, USB, soporte para memoria externa Memoria 32 KB Flash, 2 KB SRAM Hasta 4 MB Flash, 520 KB SRAM 14 KB Flash, 368 Bytes RAM 520 KB SRAM, soporte para hasta 128 MB Flash externa Ecosistema El m\u00e1s usado en las escuelas por su simpleza y librer\u00edas f\u00e1ciles Amplio en IoT, soporte para programar en Arduino IDE, ESP-IDF Utilizado mucho en industria y un poco en educaci\u00f3n, ecosistema m\u00e1s limitado pero optimizado Ecosistema en constante crecimiento, soporte C/C++, Python y SDK oficial de Raspberry Pi Costos (aprox.) 160-240 MX 100-200 MX (seg\u00fan versi\u00f3n) 120-200 MX 120-160 MX Arquitectura AVR de 8 bits Tensilica Xtensa LX6 o RISC-V de 32 bits PIC de 8 bits ARM Cortex-M33, 32 bits dual-core Velocidad de trabajo 16 MHz 160 \u2013 240 MHz 20 MHz Hasta 150 MHz en dual-core"},{"location":"SistemasEmbebidos/Tareas/#ranking","title":"RANKING","text":"<p>Aqu\u00ed est\u00e1 el ranking de los microcontroladores, lo hice en mi opini\u00f3n tomando en cuenta todas las caracter\u00edsticas de la tabla. </p> Microcontrolador Posici\u00f3n \u00bfPor qu\u00e9 ese ranking en mi opini\u00f3n? \u00bfPor qu\u00e9 los eleg\u00ed? ESP32 1 Es simple, potente, barato, se conecta Wi-Fi y Bluetooth y se puede utilizar en proyectos avanzados Lo eleg\u00ed porque es muy reconocible, lo hemos utilizado en producci\u00f3n electr\u00f3nica (XIAO ESP32) y porque yo s\u00e9 que en un futuro lo voy a ocupar m\u00e1s seriamente Raspberry Pi Pico 2 2 Es muy potente y r\u00e1pido, tiene bastante memoria y tiene un potencial muy bueno porque su ecosistema sigue en crecimiento, por lo tanto, es mucho mejor que Arduino para proyectos serios Lo eleg\u00ed porque siento que tiene much\u00edsimo m\u00e1s potencial que Arduino que me encanta, quiero aprender sobre ese microcontrolador y porque utilizar\u00e9 la rama de Raspberry much\u00edsimo en todo lo que sigue de la carrera Arduino UNO 3 Es h\u00edper simple, el mejor para la ense\u00f1anza en la escuela para empezar con los microcontroladores, pero es muy lento en sus ciclos y en su forma de ejecutar el programa final si son muchas instrucciones Lo eleg\u00ed porque gracias a este microcontrolador me apasion\u00e9 por la mecatr\u00f3nica y los robots potenciados por Arduino, es muy sencillo y divertido de aprender y te da libertad creativa con muchos componentes que utilizar, lo coloqu\u00e9 en este rango porque yo s\u00e9 que tiene un l\u00edmite y es lento y poco eficaz comparado con otros microcontroladores que voy a utilizar a lo largo de mi carrera PIC16F877A 4 Es muy utilizado en la industria por su optimizaci\u00f3n y simpleza, pero en los tiempos actuales se est\u00e1 quedando un poco obsoleto porque no tiene tanta memoria y es un poco m\u00e1s lento Lo eleg\u00ed porque siento que si me voy a un \u00e1rea laboral muy industrial tarde o temprano voy a terminar trabajando con este microcontrolador, o por lo menos, con unos parecidos"},{"location":"SistemasEmbebidos/Tareas/#tarea-2-outputs-basicos","title":"Tarea 2: Outputs b\u00e1sicos","text":"<p>En esta tarea tuvimos que realizar 3 programas distintos, en los cuales trabajamos en la primera un contador binario de 4 bits, en la segunda una secuencia de barrido y la \u00faltima una secuencia en formato Gray, igualmente de 4 bits.</p>"},{"location":"SistemasEmbebidos/Tareas/#primer_programa","title":"Primer_programa","text":"<p>Lo que hace este programa es representar en una cadena de 4 LEDS un contador en binario representando los 1 y 0 en encendido y apagado.</p> <pre><code>#include \"pico/stdlib.h\"\n\n#define LEDS_MASK ((1&lt;&lt;0) | (1&lt;&lt;1) | (1&lt;&lt;3) | (1&lt;&lt;4))  \n\nint main() {\n    stdio_init_all();\n\n\n    gpio_init(0); gpio_set_dir(0, GPIO_OUT);\n    gpio_init(1); gpio_set_dir(1, GPIO_OUT);\n    gpio_init(3); gpio_set_dir(3, GPIO_OUT);\n    gpio_init(4); gpio_set_dir(4, GPIO_OUT);\n\n    int estado = 0;\n\n    while (1) {\n\n        for (estado = 0; estado &lt; 16; estado++) {\n\n            gpio_put(0, estado &amp; (1&lt;&lt;0));\n            gpio_put(1, estado &amp; (1&lt;&lt;1));\n            gpio_put(3, estado &amp; (1&lt;&lt;2));  \n            gpio_put(4, estado &amp; (1&lt;&lt;3));\n            sleep_ms(500);\n        }\n    }\n}\n</code></pre>"},{"location":"SistemasEmbebidos/Tareas/#esquematicos-y-videos","title":"Esquem\u00e1ticos y videos","text":""},{"location":"SistemasEmbebidos/Tareas/#segundo_programa","title":"Segundo_Programa","text":"<p>Lo que hace el segundo programa es representar un barrido de ida y vuelta de una l\u00ednea de 4 LEDS, con el patr\u00f3n 0-1-2-3-2-1-0, encendiendo el pin seleccionado en el momento y apagando el resto.</p> <pre><code>#include \"pico/stdlib.h\"\n\n#define LED0 0   \n#define LED1 1   \n#define LED2 3   \n#define LED3 4   \n\n#define LED_MASK ((1u &lt;&lt; LED0) | (1u &lt;&lt; LED1) | (1u &lt;&lt; LED2) | (1u &lt;&lt; LED3))\n\nconst uint LEDS[4] = {LED0, LED1, LED2, LED3}; // lo hice as\u00ed para no repetir 4 lineas de c\u00f3digo\n\nint main() {\n    for (int i = 0; i &lt; 4; i++) {\n        gpio_init(LEDS[i]);\n        gpio_set_dir(LEDS[i], true);\n    }\n\n    int posicion = 0; \n    int dir = 1;   \n\n    while (true) {\n        gpio_clr_mask(LED_MASK); // Importante limpiar todos los LEDs\n\n        uint32_t bit = (1u &lt;&lt; LEDS[posicion]);  \n        gpio_set_mask(bit);      \n\n        sleep_ms(300);\n\n        posicion += dir;\n\n        if (posicion == 4 || posicion == -1) {\n            gpio_clr_mask(LED_MASK);\n            dir = -dir;  \n        }\n    }\n}\n</code></pre>"},{"location":"SistemasEmbebidos/Tareas/#esquematicos-y-videos_1","title":"Esquem\u00e1ticos y videos","text":""},{"location":"SistemasEmbebidos/Tareas/#tercer_programa","title":"Tercer_Programa","text":"<p>Lo que hace el tercer programa se parece un poco al contador binario del primer programa, pero lo que hace es representar con LEDs una secuencia llamada N\u00fameros Gray, convirtiendo una secuencia de binario a Gray y los representa en su l\u00ednea de 4 LEDs con el 1 como encendido y 0 como apagado.</p> <pre><code>#include \"pico/stdlib.h\"\n\nint main() {\n\n    const uint LEDS[] = {0, 1, 3, 4};\n    const int Cantidad = 4;\n\n\n    for (int i = 0; i &lt; Cantidad; i++) {//Para evitar c\u00f3digo si son muchos pines\n        gpio_init(LEDS[i]);\n        gpio_set_dir(LEDS[i], GPIO_OUT);\n    }\n\n    while (true) {\n\n        for (int n = 0; n &lt; 16; n++) {\n            int gray = n ^ (n &gt;&gt; 1); // F\u00f3rmula para convertir a Gray\n\n\n            for (int i = 0; i &lt; Cantidad; i++) {\n                int bit = (gray &gt;&gt; i) &amp; 1;\n                gpio_put(LEDS[i], bit);\n            }\n\n            sleep_ms(500);\n        }\n    }\n}\n</code></pre>"},{"location":"SistemasEmbebidos/Tareas/#esquematicos-y-videos_2","title":"Esquem\u00e1ticos y videos","text":""},{"location":"SistemasEmbebidos/Tareas/#tarea-3-inputs","title":"Tarea 3 Inputs","text":"<p>En esta tarea nos encargaron hacer 2 programas para Raspberry Pi Pico 2, utilizando inputs de 2 botones distintos para hacer encender una cadena de LEDs de cierta manera que detallar\u00e9 en cada programa.</p>"},{"location":"SistemasEmbebidos/Tareas/#primer-programa","title":"Primer programa","text":"<p>Este primer programa consisti\u00f3 en hacer 3 compuertas l\u00f3gicas: AND, OR y XOR, programando entradas con 2 botones en C y ejecutando en el microcontrolador para encender 3 LEDs, cada LED con la salida de las distintas compuertas.</p> <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n\n#define LED   0\n#define LED2    1\n#define LED3   3\n\n#define Boton1   5\n#define Boton2   6\n\nint main() {\n\n    gpio_init(LED);\n    gpio_set_dir(LED, true);\n\n    gpio_init(LED2);\n    gpio_set_dir(LED2, true);\n\n    gpio_init(LED3);\n    gpio_set_dir(LED3, true);\n\n    gpio_init(Boton1);\n    gpio_set_dir(Boton1, false);\n    gpio_pull_up(Boton1);\n\n    gpio_init(Boton2);\n    gpio_set_dir(Boton2, false);\n    gpio_pull_up(Boton2);\n\n    while (true) {\n        // Se invierte para que sea Pull-up\n        uint32_t b1 = !gpio_get(Boton1);\n        uint32_t b2 = !gpio_get(Boton2);\n\n        uint32_t AND = b1 &amp; b2;   \n        uint32_t OR  = b1 | b2; \n        uint32_t XOR = b1 ^ b2; \n\n        gpio_clr_mask((1u &lt;&lt; LED) | (1u &lt;&lt; LED2) | (1u &lt;&lt; LED3));\n        gpio_set_mask((AND &lt;&lt; LED) |\n                      (OR  &lt;&lt; LED2)  |\n                      (XOR &lt;&lt; LED3));\n    }\n}\n</code></pre>"},{"location":"SistemasEmbebidos/Tareas/#esquematicos-y-videos_3","title":"Esquem\u00e1ticos y videos","text":""},{"location":"SistemasEmbebidos/Tareas/#segundo-programa","title":"Segundo programa","text":"<p>Este segundo programa consisti\u00f3 en hacer una secuencia en cadenita, al igual que el programa de la cadena en la segunda tarea , programando entradas con 2 botones en C y ejecutando en el microcontrolador para encender la fila de 4 LEDs, cada LED con la salida de la numeraci\u00f3n correspondiente.</p> <pre><code>#include \"pico/stdlib.h\"\n\n#define LED0 0  \n#define LED1 1  \n#define LED2 3  \n#define LED3 4  \n\n#define Boton1 5\n#define Boton2 6\n\n#define LED_MASK ((1u &lt;&lt; LED0) | (1u &lt;&lt; LED1) | (1u &lt;&lt; LED2) | (1u &lt;&lt; LED3))\n\nconst uint LEDS[4] = {LED0, LED1, LED2, LED3};\n\nint main() {\n    stdio_init_all();\n\n    for (int i = 0; i &lt; 4; i++) {\n        gpio_init(LEDS[i]);\n        gpio_set_dir(LEDS[i], true);\n    }\n\n    gpio_init(Boton1);\n    gpio_set_dir(Boton1, false);  \n    gpio_pull_up(Boton1);\n\n    gpio_init(Boton2);\n    gpio_set_dir(Boton2, false);  \n    gpio_pull_up(Boton2);\n\n    int posicion = 0;\n    uint32_t Estadob1 = true;\n    uint32_t Estadob2 = true;\n\n    while (true) {\n        // Poner posici\u00f3n actual\n        gpio_clr_mask(LED_MASK);\n        gpio_set_mask(1u &lt;&lt; LEDS[posicion]);\n\n\n        uint32_t Avance = gpio_get(Boton1);\n        uint32_t Retroceso = gpio_get(Boton2);\n\n        if (!Avance &amp;&amp; Estadob1) {\n            posicion++;\n            if (posicion &gt; 3) posicion = 0;\n        }\n\n        if (!Retroceso &amp;&amp; Estadob2) {\n            posicion--;\n            if (posicion &lt; 0) posicion = 3;\n        }\n\n        Estadob1 = Avance;\n        Estadob2 = Retroceso;\n\n        sleep_ms(20);\n    }\n}\n</code></pre>"},{"location":"SistemasEmbebidos/Tareas/#esquematicos-y-videos_4","title":"Esquem\u00e1ticos y videos","text":""},{"location":"SistemasEmbebidos/Tareas/#tarea-4-pong-con-interrupciones","title":"Tarea 4 PONG con interrupciones","text":"<p>En esta tarea nos encargaron programar un mini-Pong con 5 LEDs en l\u00ednea y 2 botones usando interrupciones (ISR) para registrar el \u201cgolpe\u201d del jugador exactamente cuando la \u201cpelota\u201d (un LED encendido) llega al extremo de su lado. </p>"},{"location":"SistemasEmbebidos/Tareas/#reglas","title":"REGLAS","text":"<p>Pelota: es un \u00fanico LED encendido que se mueve autom\u00e1ticamente de un extremo al otro (L1\u2192L5\u2192L1\u2026) a un ritmo fijo.</p> <p>Golpe con ISR: cada bot\u00f3n genera una interrupci\u00f3n.</p> <p>El BTN_L solo cuenta si, en el instante de la ISR, la pelota est\u00e1 en L1.</p> <p>El BTN_R solo cuenta si, en el instante de la ISR, la pelota est\u00e1 en L5.</p> <p>Si coincide, la pelota rebota: invierte su direcci\u00f3n.</p> <p>Fallo y punto: si la pelota alcanza L1 y no hubo golpe v\u00e1lido del lado izquierdo en ese momento, anota el jugador derecho. An\u00e1logamente, si alcanza L5 sin golpe v\u00e1lido, anota el jugador izquierdo.</p> <p>Indicador de punto: al anotar, se parpadea el LED de punto 3 veces del jugador que meti\u00f3 el punto .</p> <p>Reinicio tras punto: despu\u00e9s del parpadeo, la pelota se reinicia en el centro (L3) y comienza a moverse hacia el jugador que meti\u00f3 el punto.</p> <p>Inicio del juego: al encender, la pelota inicia en L3 y no se mueve hasta que se presione un boton y debera moverse a la direccion opuesta del boton presionado.</p>"},{"location":"SistemasEmbebidos/Tareas/#programa","title":"Programa","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n\n#define Led 0\n#define Led2 1\n#define Led3 2   // LED central\n#define Led4 3\n#define Led5 4\n#define Led6p 6  \n#define Led7p 8   \n\n#define BotonIzq 14     \n#define BotonDer 15     \n\n#define LED_MASK ((1u &lt;&lt; Led) | (1u &lt;&lt; Led2) | (1u &lt;&lt; Led3) | (1u &lt;&lt; Led4) | (1u &lt;&lt; Led5))\n\nconst uint LEDS[5] = {Led, Led2, Led3, Led4, Led5};\nint posicion = 2;  \nint dir = 1;        \nbool fallo = false;\nint fallo_jugador = -1; \n\n// ISR para botones\nvoid boton_isr(uint gpio, uint32_t events) {\n    if (posicion == 0 &amp;&amp; gpio == BotonIzq) {\n        dir = 1;\n    } else if (posicion == 4 &amp;&amp; gpio == BotonDer) {\n        dir = -1;\n    } else {\n        fallo = true;\n        if (gpio == BotonIzq) {\n            fallo_jugador = 0; \n        } else if (gpio == BotonDer) {\n            fallo_jugador = 1; \n        }\n    }\n}\n\n\nvoid Inicioled() {\n    for (int i = 0; i &lt; 3; i++) {\n        gpio_put(Led3, 1);\n        sleep_ms(500);\n        gpio_put(Led3, 0); \n        sleep_ms(500);\n    }\n}\n\nint main() {\n    stdio_init_all();\n\n    for (int i = 0; i &lt; 5; i++) {\n        gpio_init(LEDS[i]);\n        gpio_set_dir(LEDS[i], true);\n    }\n\n    gpio_init(Led6p);\n    gpio_set_dir(Led6p, true);\n    gpio_init(Led7p);\n    gpio_set_dir(Led7p, true);\n\n    gpio_init(BotonIzq);\n    gpio_set_dir(BotonIzq, false);\n    gpio_pull_up(BotonIzq);\n    gpio_set_irq_enabled_with_callback(BotonIzq, GPIO_IRQ_EDGE_FALL, true, &amp;boton_isr);\n\n    gpio_init(BotonDer);\n    gpio_set_dir(BotonDer, false);\n    gpio_pull_up(BotonDer);\n    gpio_set_irq_enabled_with_callback(BotonDer, GPIO_IRQ_EDGE_FALL, true, &amp;boton_isr);\n\n\n    Inicioled();\n\n    while (true) {\n        gpio_clr_mask(LED_MASK); \n        gpio_set_mask(1u &lt;&lt; LEDS[posicion]); \n\n        sleep_ms(300);\n\n        if (fallo) {\n            gpio_clr_mask(LED_MASK);\n\n            if (fallo_jugador == 0) {\n                gpio_put(Led6p, 1);\n                sleep_ms(5000);\n                gpio_put(Led6p, 0);\n            } else if (fallo_jugador == 1) {\n                gpio_put(Led7p, 1);\n                sleep_ms(5000);\n                gpio_put(Led7p, 0);\n            }\n\n            // reiniciar juego\n            fallo = false;\n            fallo_jugador = -1;\n            posicion = 2;\n            dir = 1;\n\n\n            Inicioled();\n            continue;\n        }\n\n        posicion += dir;\n\n        // Rebote fallido\n        if (posicion &lt; 0) {\n            fallo = true;\n            fallo_jugador = 0;\n        } else if (posicion &gt; 4) {\n            fallo = true;\n            fallo_jugador = 1;\n        }\n    }\n}\n</code></pre>"},{"location":"SistemasEmbebidos/Tareas/#esquematicos-y-videos_5","title":"Esquem\u00e1ticos y videos","text":""},{"location":"SistemasEmbebidos/Tareas/#tarea-5-ejercicios-de-medicion","title":"Tarea 5 Ejercicios de medici\u00f3n","text":""},{"location":"SistemasEmbebidos/Tareas/#medicion-en-osciloscopio-del-periodo-y-jitter-usando-alarm0-modo-s","title":"Medici\u00f3n en osciloscopio del periodo y jitter usando ALARM0 (modo \u00b5s)","text":"<p>Genera una onda cuadrada por toggle de un pin de salida en la ISR de ALARM0, con rearme acumulativo y periodo nominal definido por ti (p. ej., 100 \u00b5s\u20135 ms). Mide con osciloscopio:</p> <p>Periodo promedio y tolerancia.</p> <p>Jitter pico-a-pico y, si tu equipo lo permite, RMS. Describe la configuraci\u00f3n del osciloscopio (acoplamiento, escala de tiempo/voltaje, modo de medici\u00f3n). No cambiar la resoluci\u00f3n del timer (mantener modo \u00b5s).</p>"},{"location":"SistemasEmbebidos/Tareas/#evidencia","title":"Evidencia","text":""},{"location":"SistemasEmbebidos/Tareas/#programa_1","title":"Programa","text":"<pre><code>// Blink con timer (SDK alto nivel): cambia BLINK_MS para ajustar\n#include \"pico/stdlib.h\"\n#include \"pico/time.h\"\n\n#define LED_PIN PICO_DEFAULT_LED_PIN\nstatic const int BLINK_MS = 1000;  // &lt;-- ajusta tu periodo aqu\u00ed\n\nbool blink_cb(repeating_timer_t *t) {\n    static bool on = false;\n    gpio_put(LED_PIN, on = !on);\n    return true; // seguir repitiendo la alarma\n}\n\nint main() {\n    stdio_init_all();\n\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, true);\n\n    repeating_timer_t timer;\n    // Programa una interrupci\u00f3n peri\u00f3dica cada BLINK_MS:\n    add_repeating_timer_ms(BLINK_MS, blink_cb, NULL, &amp;timer);\n\n    while (true) {\n        // El trabajo \"pesado\" deber\u00eda ir aqu\u00ed (no en la ISR).\n        tight_loop_contents();\n    }\n}\n</code></pre>"},{"location":"SistemasEmbebidos/Tareas/#diagrama","title":"Diagrama","text":"<p>An\u00e1lisis</p> <p>Al generar una se\u00f1al por medio de temporizadores, al momento de medirla en el osciloscopio se pudo observar el peque\u00f1o delay que se genera al usar este modo.</p> <p>Se configur\u00f3 el osciloscopio con un voltaje de 1V, para as\u00ed poder observar correctamente las se\u00f1ales. El tiempo de parpadeo era de 1 segundo y en el osciloscopio se obtuvo un ciclo de 1.001 s. Es decir que tiene un delay de 1 milisegundo</p>"},{"location":"SistemasEmbebidos/Tareas/#comparar-jitterprecision-con-osciloscopio-modo-s-vs-modo-ciclos","title":"Comparar jitter/precisi\u00f3n con osciloscopio: modo \u00b5s vs modo ciclos","text":"<p>Genera una se\u00f1al por toggle en la ISR de ALARM0, primero en modo \u00b5s y luego en modo ciclos de clk_sys (mismo periodo nominal). En ambos casos:</p> <p>Usa rearme acumulativo.</p> <p>Mant\u00e9n el resto del c\u00f3digo id\u00e9ntico. Con el osciloscopio, mide y registra para cada modo:</p> <p>Periodo promedio y desviaci\u00f3n respecto al nominal.</p> <p>Jitter pico-a-pico y/o RMS. Compara resultados y discute el compromiso entre resoluci\u00f3n de tick y horizonte de programaci\u00f3n.</p>"},{"location":"SistemasEmbebidos/Tareas/#evidencia_1","title":"Evidencia","text":""},{"location":"SistemasEmbebidos/Tareas/#programa_2","title":"Programa","text":"<pre><code>// Blink con timer de sistema (bajo nivel): programando ALARM0 e IRQ\n#include \"pico/stdlib.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n\n#define LED_PIN       PICO_DEFAULT_LED_PIN\n#define ALARM_NUM     0  // usaremos la alarma 0\n\n// Calcula el n\u00famero de IRQ para esa alarma \n#define ALARM_IRQ     timer_hardware_alarm_get_irq_num(timer_hw, ALARM_NUM)\n\nstatic volatile uint32_t next_deadline;   // pr\u00f3ximo instante (en us) en 32 bits bajos\n// Por defecto el timer cuenta \u00b5s (no cambiamos la fuente).\nstatic volatile uint32_t intervalo_us = 1000000u;    // periodo en microsegundos\n\nvoid on_alarm_irq(void) {\n    // 1) Limpiar el flag de la alarma\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM_NUM);\n\n    // 2) Hacer el trabajo toggle LED\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED_PIN;\n\n    // 3) Rearmar la siguiente alarma con \"deadline acumulativo\"\n    next_deadline += intervalo_us;\n    timer_hw-&gt;alarm[ALARM_NUM] = next_deadline;\n}\n\nint main() {\n    stdio_init_all();\n\n    // Configurar el LED\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, true);\n\n    // \"now\" = 32 bits bajos del contador (tiempo en \u00b5s)\n    uint32_t now_us = timer_hw-&gt;timerawl;          // lectura 32b (low) del contador\n    next_deadline = now_us + intervalo_us;         // primer deadline\n\n    // Programar la alarma\n    timer_hw-&gt;alarm[ALARM_NUM] = next_deadline;\n\n    // Crea un handler exclusivo para ligar el callback a la IRQ de la alarma\n    irq_set_exclusive_handler(ALARM_IRQ, on_alarm_irq);\n    // Habilitar dentro del perif\u00e9rico TIMER la fuente de interrupci\u00f3n para la alarma ALARM_NUM inte = interrupt enable\n    hw_set_bits(&amp;timer_hw-&gt;inte, 1u &lt;&lt; ALARM_NUM);\n    //Habilitar la IRQ en el NVIC (controlador de interrupciones del n\u00facleo)\n    irq_set_enabled(ALARM_IRQ, true);\n\n    while (true) {\n        // Mantener el bucle principal libre; lo pesado va aqu\u00ed, no en la ISR\n        tight_loop_contents();\n    }\n}\n</code></pre>"},{"location":"SistemasEmbebidos/Tareas/#diagrama_1","title":"Diagrama","text":""},{"location":"SistemasEmbebidos/Tareas/#comparacion","title":"Comparaci\u00f3n","text":"<p>Al comparar los dos modos, se encontr\u00f3 una diferencia entre el modo \u00b5s vs ciclos. El modo ciclos es m\u00e1s preciso y no genera ning\u00fan delay perceptible en el osciloscopio a diferncia del modo \u00b5s que tiene una diferencia de 1 ms.</p> <p>Con esta informaci\u00f3n se puede concluir que para tener un timer preciso el uso de los ciclos es el ideal y el mejor para implementar en futuros proyectos, ya que genera un timer \u00f3ptimo y sin delays.</p>"},{"location":"SistemasEmbebidos/Tareas/#tarea-6-ejercicios-de-programacion","title":"Tarea 6 Ejercicios de programaci\u00f3n","text":"<p>Esta tarea consisti\u00f3 en aprender a hacer programas utilizando timers y alarmas para hacer programas m\u00e1s optimizados.</p>"},{"location":"SistemasEmbebidos/Tareas/#primera-actividad","title":"Primera actividad","text":"<p>Esta actividad consisti\u00f3 en que, utilizando alarmas, encender y apagar simult\u00e1neamente 4 LEDs a velocidades distintas.</p>"},{"location":"SistemasEmbebidos/Tareas/#programa_3","title":"Programa","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n#include \"hardware/gpio.h\"\n\n#define LED0_PIN     0\n#define LED1_PIN     1\n#define LED2_PIN     3\n#define LED3_PIN     4\n\n#define ALARM0_NUM   0\n#define ALARM1_NUM   1\n#define ALARM2_NUM   2\n#define ALARM3_NUM   3\n\nstatic volatile uint32_t next0_us, next1_us, next2_us, next3_us;\nstatic const uint32_t INTERVALO0_US = 200000u;\nstatic const uint32_t INTERVALO1_US = 400000u;\nstatic const uint32_t INTERVALO2_US = 600000u;\nstatic const uint32_t INTERVALO3_US = 800000u;\n\n// ISR \u00daNICA para el TIMER\nstatic void on_timer_irq(void) {\n    uint32_t status = timer_hw-&gt;intr;  \n    timer_hw-&gt;intr = status;\n\n    if (status &amp; (1u &lt;&lt; ALARM0_NUM)) {\n        sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED0_PIN;\n        next0_us += INTERVALO0_US;\n        timer_hw-&gt;alarm[ALARM0_NUM] = next0_us;\n    }\n    if (status &amp; (1u &lt;&lt; ALARM1_NUM)) {\n        sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED1_PIN;\n        next1_us += INTERVALO1_US;\n        timer_hw-&gt;alarm[ALARM1_NUM] = next1_us;\n    }\n    if (status &amp; (1u &lt;&lt; ALARM2_NUM)) {\n        sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED2_PIN;\n        next2_us += INTERVALO2_US;\n        timer_hw-&gt;alarm[ALARM2_NUM] = next2_us;\n    }\n    if (status &amp; (1u &lt;&lt; ALARM3_NUM)) {\n        sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED3_PIN;\n        next3_us += INTERVALO3_US;\n        timer_hw-&gt;alarm[ALARM3_NUM] = next3_us;\n    }\n}\n\nint main() {\n    gpio_init(LED0_PIN); gpio_set_dir(LED0_PIN, GPIO_OUT); gpio_put(LED0_PIN, 0);\n    gpio_init(LED1_PIN); gpio_set_dir(LED1_PIN, GPIO_OUT); gpio_put(LED1_PIN, 0);\n    gpio_init(LED2_PIN); gpio_set_dir(LED2_PIN, GPIO_OUT); gpio_put(LED2_PIN, 0);\n    gpio_init(LED3_PIN); gpio_set_dir(LED3_PIN, GPIO_OUT); gpio_put(LED3_PIN, 0);\n\n    timer_hw-&gt;source = 0u;\n\n    uint32_t now_us = timer_hw-&gt;timerawl;\n\n    next0_us = now_us + INTERVALO0_US;\n    next1_us = now_us + INTERVALO1_US;\n    next2_us = now_us + INTERVALO2_US;\n    next3_us = now_us + INTERVALO3_US;\n\n    timer_hw-&gt;alarm[ALARM0_NUM] = next0_us;\n    timer_hw-&gt;alarm[ALARM1_NUM] = next1_us;\n    timer_hw-&gt;alarm[ALARM2_NUM] = next2_us;\n    timer_hw-&gt;alarm[ALARM3_NUM] = next3_us;\n\n    hw_clear_bits(&amp;timer_hw-&gt;intr,\n                  (1u &lt;&lt; ALARM0_NUM) |\n                  (1u &lt;&lt; ALARM1_NUM) |\n                  (1u &lt;&lt; ALARM2_NUM) |\n                  (1u &lt;&lt; ALARM3_NUM));\n\n    int irq_num = timer_hardware_alarm_get_irq_num(timer_hw, 0);\n    irq_set_exclusive_handler(irq_num, on_timer_irq);\n\n    hw_set_bits(&amp;timer_hw-&gt;inte,\n                (1u &lt;&lt; ALARM0_NUM) |\n                (1u &lt;&lt; ALARM1_NUM) |\n                (1u &lt;&lt; ALARM2_NUM) |\n                (1u &lt;&lt; ALARM3_NUM));\n\n    irq_set_enabled(irq_num, true);\n\n    while (true) {\n        tight_loop_contents();\n    }\n}\n</code></pre>"},{"location":"SistemasEmbebidos/Tareas/#diagrama-y-video","title":"Diagrama y video","text":""},{"location":"SistemasEmbebidos/Tareas/#segunda-actividad","title":"Segunda actividad","text":"<p>Esta actividad consisti\u00f3 en modificar el programa del Pong, coloc\u00e1ndole 2 botones extras que al presionarlos, aumenten o disminuyan la velocidad del barrido de los LEDs.</p>"},{"location":"SistemasEmbebidos/Tareas/#programa_4","title":"Programa","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n\n#define Leds 5\n#define Delayminimo 100\n#define Delaymaximo 1000\n#define Delay 100\n\nconst uint Boton1 = 14;     \nconst uint Boton2 = 15;  \nconst uint Botonmasvel = 13;  \nconst uint Botonmenosvel = 12;\nconst uint LEDS[Leds] = {0, 1, 2, 3, 4};\nconst uint LedP1 = 6;    // LED indicador derecha\nconst uint LedP2 = 8;    // LED indicador izquierda\n\nvolatile bool Reb1 = false;\nvolatile bool Reb2 = false;\nvolatile bool Subiovel = false;\nvolatile bool Bajovel = false;\n\nvoid button_isr(uint gpio, uint32_t events) {\n    if (gpio == Boton1) Reb1 = true;\n    else if (gpio == Boton2) Reb2 = true;\n    else if (gpio == Botonmasvel) Subiovel = true;\n    else if (gpio == Botonmenosvel) Bajovel = true;\n}\n\nvoid score_point(uint led) {\n    for (int i = 0; i &lt; 3; i++) {\n        gpio_put(led, 1);\n        sleep_ms(150);\n        gpio_put(led, 0);\n        sleep_ms(150);\n    }\n}\n\nint main() {\n    // Anotaci\u00f3n de puntos\n    gpio_init(LedP1); gpio_set_dir(LedP1, true);\n    gpio_init(LedP2); gpio_set_dir(LedP2, true);\n\n\n    gpio_init(Boton1); gpio_set_dir(Boton1, false); gpio_pull_up(Boton1);\n    gpio_set_irq_enabled_with_callback(Boton1, GPIO_IRQ_EDGE_FALL, true, &amp;button_isr);\n\n    gpio_init(Boton2); gpio_set_dir(Boton2, false); gpio_pull_up(Boton2);\n    gpio_set_irq_enabled(Boton2, GPIO_IRQ_EDGE_FALL, true);\n\n    gpio_init(Botonmasvel); gpio_set_dir(Botonmasvel, false); gpio_pull_up(Botonmasvel);\n    gpio_set_irq_enabled(Botonmasvel, GPIO_IRQ_EDGE_FALL, true);\n\n    gpio_init(Botonmenosvel); gpio_set_dir(Botonmenosvel, false); gpio_pull_up(Botonmenosvel);\n    gpio_set_irq_enabled(Botonmenosvel, GPIO_IRQ_EDGE_FALL, true);\n\n    // LEDs del juego\n    for (int i = 0; i &lt; Leds; i++) {\n        gpio_init(LEDS[i]);\n        gpio_set_dir(LEDS[i], true);\n    }\n\n    int current_led = Leds / 2;\n    int direction = 0;\n    bool game_started = false;\n    int delay_ms = 400; // velocidad inicial\n\n    gpio_put(LEDS[current_led], 1);\n\n    while (true) {\n        // Ajustar velocidad\n        if (Subiovel) {\n            if (delay_ms &gt; Delayminimo) delay_ms -= Delay;\n            Subiovel = false;\n        }\n        if (Bajovel) {\n            if (delay_ms &lt; Delaymaximo) delay_ms += Delay;\n            Bajovel = false;\n        }\n\n\n        if (!game_started) {\n            if (Reb1) { direction = 1; game_started = true; Reb1 = false; gpio_put(LEDS[current_led], 0);}\n            else if (Reb2) { direction = -1; game_started = true; Reb2 = false; gpio_put(LEDS[current_led], 0);}\n            else continue;\n        }\n\n        gpio_put(LEDS[current_led], 1);\n        sleep_ms(delay_ms);  //el delay depende del bot\u00f3n\n        gpio_put(LEDS[current_led], 0);\n\n        current_led += direction;\n\n        if (current_led == -1) {\n            if (Reb1) { direction = 1; current_led = 0; Reb1 = false; }\n            else { score_point(LedP1); current_led = Leds/2; direction = 1; }\n        }\n        if (current_led == Leds) {\n            if (Reb2) { direction = -1; current_led = Leds - 1; Reb2 = false; }\n            else { score_point(LedP2); current_led = Leds/2; direction = -1; }\n        }\n    }\n}\n</code></pre>"},{"location":"SistemasEmbebidos/Tareas/#diagrama-y-video_1","title":"Diagrama y video","text":""},{"location":"SistemasEmbebidos/Tareas/#tarea-7-pwm","title":"Tarea 7 PWM","text":"<p>Esta tarea consisti\u00f3 en aprender a hacer programas utilizando el generador de PWM de nuestro microcontrolador.</p>"},{"location":"SistemasEmbebidos/Tareas/#primera-actividad_1","title":"Primera actividad","text":"<p>Esta actividad consisti\u00f3 en que, mediante PWM vairemos el duty cycle con 2 botones para mover un motor DC a diferentes velocidades.</p>"},{"location":"SistemasEmbebidos/Tareas/#programa_5","title":"Programa","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n\n// Pines puente H TB6612\n#define PWMA   0   \n#define AIN1   1   \n#define AIN2   2   \n#define STBY   3   \n\n#define BTN_LOW   16\n#define BTN_MED   17\n#define BTN_HIGH  18\n\n#define F_PWM_HZ 2000   \n#define TOP 1023       \n\n#define DUTY_LOW   (TOP * 30 / 100)   // 30%\n#define DUTY_MED   (TOP * 60 / 100)   // 60%\n#define DUTY_HIGH  (TOP * 90 / 100)   // 90%\n\nint main() {\n    stdio_init_all();\n\n    gpio_init(AIN1);\n    gpio_set_dir(AIN1, GPIO_OUT);\n    gpio_put(AIN1, 1);\n\n    gpio_init(AIN2);\n    gpio_set_dir(AIN2, GPIO_OUT);\n    gpio_put(AIN2, 0);\n\n    gpio_init(STBY);\n    gpio_set_dir(STBY, GPIO_OUT);\n    gpio_put(STBY, 1);\n\n    gpio_set_function(PWMA, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(PWMA);\n    uint chan  = pwm_gpio_to_channel(PWMA);\n\n    float f_clk = 125000000.0f;\n    float div = f_clk / (F_PWM_HZ * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_wrap(slice, TOP);\n\n    pwm_set_chan_level(slice, chan, 0);\n    pwm_set_enabled(slice, true);\n\n    gpio_init(BTN_LOW);\n    gpio_set_dir(BTN_LOW, GPIO_IN);\n    gpio_pull_up(BTN_LOW);\n\n    gpio_init(BTN_HIGH);\n    gpio_set_dir(BTN_HIGH, GPIO_IN);\n    gpio_pull_up(BTN_HIGH);\n\n    while (1) {\n        if (!gpio_get(BTN_LOW)) {\n            pwm_set_chan_level(slice, chan, DUTY_LOW);\n        }\n\n        else if (!gpio_get(BTN_HIGH)) {\n            pwm_set_chan_level(slice, chan, DUTY_HIGH);\n        }\n        sleep_ms(100); \n    }\n}\n</code></pre>"},{"location":"SistemasEmbebidos/Tareas/#diagrama-y-video_2","title":"Diagrama y video","text":""},{"location":"SistemasEmbebidos/Tareas/#segunda-actividad_1","title":"Segunda actividad","text":"<p>Esta actividad consisti\u00f3 en hacer que con frecuencias generadas en el PWM un buzzer reprodujera una canci\u00f3n conocida.</p>"},{"location":"SistemasEmbebidos/Tareas/#programa_6","title":"Programa","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n#include &lt;stdint.h&gt;\n\n\n#define Buzzer 2\n#define TEMPO 200   // BPM\n\n#define DO3   34\n#define RE3   61\n#define MI3   68\n#define FA3   78\n#define SOL3  82\n#define SOLs3 111\n#define LA3   123\n#define SI3   151\n\n#define DO4   220\n#define DOs4  184\n#define RE4   250\n#define REs4  218\n#define MI4   282  \n#define FA4   300\n#define FAs4  277\n#define SOLb4 277\n#define SOL4  330\n#define SOLs4 350\n#define LAb4  350\n#define LA4   370\n#define LAs4  392\n#define SIb4  392\n#define SI4   420\n\n#define DO5   442\n#define DOs5  457\n#define RE5   495\n#define REs5  523\n#define MIb5  523\n#define MI5   560\n#define FA5   603\n#define FAs5  630\n#define SOL5  660\n#define SOLs5 735\n#define LA5   755\n#define LAs5  835\n#define SI5   845\n\n#define DO6   880\n\n#define SILENCIO 0\n\n\n// FIGURAS\n#define REDONDA   4.0f\n#define BLANCAP   3.0f\n#define BLANCA    2.0f\n#define NEGRA     1.0f\n#define CORCHEA   0.5f\n#define DCORCHEA  0.25f\n\nconst float reloj = 125000000.0f; // reloj 125 MHz\nuint slice_num;\nuint chan_num;\n\n\nstatic inline int duracion_ms(float figura) {\n    float negra_ms = 60000.0f / (float)TEMPO;\n    return (int)(figura * negra_ms + 0.5f);\n}\n\nvoid iniciar_pwm(uint gpio) {\n    gpio_set_function(gpio, GPIO_FUNC_PWM);\n    slice_num = pwm_gpio_to_slice_num(gpio);\n    chan_num  = pwm_gpio_to_channel(gpio);\n    pwm_set_enabled(slice_num, true);\n}\n\nvoid reproducir_nota(int frecuencia, float figura) {\n    if (frecuencia == SILENCIO) {\n        pwm_set_chan_level(slice_num, chan_num, 0);\n        sleep_ms(duracion_ms(figura));\n        return;\n    }\n\n    uint32_t wrap = 0;\n    float clkdiv = 1.0f;\n    for (int d = 1; d &lt;= 256; d++) {\n        float wrapf = reloj / ((float)d * (float)frecuencia) - 1.0f;\n        if (wrapf &gt;= 1.0f &amp;&amp; wrapf &lt;= 65535.0f) {\n            clkdiv = (float)d;\n            wrap = (uint32_t)(wrapf + 0.5f);\n            break;\n        }\n    }\n\n    if (wrap == 0) {\n        wrap = 65535;\n        clkdiv = reloj / ((wrap + 1) * (float)frecuencia);\n        if (clkdiv &lt; 1.0f) clkdiv = 1.0f;\n        if (clkdiv &gt; 256.0f) clkdiv = 256.0f;\n    }\n\n    pwm_set_clkdiv(slice_num, clkdiv);\n    pwm_set_wrap(slice_num, wrap);\n    pwm_set_chan_level(slice_num, chan_num, wrap / 2);\n\n    sleep_ms(duracion_ms(figura));\n\n    pwm_set_chan_level(slice_num, chan_num, 0);\n    sleep_ms(30);\n}\n\n\ntypedef struct {\n    int nota;\n    float figura;\n} Nota_t;\n\n\nNota_t escala[] = {\n    {MIb5, NEGRA},{SILENCIO, BLANCA}, {RE4, NEGRA}, {SILENCIO, BLANCA}, {MI4, NEGRA}, {SILENCIO, BLANCA}, {FA4, NEGRA}, {SILENCIO, BLANCA}, {SOL4, NEGRA}, {SILENCIO, BLANCA}, {LA4, NEGRA}, {SILENCIO, BLANCA}, {SI4, NEGRA}, {SILENCIO,BLANCA},\n {DO5, NEGRA}, {SILENCIO, BLANCA}, {RE5, NEGRA}, {SILENCIO, BLANCA}, {MI5, NEGRA}, {SILENCIO, BLANCA}, {FA5, NEGRA}, {SILENCIO, BLANCA}, {SOL5, NEGRA}, {SILENCIO, BLANCA}, {LA5, NEGRA}, {SILENCIO, BLANCA}, {SI5, NEGRA}, {SILENCIO,BLANCA}, {DO6,NEGRA}\n};\n\n\nNota_t cumple[] = {\n    {DO4, NEGRA}, {DO4, CORCHEA}, {RE4, CORCHEA}, {DO4, NEGRA}, {FA4, NEGRA}, {MI4, 2.0f},\n    {DO4, NEGRA}, {DO4, CORCHEA}, {RE4, CORCHEA}, {DO4, NEGRA}, {SOL4, NEGRA}, {FA4, 2.0f},\n    {DO4, NEGRA}, {DO4, CORCHEA}, {DO5, CORCHEA}, {LA4, NEGRA}, {FA4, NEGRA}, {MI4, NEGRA}, {RE4, 2.0f},\n    {SI4, NEGRA}, {SI4, CORCHEA}, {LA4, CORCHEA}, {FA4, NEGRA}, {SOL4, NEGRA}, {FA4, 2.0f}\n};\n\nNota_t mario[] = { {MI5, CORCHEA}, {MI5, CORCHEA}, {SILENCIO, CORCHEA}, {MI5, CORCHEA}, {SILENCIO, CORCHEA}, {DO5, CORCHEA}, {MI5, CORCHEA}, {SILENCIO, CORCHEA}, {SOL5, CORCHEA}, {SILENCIO, BLANCA}, {SOL4,CORCHEA}, {SILENCIO, CORCHEA},{SILENCIO, NEGRA},\n{DO5, NEGRA}, {SILENCIO, CORCHEA}, {SOL4, NEGRA}, {SILENCIO, CORCHEA}, {MI4, NEGRA}, {SILENCIO, CORCHEA}, {LA4, NEGRA}, {SI4, NEGRA}, {SIb4, CORCHEA}, {LA4, NEGRA}, {SOL4, CORCHEA}, {SILENCIO, DCORCHEA}, {MI5, CORCHEA}, {SILENCIO, DCORCHEA}, {SOL5, CORCHEA}, {SILENCIO, DCORCHEA}, {LA5, NEGRA}, {FA5, CORCHEA}, {SOL5, CORCHEA}, {SILENCIO, CORCHEA}, {MI5, NEGRA}, {DO5, CORCHEA}, {RE5, CORCHEA}, {SI4, NEGRA}, {SILENCIO, CORCHEA},\n{DO5, NEGRA}, {SILENCIO, CORCHEA}, {SOL4, NEGRA}, {SILENCIO, CORCHEA}, {MI4, NEGRA}, {SILENCIO, CORCHEA}, {LA4, NEGRA}, {SI4, NEGRA}, {SIb4, CORCHEA}, {LA4, NEGRA}, {SOL4, CORCHEA}, {SILENCIO, DCORCHEA}, {MI5, CORCHEA}, {SILENCIO, DCORCHEA}, {SOL5, CORCHEA}, {SILENCIO, DCORCHEA}, {LA5, NEGRA}, {FA5, CORCHEA}, {SOL5, CORCHEA}, {SILENCIO, CORCHEA}, {MI5, NEGRA}, {DO5, CORCHEA}, {RE5, CORCHEA}, {SI4, NEGRA}, {SILENCIO, NEGRA}, {SILENCIO, CORCHEA},\n{SOL5, CORCHEA}, {FAs5, CORCHEA}, {FA5, CORCHEA}, {REs5, NEGRA}, {MI5, CORCHEA}, {SILENCIO, CORCHEA}, {SOLs4, CORCHEA}, {LA4, CORCHEA}, {DO5, CORCHEA}, {SILENCIO, CORCHEA}, {LA4, CORCHEA}, {DO5, CORCHEA}, {RE5, CORCHEA}, {SILENCIO, NEGRA}, {SOL5, CORCHEA}, {FAs5, CORCHEA}, {FA5, CORCHEA}, {REs5, NEGRA}, {MI5, CORCHEA}, {SILENCIO, CORCHEA}, {DO6, NEGRA}, {DO6, CORCHEA}, {DO6, NEGRA}, {SILENCIO, BLANCA}, {SILENCIO, CORCHEA},\n{SOL5, CORCHEA}, {FAs5, CORCHEA}, {FA5, CORCHEA}, {REs5, NEGRA}, {MI5, CORCHEA}, {SILENCIO, CORCHEA}, {SOLs4, CORCHEA}, {LA4, CORCHEA}, {DO5, CORCHEA}, {SILENCIO, CORCHEA}, {LA4, CORCHEA}, {DO5, CORCHEA}, {RE5, CORCHEA}, {SILENCIO, NEGRA}, {MIb5, NEGRA}, {SILENCIO, CORCHEA}, {RE5, NEGRA}, {SILENCIO, CORCHEA}, {DO5, NEGRA}, {SILENCIO, BLANCA}, {SILENCIO, NEGRA},\n{SOL5, CORCHEA}, {FAs5, CORCHEA}, {FA5, CORCHEA}, {REs5, NEGRA}, {MI5, CORCHEA}, {SILENCIO, CORCHEA}, {SOLs4, CORCHEA}, {LA4, CORCHEA}, {DO5, CORCHEA}, {SILENCIO, CORCHEA}, {LA4, CORCHEA}, {DO5, CORCHEA}, {RE5, CORCHEA}, {SILENCIO, NEGRA}, {SOL5, CORCHEA}, {FAs5, CORCHEA}, {FA5, CORCHEA}, {REs5, NEGRA}, {MI5, CORCHEA}, {SILENCIO, CORCHEA}, {DO6, NEGRA}, {DO6, CORCHEA}, {DO6, NEGRA}, {SILENCIO, BLANCA}, {SILENCIO, CORCHEA},\n{SOL5, CORCHEA}, {FAs5, CORCHEA}, {FA5, CORCHEA}, {REs5, NEGRA}, {MI5, CORCHEA}, {SILENCIO, CORCHEA}, {SOLs4, CORCHEA}, {LA4, CORCHEA}, {DO5, CORCHEA}, {SILENCIO, CORCHEA}, {LA4, CORCHEA}, {DO5, CORCHEA}, {RE5, CORCHEA}, {SILENCIO, NEGRA}, {MIb5, NEGRA}, {SILENCIO, CORCHEA}, {RE5, NEGRA}, {SILENCIO, CORCHEA}, {DO5, NEGRA}, {SILENCIO, BLANCA},\n{DO5, CORCHEA}, {DO5, CORCHEA}, {SILENCIO, CORCHEA}, {DO5, CORCHEA}, {SILENCIO, CORCHEA}, {DO5, CORCHEA}, {RE5, NEGRA}, {MI5, CORCHEA}, {DO5, CORCHEA}, {SILENCIO, CORCHEA}, {LA4, CORCHEA}, {SOL4, BLANCA}, {DO5, CORCHEA}, {DO5, CORCHEA},  {SILENCIO, CORCHEA}, {DO5, CORCHEA}, {SILENCIO, CORCHEA}, {DO5, CORCHEA}, {RE5, CORCHEA}, {MI5, NEGRA}, {SILENCIO, REDONDA}, \n{DO5, CORCHEA}, {DO5, CORCHEA}, {SILENCIO, CORCHEA}, {DO5, CORCHEA}, {SILENCIO, CORCHEA}, {DO5, CORCHEA}, {RE5, NEGRA}, {MI5, CORCHEA}, {DO5, CORCHEA}, {SILENCIO, CORCHEA}, {LA4, CORCHEA}, {SOL4, BLANCA}, {SILENCIO, CORCHEA}, {MI5, CORCHEA}, {MI5, CORCHEA}, {SILENCIO, CORCHEA}, {MI5, CORCHEA}, {SILENCIO, CORCHEA}, {DO5, CORCHEA}, {MI5, CORCHEA}, {SILENCIO, CORCHEA}, {SOL5, CORCHEA}, {SILENCIO, BLANCA}, {SOL4,CORCHEA}, {SILENCIO, CORCHEA},{SILENCIO, NEGRA},\n{DO5, NEGRA}, {SILENCIO, CORCHEA}, {SOL4, NEGRA}, {SILENCIO, CORCHEA}, {MI4, NEGRA}, {SILENCIO, CORCHEA}, {LA4, NEGRA}, {SI4, NEGRA}, {SIb4, CORCHEA}, {LA4, NEGRA}, {SOL4, CORCHEA}, {SILENCIO, DCORCHEA}, {MI5, CORCHEA}, {SILENCIO, DCORCHEA}, {SOL5, CORCHEA}, {SILENCIO, DCORCHEA}, {LA5, NEGRA}, {FA5, CORCHEA}, {SOL5, CORCHEA}, {SILENCIO, CORCHEA}, {MI5, NEGRA}, {DO5, CORCHEA}, {RE5, CORCHEA}, {SI4, NEGRA}, {SILENCIO, CORCHEA},\n{DO5, NEGRA}, {SILENCIO, CORCHEA}, {SOL4, NEGRA}, {SILENCIO, CORCHEA}, {MI4, NEGRA}, {SILENCIO, CORCHEA}, {LA4, NEGRA}, {SI4, NEGRA}, {SIb4, CORCHEA}, {LA4, NEGRA}, {SOL4, CORCHEA}, {SILENCIO, DCORCHEA}, {MI5, CORCHEA}, {SILENCIO, DCORCHEA}, {SOL5, CORCHEA}, {SILENCIO, DCORCHEA}, {LA5, NEGRA}, {FA5, CORCHEA}, {SOL5, CORCHEA}, {SILENCIO, CORCHEA}, {MI5, NEGRA}, {DO5, CORCHEA}, {RE5, CORCHEA}, {SI4, NEGRA}, {SILENCIO, NEGRA}, {SILENCIO, NEGRA},\n{MI5, CORCHEA}, {DO5, NEGRA}, {SOL4, CORCHEA}, {SILENCIO, CORCHEA}, {SOLs4, NEGRA}, {LA4, CORCHEA}, {LA4, CORCHEA}, {FA5, NEGRA}, {FA5, CORCHEA}, {LA4, NEGRA}, {SILENCIO, NEGRA}, {SI4, CORCHEA}, {SILENCIO, DCORCHEA}, {LA5, CORCHEA}, {SILENCIO, DCORCHEA}, {LA5, CORCHEA}, {SILENCIO, DCORCHEA}, {LA5, CORCHEA}, {SILENCIO, DCORCHEA}, {SOL5, CORCHEA}, {SILENCIO, DCORCHEA}, {FA5, CORCHEA}, {SILENCIO, DCORCHEA}, {MI5, CORCHEA}, {DO5, NEGRA}, {LA4, CORCHEA}, {SOL4, NEGRA}, {SILENCIO, NEGRA},\n{MI5, CORCHEA}, {DO5, NEGRA}, {SOL4, CORCHEA}, {SILENCIO, CORCHEA}, {SOLs4, NEGRA}, {LA4, CORCHEA}, {LA4, CORCHEA}, {FA5, NEGRA}, {FA5, CORCHEA}, {LA4, NEGRA}, {SILENCIO, NEGRA}, {SI4, CORCHEA}, {FA5, NEGRA}, {FA5, CORCHEA}, {FA5, CORCHEA}, {SILENCIO, DCORCHEA}, {MI5, CORCHEA}, {SILENCIO, DCORCHEA}, {RE5, CORCHEA}, {SILENCIO,DCORCHEA}, {DO5, CORCHEA}, {SILENCIO, DCORCHEA}, {SOL4, CORCHEA}, {SILENCIO, DCORCHEA}, {MI4, CORCHEA}, {DO4, NEGRA}, {SILENCIO, NEGRA},\n{MI5, CORCHEA}, {DO5, NEGRA}, {SOL4, CORCHEA}, {SILENCIO, CORCHEA}, {SOLs4, NEGRA}, {LA4, CORCHEA}, {LA4, CORCHEA}, {FA5, NEGRA}, {FA5, CORCHEA}, {LA4, NEGRA}, {SILENCIO, NEGRA}, {SI4, CORCHEA}, {SILENCIO, DCORCHEA}, {LA5, CORCHEA}, {SILENCIO, DCORCHEA}, {LA5, CORCHEA}, {SILENCIO, DCORCHEA}, {LA5, CORCHEA}, {SILENCIO, DCORCHEA}, {SOL5, CORCHEA}, {SILENCIO, DCORCHEA}, {FA5, CORCHEA}, {SILENCIO, DCORCHEA}, {MI5, CORCHEA}, {DO5, NEGRA}, {LA4, CORCHEA}, {SOL4, NEGRA}, {SILENCIO, NEGRA},\n{MI5, CORCHEA}, {DO5, NEGRA}, {SOL4, CORCHEA}, {SILENCIO, CORCHEA}, {SOLs4, NEGRA}, {LA4, CORCHEA}, {LA4, CORCHEA}, {FA5, NEGRA}, {FA5, CORCHEA}, {LA4, NEGRA}, {SILENCIO, NEGRA}, {SI4, CORCHEA}, {FA5, NEGRA}, {FA5, CORCHEA}, {FA5, CORCHEA}, {SILENCIO, DCORCHEA}, {MI5, CORCHEA}, {SILENCIO, DCORCHEA}, {RE5, CORCHEA}, {SILENCIO,DCORCHEA}, {DO5, CORCHEA}, {SILENCIO, DCORCHEA}, {SOL4, CORCHEA}, {SILENCIO, DCORCHEA}, {MI4, CORCHEA}, {DO4, NEGRA}, {SILENCIO, BLANCA},\n{DO5, BLANCA}, {SILENCIO, DCORCHEA}, {SOL4, BLANCA}, {SILENCIO, DCORCHEA}, {MI4, NEGRA}, {SILENCIO, CORCHEA}, {LA4, NEGRA}, {SILENCIO, DCORCHEA}, {SI4, NEGRA}, {SILENCIO, DCORCHEA}, {SIb4, NEGRA}, {SILENCIO, DCORCHEA}, {LAb4, NEGRA}, {SILENCIO, DCORCHEA}, {SIb4, NEGRA}, {SILENCIO, DCORCHEA}, {LAb4, NEGRA}, {SILENCIO, DCORCHEA}, {SOL4, CORCHEA}, {FA4, CORCHEA}, {SOL4, BLANCAP}, {SILENCIO, REDONDA}, {SILENCIO, REDONDA}\n};\n\n\n// ---------- Funci\u00f3n gen\u00e9rica ----------\nvoid reproducir_melodia(Nota_t *melodia, int n) {\n    for (int i = 0; i &lt; n; i++) {\n        reproducir_nota(melodia[i].nota, melodia[i].figura);\n    }\n}\n\nint main() {\n    stdio_init_all();\n    iniciar_pwm(Buzzer);\n\n    Nota_t *melodia = mario;  // seleccionar la funci\u00f3n de melod\u00eda, cambiar mario por la que sea\n    int n = sizeof(mario) / sizeof(mario[0]);\n\n\n    while (1) {\n        reproducir_melodia(melodia, n);\n        sleep_ms(500); // pausa para el bucle de la melod\u00eda\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"SistemasEmbebidos/Tareas/#diagrama-y-video_3","title":"Diagrama y video","text":""},{"location":"SistemasEmbebidos/Tareas/#tercera-actividad","title":"Tercera actividad","text":"<p>Esta actividad consisti\u00f3 en generar una se\u00f1al PWM en la raspberry para pasarla por un filtro RC y medir la se\u00f1al, el objetivo fue hacer una se\u00f1al senosoidal observable en el osciloscopio.</p>"},{"location":"SistemasEmbebidos/Tareas/#programa_7","title":"Programa","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n#include \"hardware/pwm.h\"\n#include &lt;math.h&gt;\n\n#define PWMA 0       // GPIO 0 salida PWM\n#define FS   2000    // Frecuencia de muestreo de la tabla (Hz)\n#define F_SENO 60    // Frecuencia de la se\u00f1al senoidal (Hz)\n#define TOP   1023   // Resoluci\u00f3n PWM (10 bits)\n\n#define ALARM0_NUM 0\n#define ALARM0_IRQ timer_hardware_alarm_get_irq_num(timer_hw, ALARM0_NUM)\n\n#define TABLA_T (FS / F_SENO)\n\nuint16_t tabla_sen[TABLA_T];\nvolatile int x = 0;\n\nvoid alarm0_isr() {\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM0_NUM);\n    // Actualizar PWM con el siguiente valor del seno\n    pwm_set_gpio_level(PWMA, tabla_sen[x]);\n    x = (x + 1) % TABLA_T;\n    uint64_t now = time_us_64();\n    timer_hw-&gt;alarm[ALARM0_NUM] = (uint32_t)(now + 1000000 / FS);\n}\n\nint main() {\n    stdio_init_all();\n\n    for (int i = 0; i &lt; TABLA_T; i++) {\n        float ang = 2 * M_PI * i / TABLA_T;\n        float s = (sinf(ang) + 1.0f) / 2.0f;  // Normalizado 0\u20131\n        tabla_sen[i] = (uint16_t)(s * TOP);\n    }\n\n\n    gpio_set_function(PWMA, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(PWMA);\n    float f_clk = 125000000.0f; // clock base 125 MHz\n    float div = f_clk / (FS * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_wrap(slice, TOP);\n    pwm_set_enabled(slice, true);\n\n\n    irq_set_exclusive_handler(ALARM0_IRQ, alarm0_isr);\n    irq_set_enabled(ALARM0_IRQ, true);\n\n\n    uint64_t now = time_us_64();\n    timer_hw-&gt;alarm[ALARM0_NUM] = (uint32_t)(now + 1000000 / FS);\n\n    while (1) {\n        tight_loop_contents(); // loop vac\u00edo\n    }\n}\n</code></pre>"},{"location":"SistemasEmbebidos/Tareas/#fotos-de-comprobacion-y-diagrama","title":"Fotos de comprobaci\u00f3n y diagrama","text":""},{"location":"SistemasEmbebidos/Tareas/#tarea-8-uart","title":"Tarea 8 UART","text":"<p>Esta tarea consisti\u00f3 en aprender a hacer programas utilizando la comunicaci\u00f3n del puerto serial para hacer conexiones entre microcontroladores con el objetivo de leer, mandar, procesar, recibir y comparar comandos para activar leds.</p>"},{"location":"SistemasEmbebidos/Tareas/#primera-actividad_2","title":"Primera actividad","text":"<p>Esta actividad consisti\u00f3 en que, utilizando conexi\u00f3n serial entre dos RPP 2 y un comando, encender un led parpadeante.</p>"},{"location":"SistemasEmbebidos/Tareas/#programa_8","title":"Programa","text":"<pre><code>#include \"pico/stdlib.h\"\n#include &lt;stdio.h&gt;\n\n#define UART_ID uart1\n#define BAUD_RATE 115200\n#define TX_PIN 0\n#define RX_PIN 1\n\n\n\nint main() {\n    stdio_init_all();\n\n\n    gpio_set_function(TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(RX_PIN, GPIO_FUNC_UART);\n\n    uart_init(UART_ID, BAUD_RATE);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n\n\n    sleep_ms(2000); // tiempo para enumeraci\u00f3n USB\n\n    while (getchar_timeout_us(0) != PICO_ERROR_TIMEOUT) {\n    // solo leer y descartar cualquier car\u00e1cter residual\n}\n\n    printf(\"\\n[Pico USB] Conexi\u00f3n lista. Escribe algo y Enter.\\n\");\n\n    while (true) {\n        int ch = getchar_timeout_us(0);\n        if (ch != PICO_ERROR_TIMEOUT) {\n            printf(\"Eco: %c\\n\", (char)ch);\n            uart_putc(UART_ID, (char)ch); \n        }\n        sleep_ms(10);\n    }\n}\n</code></pre>"},{"location":"SistemasEmbebidos/Tareas/#video","title":"Video","text":""},{"location":"SistemasEmbebidos/Tareas/#segunda-actividad_2","title":"Segunda actividad","text":"<p>Esta actividad consisti\u00f3 en que, utilizando conexi\u00f3n serial UART de 2 RPP2, se use la terminal para encender el led contrario con un comando escrito \"on\" y \"off\".</p>"},{"location":"SistemasEmbebidos/Tareas/#programa_9","title":"Programa","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n#include &lt;string&gt;\n\n#define UART_ID uart0\n#define BAUD_RATE 115200\n#define UART_TX_PIN 0\n#define UART_RX_PIN 1\n#define LED_PIN 2\n\nusing namespace std;\n\nint main() {\n    stdio_init_all(); // Inicializa USB serial\n    sleep_ms(2000);\n\n    printf(\"\\n[Pico listo] Comunicaci\u00f3n UART iniciando...\\n\");\n\n    // Inicializa UART antes de asignar pines\n    uart_init(UART_ID, BAUD_RATE);\n    gpio_set_function(UART_TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(UART_RX_PIN, GPIO_FUNC_UART);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n    uart_set_fifo_enabled(UART_ID, true);\n\n    // Configuraci\u00f3n del LED\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, GPIO_OUT);\n    gpio_put(LED_PIN, 0);\n\n    string mensaje_usb = \"\";\n    string mensaje_uart = \"\";\n\n    while (true) {\n        //Escritura mensaje\n        int ch = getchar_timeout_us(0); // no bloqueante\n        if (ch != PICO_ERROR_TIMEOUT) {\n            if (ch == '\\n' || ch == '\\r') {\n                if (!mensaje_usb.empty()) {\n                    uart_puts(UART_ID, (mensaje_usb + \"\\n\").c_str());\n                    printf(\"Mensaje enviado: %s\\n\", mensaje_usb.c_str());\n                    mensaje_usb = \"\";\n                }\n            } else {\n                mensaje_usb += (char)ch;\n            }\n        }\n\n        //Lectura en UART\n        while (uart_is_readable(UART_ID)) {\n            char ch_uart = uart_getc(UART_ID);\n\n            if (ch_uart == '\\n' || ch_uart == '\\r') {\n                if (!mensaje_uart.empty()) {\n                    printf(\"Mensaje recibido: %s\\n\", mensaje_uart.c_str());\n\n                    // Comparar informaci\u00f3n\n                    if (mensaje_uart == \"on\" || mensaje_uart == \"ON\") {\n                        gpio_put(LED_PIN, 1);\n                        printf(\"LED encendido\\n\");\n                    } else if (mensaje_uart == \"off\" || mensaje_uart == \"OFF\") {\n                        gpio_put(LED_PIN, 0);\n                        printf(\"LED apagado\\n\");\n                    } else {\n                        printf(\"Comando desconocido.\\n\");\n                    }\n\n                    mensaje_uart = \"\";\n                }\n            } else {\n                mensaje_uart += ch_uart;\n            }\n        }\n\n        sleep_ms(10);\n    }\n}\n</code></pre>"},{"location":"SistemasEmbebidos/Tareas/#video_1","title":"Video","text":""},{"location":"SistemasEmbebidos/Tareas/#tercera-actividad_1","title":"Tercera actividad","text":"<p>Esta actividad consisti\u00f3 en que, utilizando conexi\u00f3n serial UART de 2 RPP2, se confirme la conexi\u00f3n con un programa de comandos en la terminal tipo \"handshake\" para empezar a ejecutar el programa de la actividad anterior, el que trataba sobre encender el led contrario con un comando escrito \"on\" y \"off\".</p>"},{"location":"SistemasEmbebidos/Tareas/#programa-del-emisor-a","title":"Programa del emisor (A)","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n#include &lt;string&gt;\n\n#define UART_ID uart0\n#define BAUD_RATE 115200\n#define UART_TX_PIN 0\n#define UART_RX_PIN 1\n#define LED_PIN 2\n\nusing namespace std;\n\nint main() {\n    stdio_init_all();\n    sleep_ms(2000);\n\n    printf(\"\\n[Pico A listo] Escribe 'conectar' para iniciar handshake.\\n\");\n\n    uart_init(UART_ID, BAUD_RATE);\n    gpio_set_function(UART_TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(UART_RX_PIN, GPIO_FUNC_UART);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n    uart_set_fifo_enabled(UART_ID, true);\n\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, GPIO_OUT);\n    gpio_put(LED_PIN, 0);\n\n    string usb_msg = \"\";\n    string uart_msg = \"\";\n    bool conectado = false;\n\n    while (true) {\n        // Leer comandos desde USB\n        int ch = getchar_timeout_us(0);\n        if (ch != PICO_ERROR_TIMEOUT) {\n            if (ch == '\\n' || ch == '\\r') {\n                if (!usb_msg.empty()) {\n                    uart_puts(UART_ID, (usb_msg + \"\\n\").c_str());\n                    printf(\"[Enviado por UART]: %s\\n\", usb_msg.c_str());\n                    usb_msg = \"\";\n                }\n            } else usb_msg += (char)ch;\n        }\n\n        // Leer mensajes por UART\n        while (uart_is_readable(UART_ID)) {\n            char c = uart_getc(UART_ID);\n            if (c == '\\n' || c == '\\r') {\n                if (!uart_msg.empty()) {\n                    printf(\"[Recibido]: %s\\n\", uart_msg.c_str());\n\n                    if (!conectado) {\n                        if (uart_msg == \"ok\") {\n                            printf(\"Pico B respondi\u00f3 OK.\\n\");\n                        } else if (uart_msg == \"conectado\") {\n                            printf(\"Conexi\u00f3n establecida \\n\");\n                            conectado = true;\n                        } else {\n                            printf(\"[Error] Mensaje inesperado durante handshake.\\n\");\n                        }\n                    } else {\n                        if (uart_msg == \"on\" || uart_msg == \"ON\") {\n                            gpio_put(LED_PIN, 1);\n                            printf(\"[LED] Encendido (por comando remoto)\\n\");\n                        } else if (uart_msg == \"off\" || uart_msg == \"OFF\") {\n                            gpio_put(LED_PIN, 0);\n                            printf(\"[LED] Apagado (por comando remoto)\\n\");\n                        } else {\n                            printf(\"Error: Comando desconocido tras conexi\u00f3n.\\n\");\n                        }\n                    }\n                    uart_msg = \"\";\n                }\n            } else uart_msg += c;\n        }\n\n        sleep_ms(10);\n    }\n}\n</code></pre>"},{"location":"SistemasEmbebidos/Tareas/#programa-del-receptor-b","title":"Programa del receptor (B)","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n#include &lt;string&gt;\n\n#define UART_ID uart0\n#define BAUD_RATE 115200\n#define UART_TX_PIN 0\n#define UART_RX_PIN 1\n#define LED_PIN 2\n\nusing namespace std;\n\nint main() {\n    stdio_init_all();\n    sleep_ms(2000);\n\n    printf(\"\\nPico B listo, Esperando handshake desde el otro dispositivo...\\n\");\n\n    uart_init(UART_ID, BAUD_RATE);\n    gpio_set_function(UART_TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(UART_RX_PIN, GPIO_FUNC_UART);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n    uart_set_fifo_enabled(UART_ID, true);\n\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, GPIO_OUT);\n    gpio_put(LED_PIN, 0);\n\n    string uart_msg = \"\";\n    string usb_msg = \"\";\n    bool conectado = false;\n\n    while (true) {\n        // Leer mensajes entrantes por UART\n        while (uart_is_readable(UART_ID)) {\n            char c = uart_getc(UART_ID);\n            if (c == '\\n' || c == '\\r') {\n                if (!uart_msg.empty()) {\n                    printf(\"Recibido: %s\\n\", uart_msg.c_str());\n\n                    if (!conectado) {\n                        if (uart_msg == \"conectar\") {\n                            uart_puts(UART_ID, \"ok\\n\");\n                            sleep_ms(300);\n                            uart_puts(UART_ID, \"conectado\\n\");\n                            conectado = true;\n                            printf(\"Conexi\u00f3n establecida\\n\");\n                        } else {\n                            uart_puts(UART_ID, \"error\\n\");\n                            printf(\"Error, mensaje inesperado durante handshake.\\n\");\n                        }\n                    } else {\n                        if (uart_msg == \"on\" || uart_msg == \"ON\") {\n                            gpio_put(LED_PIN, 1);\n                            printf(\"LED encendido\\n\");\n                        } else if (uart_msg == \"off\" || uart_msg == \"OFF\") {\n                            gpio_put(LED_PIN, 0);\n                            printf(\"LED apagado\\n\");\n                        } else {\n                            printf(\"[Error] Comando desconocido tras conexi\u00f3n.\\n\");\n                        }\n                    }\n                    uart_msg = \"\";\n                }\n            } else uart_msg += c;\n        }\n\n\n        int ch = getchar_timeout_us(0);\n        if (ch != PICO_ERROR_TIMEOUT) {\n            if (ch == '\\n' || ch == '\\r') {\n                if (!usb_msg.empty()) {\n                    uart_puts(UART_ID, (usb_msg + \"\\n\").c_str());\n                    printf(\"[Enviado por UART]: %s\\n\", usb_msg.c_str());\n                    usb_msg = \"\";\n                }\n            } else usb_msg += (char)ch;\n        }\n\n        sleep_ms(10);\n    }\n}\n</code></pre>"},{"location":"SistemasEmbebidos/Tareas/#video_2","title":"Video","text":""},{"location":"SistemasEmbebidos/Tema_J/","title":"I2C (Inter-Integrated Circuit)","text":""},{"location":"SistemasEmbebidos/Tema_J/#introduccion","title":"Introduccion","text":""},{"location":"SistemasEmbebidos/Tema_J/#que-es-i2c","title":"\u00bfQue es I2C?","text":"<ul> <li>Bus serial s\u00edncrono de dos l\u00edneas:<ul> <li>SCL (clock) y SDA (datos).</li> </ul> </li> <li>Arquitectura multidispositivo sobre el mismo par de hilos.</li> <li>Comunicaci\u00f3n m\u00e1ster \u2194 esclavo (en la pr\u00e1ctica: controller \u2194 target).</li> <li>Cada target tiene una direcci\u00f3n (7 o 10 bits) en el bus.</li> </ul>"},{"location":"SistemasEmbebidos/Tema_J/#cuando-conviene-usar-i2c","title":"\u00bfCu\u00e1ndo conviene usar I\u00b2C?","text":"<ul> <li>Conectar muchos perif\u00e9ricos con pocos pines.</li> <li>Dispositivos t\u00edpicos: sensores (temperatura, IMU), ADC/DAC, GPIO expanders, pantallas (OLED), EEPROM.</li> <li>Velocidades modestas: 100 kbps (Standard), 400 kbps (Fast), 1 Mbps (Fm+), 3.4 Mbps (Hs). (Para flujos m\u00e1s altos o enlaces punto a punto, SPI suele ser mejor; para texto/terminal, UART).</li> </ul>"},{"location":"SistemasEmbebidos/Tema_J/#hardware","title":"Hardware","text":"<p>$$ R_p(min)= \\frac{V_{cc}-V_{oL}(max)}{I_{oL}} $$</p> <p>Donde $V_{oL}(max)$ es el voltaje m\u00e1ximo que el dispositivo garantiza en LOW (normalmente 0.4 V) e $I_{oL}$ es la corriente que el dispositivo puede absorber en LOW (normalmente 3 mA). $$ R_p(min)= \\frac{3.3V-0.4V}{3mA}=966.67 \\Omega $$</p> <p>$$ R_p(max)= \\frac{t_r}{0.8473 \\cdot C_b} $$ Donde $t_r$ es el tiempo m\u00e1ximo de subida permitido (1000 ns para 100 kHz, 300 ns para 400 kHz, 120 ns para 1 MHz) y $C_b$ es la capacitancia total del bus (incluyendo cables, PCB y dispositivos).</p> <p>Tipicamente usamos los siguientes valores:</p> <ul> <li>100 kHz: 4.7 k\u03a9 y hasta 10 k\u03a9 puede funcionar.</li> <li>400 kHz: 2.2\u20134.7 k\u03a9.</li> <li>1 MHz (Fm+): 1\u20132.2 k\u03a9.</li> </ul>"},{"location":"SistemasEmbebidos/Tema_J/#pines-i2c-en-raspberry-pi-pico-2","title":"Pines I2C en Raspberry Pi Pico 2","text":"<p>I2C0 - SDA pins: GP0, GP4, GP8, GP12, GP16, GP20 - SCL pins: GP1, GP5, GP9, GP13, GP17, GP21</p> <p>I2C1 - SDA pins: GP2, GP6, GP10, GP14, GP18, GP26 - SCL pins: GP3, GP7, GP11, GP15, GP19, GP27</p>"},{"location":"SistemasEmbebidos/Tema_J/#protocolo","title":"Protocolo","text":""},{"location":"SistemasEmbebidos/Tema_J/#formato-de-mensaje","title":"Formato de mensaje","text":"<ul> <li><code>START</code>: SDA cae (HIGH\u2192LOW) mientras SCL est\u00e1 HIGH; inicio de transacci\u00f3n (maestro).</li> <li><code>Address + R/W</code>: Byte con direcci\u00f3n (7 bits) + bit R/W; selecciona esclavo y sentido (maestro).</li> <li><code>ACK/NACK</code>: Bit de acuse tras cada byte; lo da el receptor (esclavo en write, maestro en read).</li> <li><code>DATA</code>: Bytes MSB\u2192LSB; en write los env\u00eda el maestro, en read los env\u00eda el esclavo.</li> <li><code>REPEATED START (Sr)</code>: Nuevo START sin STOP previo; encadena operaciones sin soltar el bus (maestro).</li> <li><code>STOP</code>: SDA sube (LOW\u2192HIGH) mientras SCL est\u00e1 HIGH; fin de transacci\u00f3n y libera bus (maestro).</li> </ul>"},{"location":"SistemasEmbebidos/Tema_J/#secuencias-comunes","title":"Secuencias comunes","text":""},{"location":"SistemasEmbebidos/Tema_J/#api-de-i2c-en-raspberry-pi-pico-sdk","title":"API de I2C en Raspberry Pi Pico SDK","text":"<ul> <li><code>i2c_init(i2c, baudrate)</code> inicializa el perif\u00e9rico I\u00b2C y fija la velocidad, donde:<ul> <li><code>i2c</code> es el puntero a la instancia (<code>i2c0</code> o <code>i2c1</code>).</li> <li><code>baudrate</code> es la velocidad objetivo en Hz (p. ej. <code>100000</code>, <code>400000</code>).</li> <li>Retorna: <code>uint</code> con la velocidad realmente aplicada.</li> </ul> </li> <li><code>i2c_deinit(i2c)</code> apaga/deshabilita el perif\u00e9rico I\u00b2C, donde:<ul> <li><code>i2c</code> es la instancia (<code>i2c0</code> o <code>i2c1</code>).</li> <li>Retorna: nada.</li> </ul> </li> <li><code>i2c_set_baudrate(i2c, baudrate)</code> cambia la velocidad en caliente, donde:<ul> <li><code>i2c</code> es la instancia.</li> <li><code>baudrate</code> es la nueva velocidad en Hz.</li> <li>Retorna: <code>uint</code> con la velocidad realmente aplicada.</li> </ul> </li> <li><code>i2c_write_blocking(i2c, addr, src, len, nostop)</code> env\u00eda bytes al esclavo (bloqueante), donde:<ul> <li><code>i2c</code> es la instancia.</li> <li><code>addr</code> es la direcci\u00f3n de 7 bits del esclavo (ej. <code>0x8A</code>).</li> <li><code>src</code> es puntero a la memoria con los datos a transmitir.</li> <li><code>len</code> es el n\u00famero de bytes a enviar desde <code>src</code>.</li> <li><code>nostop</code> si es <code>true</code> no emite STOP (prepara REPEATED START); si es <code>false</code> s\u00ed emite STOP.</li> <li>Retorna: <code>int</code> con bytes escritos (deber\u00eda ser <code>len</code>) o &lt;0 en error (NACK/timeout).</li> </ul> </li> <li><code>i2c_read_blocking(i2c, addr, dst, len, nostop)</code> lee bytes del esclavo (bloqueante), donde:<ul> <li><code>i2c</code> es la instancia.</li> <li><code>addr</code> es la direcci\u00f3n de 7 bits del esclavo.</li> <li><code>dst</code> es puntero a la memoria destino para almacenar los datos le\u00eddos.</li> <li><code>len</code> es el n\u00famero de bytes a leer hacia <code>dst</code>.</li> <li><code>nostop</code> si es <code>true</code> no emite STOP al final; si es <code>false</code> emite STOP (el hardware NACKea el \u00faltimo byte).</li> <li>Retorna: <code>int</code> con bytes le\u00eddos (deber\u00eda ser <code>len</code>) o &lt;0 en error.</li> </ul> </li> <li><code>i2c_write_timeout_us(i2c, addr, src, len, nostop, timeout_us)</code> igual que <code>i2c_write_blocking</code> pero con timeout, donde:<ul> <li><code>timeout_us</code> es el tiempo m\u00e1ximo en microsegundos.</li> <li>Retorna: bytes escritos, <code>PICO_ERROR_TIMEOUT</code> si expira, o &lt;0 en otros errores.</li> </ul> </li> <li><code>i2c_read_timeout_us(i2c, addr, dst, len, nostop, timeout_us)</code> igual que <code>i2c_read_blocking</code> pero con timeout, donde:<ul> <li><code>timeout_us</code> es el tiempo m\u00e1ximo en microsegundos.</li> <li>Retorna: bytes le\u00eddos, <code>PICO_ERROR_TIMEOUT</code> si expira, o &lt;0 en otros errores.</li> </ul> </li> </ul>"},{"location":"SistemasEmbebidos/Tema_J/#cmakeliststxt","title":"CMakeLists.txt","text":"<p>Para poder ocupar I2C es necesario agregar la libreria de hardware_i2c en el CMakeLists.txt de nuestro proyecto: <pre><code>target_link_libraries(i2c_demo\n    pico_stdlib\n    hardware_i2c          # &lt;-- A\u00d1ADIR esta l\u00ednea\n)\n</code></pre></p>"},{"location":"SistemasEmbebidos/Tema_J/#ejemplo-basico-de-uso-escritura","title":"Ejemplo b\u00e1sico de uso Escritura","text":"<p>Siguiendo la siguiente transaccion:</p> <ol> <li><code>START</code> inicio de la comunicacion</li> <li><code>Address + W \u2192 ACK (esclavo)</code> indico con quien me voy a comunicar</li> <li><code>Data (registro) \u2192 ACK (esclavo)</code> indico donde quiero escribir el valor</li> <li><code>Data (valor) \u2192 ACK (esclavo)</code> indico que valor quiero escribir</li> <li><code>STOP</code> fin de la comunicacion</li> </ol> i2c_escribe<pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n#include \"hardware/i2c.h\"\n\n#define I2C_PORT    i2c0\n#define SDA_PIN     4\n#define SCL_PIN     5\n#define ADDR 0x8A //Direccion del dispositivo esclavo de 7 bits\n\nint main(void) {\n    stdio_init_all();\n    //Configura el inicio de i2c con una velocidad de 100 KHz\n    i2c_init(I2C_PORT, 100000);\n    //Configura los pines para trabajar como i2c\n    gpio_set_function(SDA_PIN, GPIO_FUNC_I2C);\n    gpio_set_function(SCL_PIN, GPIO_FUNC_I2C);\n    //Habilita pullup interno para pines\n    gpio_pull_up(SDA_PIN);\n    gpio_pull_up(SCL_PIN);\n\n    sleep_ms(500);\n    uint8_t reg = 0x00; //Registro a escribir     \n    uint8_t value = 0x67; //Valor a escribir  \n    uint8_t value2 = 0x42; //Valor a escribir   \n    uint8_t memoria[3];\n    while (true) {\n        memoria[0] = reg;\n        memoria[1] = value;\n        memoria[2] = value2;\n\n        /*OPCION 1 TODO JUNTO*/\n        // START + addr|W + WRITE(reg) + ACK  \n        int w = i2c_write_blocking(I2C_PORT, ADDR, memoria, sizeof(memoria), /*nostop=*/false);\n        if (w &lt; 0) {\n        printf(\"I2C error (ret=%d)\\n\", w);\n        } else if (w != (int)sizeof(memoria)) {\n            printf(\"Escritura parcial: %d/%d bytes\\n\", w, (int)sizeof(memoria));\n        } else {\n            printf(\"Escrito correctamente\\n\");\n        }\n        sleep_ms(1000);\n    }\n    return 0;\n}\n</code></pre>"},{"location":"SistemasEmbebidos/Tema_J/#ejemplo-basico-de-uso-lectura","title":"Ejemplo b\u00e1sico de uso Lectura","text":"<ol> <li><code>START</code> inicio de la comunicacion</li> <li><code>Address + W \u2192 ACK (esclavo)</code> indico con quien me voy a comunicar en escritura</li> <li><code>Data (registro) \u2192 ACK (esclavo)</code> Escribo de donde quiero leer</li> <li><code>REPEATED START</code> Reinicio la comunicacion</li> <li><code>Address + R \u2192 ACK (esclavo)</code> indico con quien me voy a comunicar pero en lectura</li> <li><code>Data byte(s) \u2192 ACK (maestro)</code> Leo el/los byte(s) solicitados</li> <li><code>\u00daltimo Data \u2192 NACK (maestro)</code> Indico que es el \u00faltimo byte que voy a leer</li> <li><code>STOP</code></li> </ol> i2c_leer<pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n#include \"hardware/i2c.h\"\n\n#define I2C_PORT    i2c0\n#define SDA_PIN     4\n#define SCL_PIN     5\n#define ADDR 0x2A //Direccion del dispositivo esclavo de 7 bits\n\nint main(void) {\n    stdio_init_all();\n    //Configura el inicio de i2c con una velocidad de 100 KHz\n    i2c_init(I2C_PORT, 100000);\n    //Configura los pines para trabajar como i2c\n    gpio_set_function(SDA_PIN, GPIO_FUNC_I2C);\n    gpio_set_function(SCL_PIN, GPIO_FUNC_I2C);\n    //Habilita pullup interno para pines\n    gpio_pull_up(SDA_PIN);\n    gpio_pull_up(SCL_PIN);\n\n    sleep_ms(500);\n    uint8_t reg = 0x00; //Registro a Leer       \n    uint8_t memoria[3]; //Leeremos 3 bytes\n    while (true) {\n        // START + addr|W + WRITE(reg) + ACK  + NoStop\n        int w = i2c_write_blocking(I2C_PORT, ADDR, &amp;reg, 1, /*nostop=*/true);\n        if (w &lt; 0) {\n            printf(\"I2C error (ret=%d)\\n\", w);\n            goto next;\n        } else if (w != 1) {\n            printf(\"Escritura parcial: %d/1 bytes\\n\", w);\n            goto next;\n        } else {\n            printf(\"Escrito correctamente\\n\");\n        }\n        // REPEATED START + addr|R + READ(data) + NACK + STOP\n        int r = i2c_read_blocking(I2C_PORT, ADDR, memoria, sizeof(memoria), /*nostop=*/false);\n        if (r &lt; 0) {\n            printf(\"I2C error (ret=%d)\\n\", r);\n        } else if (r != (int)sizeof(memoria)) {\n            printf(\"Lectura parcial: %d/%d bytes\\n\", r, (int)sizeof(memoria));\n            printf(\"Datos leidos: \");\n            for (int i = 0; i &lt; r; i++) {\n                printf(\"0x%02X \", memoria[i]);\n            }\n        } else {\n            printf(\"Leido correctamente\\n\");\n            printf(\"Datos leidos: \\n\");\n            for (int i = 0; i &lt; (int)sizeof(memoria); i++) {\n                printf(\"0x%02X \\n\", memoria[i]);\n            }\n        } \n        next:\n            sleep_ms(1000);\n    }\n    return 0;\n}\n</code></pre>"}]}